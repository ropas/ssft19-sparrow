/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 73 "/home/khheo/testset/make-3.76.1/signame.c"
struct __anonstruct_num_abbrev_45 {
   int number ;
   char const   *abbrev ;
};
#line 73 "/home/khheo/testset/make-3.76.1/signame.c"
typedef struct __anonstruct_num_abbrev_45 num_abbrev;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h"
typedef unsigned long size_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 35 "/usr/include/ar.h"
struct ar_hdr {
   char ar_name[16] ;
   char ar_date[12] ;
   char ar_uid[6] ;
   char ar_gid[6] ;
   char ar_mode[8] ;
   char ar_size[10] ;
   char ar_fmag[2] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 337 "/home/khheo/testset/make-3.76.1/make.h"
struct dep;
#line 23 "/home/khheo/testset/make-3.76.1/filedef.h"
struct commands;
#line 23
struct variable_set_list;
#line 23
enum __anonenum_command_state_55 {
    cs_not_started = 0,
    cs_deps_running = 1,
    cs_running = 2,
    cs_finished = 3
} ;
#line 23 "/home/khheo/testset/make-3.76.1/filedef.h"
struct file {
   struct file *next ;
   char *name ;
   char *hname ;
   char *vpath ;
   struct dep *deps ;
   struct commands *cmds ;
   int command_flags ;
   char *stem ;
   struct dep *also_make ;
   time_t last_mtime ;
   struct file *prev ;
   struct file *renamed ;
   struct variable_set_list *variables ;
   struct file *parent ;
   struct file *double_colon ;
   short update_status ;
   enum __anonenum_command_state_55 command_state : 2 ;
   unsigned int precious : 1 ;
   unsigned int tried_implicit : 1 ;
   unsigned int updating : 1 ;
   unsigned int updated : 1 ;
   unsigned int is_target : 1 ;
   unsigned int cmd_target : 1 ;
   unsigned int phony : 1 ;
   unsigned int intermediate : 1 ;
   unsigned int secondary : 1 ;
   unsigned int dontcare : 1 ;
   unsigned int ignore_vpath : 1 ;
};
#line 25 "/home/khheo/testset/make-3.76.1/dep.h"
struct dep {
   struct dep *next ;
   char *name ;
   struct file *file ;
   int changed ;
};
#line 36 "/home/khheo/testset/make-3.76.1/dep.h"
struct nameseq {
   struct nameseq *next ;
   char *name ;
};
#line 200 "/home/khheo/testset/make-3.76.1/ar.c"
struct ar_glob_state {
   char *arname ;
   char *pattern ;
   unsigned int size ;
   struct nameseq *chain ;
   unsigned int n ;
};
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 21 "/home/khheo/testset/make-3.76.1/variable.h"
enum variable_origin {
    o_default = 0,
    o_env = 1,
    o_file = 2,
    o_env_override = 3,
    o_command = 4,
    o_override = 5,
    o_automatic = 6,
    o_invalid = 7
} ;
#line 37
enum __anonenum_export_56 {
    v_export = 0,
    v_noexport = 1,
    v_ifset = 2,
    v_default = 3
} ;
#line 37 "/home/khheo/testset/make-3.76.1/variable.h"
struct variable {
   struct variable *next ;
   char *name ;
   char *value ;
   enum variable_origin origin : 3 ;
   unsigned int recursive : 1 ;
   unsigned int expanding : 1 ;
   enum __anonenum_export_56 export : 2 ;
};
#line 57 "/home/khheo/testset/make-3.76.1/variable.h"
struct variable_set {
   struct variable **table ;
   unsigned int buckets ;
};
#line 65 "/home/khheo/testset/make-3.76.1/variable.h"
struct variable_set_list {
   struct variable_set_list *next ;
   struct variable_set *set ;
};
#line 29 "/home/khheo/testset/make-3.76.1/vpath.c"
struct vpath {
   struct vpath *next ;
   char *pattern ;
   char *percent ;
   unsigned int patlen ;
   char **searchpath ;
   unsigned int maxlen ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 22 "/home/khheo/testset/make-3.76.1/commands.h"
struct commands {
   char *filename ;
   unsigned int lineno ;
   char *commands ;
   unsigned int ncommand_lines ;
   char **command_lines ;
   char *lines_flags ;
   int any_recurse ;
};
#line 221 "/home/khheo/testset/make-3.76.1/function.c"
enum function {
    function_subst = 0,
    function_addsuffix = 1,
    function_addprefix = 2,
    function_dir = 3,
    function_notdir = 4,
    function_suffix = 5,
    function_basename = 6,
    function_wildcard = 7,
    function_firstword = 8,
    function_word = 9,
    function_words = 10,
    function_wordlist = 11,
    function_findstring = 12,
    function_strip = 13,
    function_join = 14,
    function_patsubst = 15,
    function_filter = 16,
    function_filter_out = 17,
    function_foreach = 18,
    function_sort = 19,
    function_origin = 20,
    function_shell = 21,
    function_invalid = 22
} ;
#line 253 "/home/khheo/testset/make-3.76.1/function.c"
struct __anonstruct_function_table_57 {
   char *name ;
   unsigned int len ;
   enum function function ;
};
#line 885 "/home/khheo/testset/make-3.76.1/function.c"
struct word {
   struct word *next ;
   char *word ;
   int matched ;
};
#line 451 "/home/khheo/testset/make-3.76.1/variable.c"
struct variable_bucket {
   struct variable_bucket *next ;
   struct variable *variable ;
};
#line 630
enum __anonenum_flavor_57 {
    bogus = 0,
    simple = 1,
    recursive = 2,
    append = 3
} ;
#line 34 "/home/khheo/testset/make-3.76.1/rule.h"
struct pspec {
   char *target ;
   char *dep ;
   char *commands ;
};
#line 21 "/home/khheo/testset/make-3.76.1/rule.h"
struct rule {
   struct rule *next ;
   char **targets ;
   unsigned int *lens ;
   char **suffixes ;
   struct dep *deps ;
   struct commands *cmds ;
   char terminal ;
   char in_use ;
};
#line 86 "/home/khheo/testset/make-3.76.1/glob/glob.h"
struct dirent;
#line 86 "/home/khheo/testset/make-3.76.1/glob/glob.h"
struct __anonstruct_glob_t_57 {
   int gl_pathc ;
   char **gl_pathv ;
   int gl_offs ;
   int gl_flags ;
   void (*gl_closedir)(void * ) ;
   struct dirent *(*gl_readdir)(void * ) ;
   void *(*gl_opendir)(char const   * ) ;
   int (*gl_lstat)(char const   * , struct stat * ) ;
   int (*gl_stat)(char const   * , struct stat * ) ;
};
#line 86 "/home/khheo/testset/make-3.76.1/glob/glob.h"
typedef struct __anonstruct_glob_t_57 glob_t;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 47 "/home/khheo/testset/make-3.76.1/read.c"
struct linebuffer {
   unsigned int size ;
   char *buffer ;
};
#line 68 "/home/khheo/testset/make-3.76.1/read.c"
struct conditionals {
   unsigned int if_cmds ;
   unsigned int allocated ;
   char *ignoring ;
   char *seen_else ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 551 "/home/khheo/testset/make-3.76.1/misc.c"
enum __anonenum_current_access_55 {
    make = 0,
    user = 1
} ;
#line 48 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 206 "/home/khheo/testset/make-3.76.1/dir.c"
struct dirfile;
#line 206 "/home/khheo/testset/make-3.76.1/dir.c"
struct directory_contents {
   struct directory_contents *next ;
   dev_t dev ;
   ino_t ino ;
   struct dirfile **files ;
   DIR *dirstream ;
};
#line 240 "/home/khheo/testset/make-3.76.1/dir.c"
struct directory {
   struct directory *next ;
   char *name ;
   struct directory_contents *contents ;
};
#line 265 "/home/khheo/testset/make-3.76.1/dir.c"
struct dirfile {
   struct dirfile *next ;
   char *name ;
   char impossible ;
};
#line 936 "/home/khheo/testset/make-3.76.1/dir.c"
struct dirstream {
   struct directory_contents *contents ;
   unsigned int bucket ;
   struct dirfile *elt ;
};
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_49 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_50 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_49 __wait_terminated ;
   struct __anonstruct___wait_stopped_50 __wait_stopped ;
};
#line 24 "/home/khheo/testset/make-3.76.1/job.h"
struct child {
   struct child *next ;
   struct file *file ;
   char **environment ;
   char **command_lines ;
   unsigned int command_line ;
   char *command_ptr ;
   pid_t pid ;
   unsigned int remote : 1 ;
   unsigned int noerror : 1 ;
   unsigned int good_stdin : 1 ;
   unsigned int deleted : 1 ;
};
#line 405 "/home/khheo/testset/make-3.76.1/job.c"
union __anonunion_57 {
   int __in ;
   int __i ;
};
#line 406 "/home/khheo/testset/make-3.76.1/job.c"
union __anonunion_58 {
   int __in ;
   int __i ;
};
#line 406 "/home/khheo/testset/make-3.76.1/job.c"
union __anonunion_59 {
   int __in ;
   int __i ;
};
#line 406 "/home/khheo/testset/make-3.76.1/job.c"
union __anonunion_60 {
   int __in ;
   int __i ;
};
#line 407 "/home/khheo/testset/make-3.76.1/job.c"
union __anonunion_61 {
   int __in ;
   int __i ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 81 "./getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 72 "/home/khheo/testset/make-3.76.1/main.c"
enum __anonenum_type_57 {
    flag = 0,
    flag_off = 1,
    string = 2,
    positive_int = 3,
    floating = 4,
    ignore = 5
} ;
#line 72 "/home/khheo/testset/make-3.76.1/main.c"
struct command_switch {
   char c ;
   enum __anonenum_type_57 type ;
   char *value_ptr ;
   unsigned int env : 1 ;
   unsigned int toenv : 1 ;
   unsigned int no_makefile : 1 ;
   char *noarg_value ;
   char *default_value ;
   char *long_name ;
   char *argdesc ;
   char *description ;
};
#line 104 "/home/khheo/testset/make-3.76.1/main.c"
struct stringlist {
   char **list ;
   unsigned int idx ;
   unsigned int max ;
};
#line 356 "/home/khheo/testset/make-3.76.1/main.c"
struct command_variable {
   struct command_variable *next ;
   struct variable *variable ;
};
#line 2071 "/home/khheo/testset/make-3.76.1/main.c"
struct flag {
   struct flag *next ;
   struct command_switch  const  *cs ;
   char *arg ;
};
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 23 "/home/khheo/testset/make-3.76.1/signame.h"
void signame_init(void) ;
#line 28
char *sig_abbrev(int number ) ;
#line 32
int sig_number(char const   *abbrev ) ;
#line 78 "/home/khheo/testset/make-3.76.1/signame.c"
static num_abbrev sig_table[130]  ;
#line 80 "/home/khheo/testset/make-3.76.1/signame.c"
static int sig_table_nelts  =    0;
#line 84 "/home/khheo/testset/make-3.76.1/signame.c"
static void init_sig(int number , char const   *abbrev , char const   *name___0 ) 
{ 
  int tmp ;

  {
#line 93
  sig_table[sig_table_nelts].number = number;
#line 94
  tmp = sig_table_nelts;
#line 94
  sig_table_nelts ++;
#line 94
  sig_table[tmp].abbrev = abbrev;
#line 95
  return;
}
}
#line 97 "/home/khheo/testset/make-3.76.1/signame.c"
void signame_init(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;

  {
  {
#line 109
  init_sig(1, "HUP", "Hangup");
#line 112
  init_sig(2, "INT", "Interrupt");
#line 115
  init_sig(3, "QUIT", "Quit");
#line 118
  init_sig(4, "ILL", "Illegal Instruction");
#line 121
  init_sig(5, "TRAP", "Trace/breakpoint trap");
#line 126
  init_sig(6, "ABRT", "Aborted");
#line 129
  init_sig(6, "IOT", "IOT trap");
#line 135
  init_sig(8, "FPE", "Floating point exception");
#line 138
  init_sig(9, "KILL", "Killed");
#line 141
  init_sig(7, "BUS", "Bus error");
#line 144
  init_sig(11, "SEGV", "Segmentation fault");
#line 147
  init_sig(31, "SYS", "Bad system call");
#line 150
  init_sig(13, "PIPE", "Broken pipe");
#line 153
  init_sig(14, "ALRM", "Alarm clock");
#line 156
  init_sig(15, "TERM", "Terminated");
#line 159
  init_sig(10, "USR1", "User defined signal 1");
#line 162
  init_sig(12, "USR2", "User defined signal 2");
#line 167
  init_sig(17, "CHLD", "Child exited");
#line 170
  init_sig(17, "CLD", "Child exited");
#line 173
  init_sig(30, "PWR", "Power failure");
#line 176
  init_sig(20, "TSTP", "Stopped");
#line 179
  init_sig(21, "TTIN", "Stopped (tty input)");
#line 182
  init_sig(22, "TTOU", "Stopped (tty output)");
#line 185
  init_sig(19, "STOP", "Stopped (signal)");
#line 188
  init_sig(24, "XCPU", "CPU time limit exceeded");
#line 191
  init_sig(25, "XFSZ", "File size limit exceeded");
#line 194
  init_sig(26, "VTALRM", "Virtual timer expired");
#line 197
  init_sig(27, "PROF", "Profiling timer expired");
#line 203
  init_sig(28, "WINCH", "Window changed");
#line 206
  init_sig(18, "CONT", "Continued");
#line 209
  init_sig(23, "URG", "Urgent I/O condition");
#line 216
  init_sig(29, "IO", "I/O possible");
#line 225
  init_sig(29, "POLL", "I/O possible");
  }
#line 239
  return;
}
}
#line 243 "/home/khheo/testset/make-3.76.1/signame.c"
char *sig_abbrev(int number ) 
{ 
  int i ;

  {
#line 249
  if (sig_table_nelts == 0) {
    {
#line 250
    signame_init();
    }
  }
#line 252
  i = 0;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! (i < sig_table_nelts)) {
#line 252
      goto while_break;
    }
#line 253
    if (sig_table[i].number == number) {
#line 254
      return ((char *)sig_table[i].abbrev);
    }
#line 252
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  return ((char *)((void *)0));
}
}
#line 261 "/home/khheo/testset/make-3.76.1/signame.c"
int sig_number(char const   *abbrev ) 
{ 
  int i ;
  int tmp ;

  {
#line 267
  if (sig_table_nelts == 0) {
    {
#line 268
    signame_init();
    }
  }
#line 271
  if ((int const   )*(abbrev + 0) == 83) {
#line 271
    if ((int const   )*(abbrev + 1) == 73) {
#line 271
      if ((int const   )*(abbrev + 2) == 71) {
#line 272
        abbrev += 3;
      }
    }
  }
#line 274
  i = 0;
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! (i < sig_table_nelts)) {
#line 274
      goto while_break;
    }
#line 275
    if ((int const   )*(abbrev + 0) == (int const   )*(sig_table[i].abbrev + 0)) {
      {
#line 275
      tmp = strcmp(abbrev, sig_table[i].abbrev);
      }
#line 275
      if (tmp == 0) {
#line 277
        return (sig_table[i].number);
      }
    }
#line 274
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 278
  return (-1);
}
}
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 426 "/home/khheo/testset/make-3.76.1/make.h"
char *remote_description ;
#line 25 "/home/khheo/testset/make-3.76.1/remote-stub.c"
char *remote_description  =    (char *)0;
#line 29 "/home/khheo/testset/make-3.76.1/remote-stub.c"
void remote_setup(void) 
{ 


  {
#line 32
  return;
}
}
#line 36 "/home/khheo/testset/make-3.76.1/remote-stub.c"
void remote_cleanup(void) 
{ 


  {
#line 39
  return;
}
}
#line 43 "/home/khheo/testset/make-3.76.1/remote-stub.c"
int start_remote_job_p(void) 
{ 


  {
#line 46
  return (0);
}
}
#line 56 "/home/khheo/testset/make-3.76.1/remote-stub.c"
int start_remote_job(char **argv , char **envp , int stdin_fd , int *is_remote , int *id_ptr ,
                     int *used_stdin ) 
{ 


  {
#line 64
  return (-1);
}
}
#line 73 "/home/khheo/testset/make-3.76.1/remote-stub.c"
int remote_status(int *exit_code_ptr , int *signal_ptr , int *coredump_ptr , int block ) 
{ 
  int *tmp ;

  {
  {
#line 78
  tmp = __errno_location();
#line 78
  *tmp = 10;
  }
#line 79
  return (-1);
}
}
#line 85 "/home/khheo/testset/make-3.76.1/remote-stub.c"
void block_remote_children(void) 
{ 


  {
#line 88
  return;
}
}
#line 94 "/home/khheo/testset/make-3.76.1/remote-stub.c"
void unblock_remote_children(void) 
{ 


  {
#line 97
  return;
}
}
#line 101 "/home/khheo/testset/make-3.76.1/remote-stub.c"
int remote_kill(int id , int sig ) 
{ 


  {
#line 106
  return (-1);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 150
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 249 "/home/khheo/testset/make-3.76.1/arscan.c"
long ar_scan(char *archive , long (*function)() , long arg ) 
{ 
  int long_name ;
  char *namemap ;
  register int desc ;
  int tmp ;
  char buf___0[8] ;
  register int nread ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  register long member_offset ;
  register int nread___0 ;
  struct ar_hdr member_header ;
  char namebuf[sizeof(member_header.ar_name) + 1UL] ;
  char *name___0 ;
  int is_namemap ;
  long eltsize ;
  int eltmode ;
  long fnval ;
  __off_t tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  register char *p ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int namesize ;
  int tmp___9 ;
  void *tmp___10 ;
  ssize_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  char *clear ;
  char *limit ;
  void *tmp___15 ;
  ssize_t tmp___16 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;

  {
  {
#line 258
  long_name = 0;
#line 260
  namemap = (char *)0;
#line 261
  tmp = open((char const   *)archive, 0, 0);
#line 261
  desc = tmp;
  }
#line 262
  if (desc < 0) {
#line 263
    return (-1L);
  }
  {
#line 267
  tmp___0 = read(desc, (void *)(buf___0), (size_t )8);
#line 267
  nread = (int )tmp___0;
  }
#line 268
  if (nread != 8) {
    {
#line 270
    close(desc);
    }
#line 271
    return (-2L);
  } else {
    {
#line 268
    tmp___1 = memcmp((void const   *)(buf___0), (void const   *)"!<arch>\n", (size_t )8);
    }
#line 268
    if (tmp___1) {
      {
#line 270
      close(desc);
      }
#line 271
      return (-2L);
    }
  }
#line 304
  member_offset = 8L;
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 347
    tmp___2 = lseek(desc, member_offset, 0);
    }
#line 347
    if (tmp___2 < 0L) {
      {
#line 349
      close(desc);
      }
#line 350
      return (-2L);
    }
    {
#line 390
    tmp___3 = read(desc, (void *)((char *)(& member_header)), sizeof(struct ar_hdr ));
#line 390
    nread___0 = (int )tmp___3;
    }
#line 391
    if (nread___0 == 0) {
#line 393
      goto while_break;
    }
#line 395
    if ((unsigned long )nread___0 != sizeof(struct ar_hdr )) {
      {
#line 401
      close(desc);
      }
#line 402
      return (-2L);
    } else {
      {
#line 395
      tmp___4 = memcmp((void const   *)(member_header.ar_fmag), (void const   *)"`\n",
                       (size_t )2);
      }
#line 395
      if (tmp___4) {
        {
#line 401
        close(desc);
        }
#line 402
        return (-2L);
      }
    }
    {
#line 405
    name___0 = namebuf;
#line 406
    memmove((void *)name___0, (void const   *)(member_header.ar_name), sizeof(member_header.ar_name));
#line 408
    p = name___0 + sizeof(member_header.ar_name);
    }
    {
#line 409
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 410
      *p = (char )'\000';
#line 409
      if ((unsigned long )p > (unsigned long )name___0) {
#line 409
        p --;
#line 409
        if (! ((int )*p == 32)) {
#line 409
          goto while_break___0;
        }
      } else {
#line 409
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 420
    tmp___5 = strcmp((char const   *)name___0, "//");
    }
#line 420
    if (tmp___5) {
      {
#line 420
      tmp___6 = strcmp((char const   *)name___0, "ARFILENAMES/");
      }
#line 420
      if (tmp___6) {
#line 420
        tmp___7 = 0;
      } else {
#line 420
        tmp___7 = 1;
      }
    } else {
#line 420
      tmp___7 = 1;
    }
#line 420
    is_namemap = tmp___7;
#line 424
    if ((int )*p == 47) {
#line 425
      *p = (char )'\000';
    }
#line 433
    if (! is_namemap) {
#line 433
      if ((int )*(name___0 + 0) == 32) {
#line 433
        goto _L___1;
      } else
#line 433
      if ((int )*(name___0 + 0) == 47) {
        _L___1: /* CIL Label */ 
#line 433
        if ((unsigned long )namemap != (unsigned long )((char *)0)) {
          {
#line 437
          tmp___8 = atoi((char const   *)(name___0 + 1));
#line 437
          name___0 = namemap + tmp___8;
#line 438
          long_name = 1;
          }
        } else {
#line 433
          goto _L___0;
        }
      } else {
#line 433
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 440
    if ((int )*(name___0 + 0) == 35) {
#line 440
      if ((int )*(name___0 + 1) == 49) {
#line 440
        if ((int )*(name___0 + 2) == 47) {
          {
#line 444
          tmp___9 = atoi((char const   *)(name___0 + 3));
#line 444
          namesize = tmp___9;
#line 446
          tmp___10 = __builtin_alloca((unsigned long )(namesize + 1));
#line 446
          name___0 = (char *)tmp___10;
#line 447
          tmp___11 = read(desc, (void *)name___0, (size_t )namesize);
#line 447
          nread___0 = (int )tmp___11;
          }
#line 448
          if (nread___0 != namesize) {
            {
#line 450
            close(desc);
            }
#line 451
            return (-2L);
          }
#line 453
          *(name___0 + namesize) = (char )'\000';
#line 455
          long_name = 1;
        }
      }
    }
    {
#line 461
    sscanf((char const   */* __restrict  */)(member_header.ar_mode), (char const   */* __restrict  */)"%o",
           & eltmode);
#line 462
    eltsize = atol((char const   *)(member_header.ar_size));
#line 468
    tmp___12 = atoi((char const   *)(member_header.ar_gid));
#line 468
    tmp___13 = atoi((char const   *)(member_header.ar_uid));
#line 468
    tmp___14 = atol((char const   *)(member_header.ar_date));
#line 468
    fnval = (*function)(desc, name___0, ! long_name, member_offset, (unsigned long )member_offset + sizeof(struct ar_hdr ),
                        eltsize, tmp___14, tmp___13, tmp___12, eltmode, arg);
    }
#line 484
    if (fnval) {
      {
#line 486
      close(desc);
      }
#line 487
      return (fnval);
    }
#line 507
    if (is_namemap) {
      {
#line 512
      tmp___15 = __builtin_alloca((unsigned long )eltsize);
#line 512
      namemap = (char *)tmp___15;
#line 513
      tmp___16 = read(desc, (void *)namemap, (size_t )eltsize);
#line 513
      nread___0 = (int )tmp___16;
      }
#line 514
      if ((long )nread___0 != eltsize) {
        {
#line 516
        close(desc);
        }
#line 517
        return (-2L);
      }
#line 523
      limit = namemap + eltsize;
#line 524
      clear = namemap;
      {
#line 524
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 524
        if (! ((unsigned long )clear < (unsigned long )limit)) {
#line 524
          goto while_break___1;
        }
#line 526
        if ((int )*clear == 10) {
#line 528
          *clear = (char )'\000';
#line 529
          if ((int )*(clear + -1) == 47) {
#line 530
            *(clear + -1) = (char )'\000';
          }
        }
#line 524
        clear ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 534
      is_namemap = 0;
    }
#line 537
    member_offset = (long )((unsigned long )member_offset + (sizeof(struct ar_hdr ) + (unsigned long )eltsize));
#line 538
    if (member_offset % 2L != 0L) {
#line 539
      member_offset ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 544
  close(desc);
  }
#line 545
  return (0L);
}
}
#line 553 "/home/khheo/testset/make-3.76.1/arscan.c"
int ar_name_equal(char *name___0 , char *mem , int truncated ) 
{ 
  char *p ;
  struct ar_hdr hdr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 560
  p = strrchr((char const   *)name___0, '/');
  }
#line 561
  if ((unsigned long )p != (unsigned long )((char *)0)) {
#line 562
    name___0 = p + 1;
  }
#line 596
  if (truncated) {
    {
#line 603
    tmp = strncmp((char const   *)name___0, (char const   *)mem, sizeof(hdr.ar_name) - 1UL);
    }
#line 603
    if (tmp) {
#line 603
      tmp___0 = 0;
    } else {
#line 603
      tmp___0 = 1;
    }
#line 603
    return (tmp___0);
  }
  {
#line 615
  tmp___1 = strcmp((char const   *)name___0, (char const   *)mem);
  }
#line 615
  if (tmp___1) {
#line 615
    tmp___2 = 0;
  } else {
#line 615
    tmp___2 = 1;
  }
#line 615
  return (tmp___2);
}
}
#line 622 "/home/khheo/testset/make-3.76.1/arscan.c"
static long ar_member_pos(int desc , char *mem , int truncated , long hdrpos , long datapos ,
                          long size , long date , int uid , int gid , int mode , char *name___0 ) 
{ 
  int tmp ;

  {
  {
#line 632
  tmp = ar_name_equal(name___0, mem, truncated);
  }
#line 632
  if (! tmp) {
#line 633
    return (0L);
  }
#line 634
  return (hdrpos);
}
}
#line 644 "/home/khheo/testset/make-3.76.1/arscan.c"
int ar_member_touch(char *arname , char *memname ) 
{ 
  register long pos ;
  long tmp ;
  register int fd ;
  struct ar_hdr ar_hdr ;
  register int i ;
  struct stat statbuf ;
  __off_t tmp___0 ;
  ssize_t tmp___1 ;
  __off_t tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  __off_t tmp___6 ;
  ssize_t tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *__cil_tmp19 ;

  {
  {
#line 648
  tmp = ar_scan(arname, (long (*)())(& ar_member_pos), (long )memname);
#line 648
  pos = tmp;
  }
#line 654
  if (pos < 0L) {
#line 655
    return ((int )pos);
  }
#line 656
  if (! pos) {
#line 657
    return (1);
  }
  {
#line 659
  fd = open((char const   *)arname, 2, 438);
  }
#line 660
  if (fd < 0) {
#line 661
    return (-3);
  }
  {
#line 663
  tmp___0 = lseek(fd, pos, 0);
  }
#line 663
  if (tmp___0 < 0L) {
#line 664
    goto lose;
  }
  {
#line 665
  tmp___1 = read(fd, (void *)((char *)(& ar_hdr)), sizeof(struct ar_hdr ));
  }
#line 665
  if (sizeof(struct ar_hdr ) != (unsigned long )tmp___1) {
#line 666
    goto lose;
  }
  {
#line 668
  tmp___2 = lseek(fd, pos, 0);
  }
#line 668
  if (tmp___2 < 0L) {
#line 669
    goto lose;
  }
  {
#line 670
  tmp___3 = write(fd, (void const   *)((char *)(& ar_hdr)), sizeof(struct ar_hdr ));
  }
#line 670
  if (sizeof(struct ar_hdr ) != (unsigned long )tmp___3) {
#line 671
    goto lose;
  }
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 674
    tmp___4 = fstat(fd, & statbuf);
    }
#line 674
    if (tmp___4 < 0) {
      {
#line 674
      tmp___5 = __errno_location();
      }
#line 674
      if (! (*tmp___5 == 4)) {
#line 674
        goto while_break;
      }
    } else {
#line 674
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 680
  i = 0;
  {
#line 680
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 680
    if (! ((unsigned long )i < sizeof(ar_hdr.ar_date))) {
#line 680
      goto while_break___0;
    }
#line 681
    ar_hdr.ar_date[i] = (char )' ';
#line 680
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 682
  sprintf((char */* __restrict  */)(ar_hdr.ar_date), (char const   */* __restrict  */)"%ld",
          statbuf.st_mtim.tv_sec);
#line 690
  tmp___6 = lseek(fd, pos, 0);
  }
#line 690
  if (tmp___6 < 0L) {
#line 691
    goto lose;
  }
  {
#line 692
  tmp___7 = write(fd, (void const   *)((char *)(& ar_hdr)), sizeof(struct ar_hdr ));
  }
#line 692
  if (sizeof(struct ar_hdr ) != (unsigned long )tmp___7) {
#line 693
    goto lose;
  }
  {
#line 694
  close(fd);
  }
#line 695
  return (0);
  lose: 
  {
#line 698
  tmp___8 = __errno_location();
#line 698
  i = *tmp___8;
#line 699
  close(fd);
#line 700
  tmp___9 = __errno_location();
#line 700
  *tmp___9 = i;
  }
#line 701
  return (-3);
}
}
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 317 "/home/khheo/testset/make-3.76.1/make.h"
void fatal(char *s1 , char *s2 , char *s3 , char *s4 , char *s5 , char *s6 ) ;
#line 318
void error(char *s1 , char *s2 , char *s3 , char *s4 , char *s5 , char *s6 ) ;
#line 323
void perror_with_name(char *str , char *name___0 ) ;
#line 324
char *savestring(char *str , unsigned int length___0 ) ;
#line 325
char *concat(char *s1 , char *s2 , char *s3 ) ;
#line 326
char *xmalloc(unsigned int size ) ;
#line 342
int ar_name(char *name___0 ) ;
#line 343
void ar_parse_name(char *name___0 , char **arname_p , char **memname_p ) ;
#line 344
int ar_touch(char *name___0 ) ;
#line 345
time_t ar_member_date(char *name___0 ) ;
#line 350
int file_exists_p(char *name___0 ) ;
#line 92 "/home/khheo/testset/make-3.76.1/filedef.h"
struct file *lookup_file(char *name___0 ) ;
#line 92
struct file *enter_file(char *name___0 ) ;
#line 106
time_t f_mtime(struct file *file , int search ) ;
#line 52 "/home/khheo/testset/make-3.76.1/dep.h"
struct nameseq *ar_glob(char *arname , char *member_pattern , unsigned int size ) ;
#line 61 "./glob/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__string , int __flags ) ;
#line 39 "/home/khheo/testset/make-3.76.1/ar.c"
int ar_name(char *name___0 ) 
{ 
  char *p ;
  char *tmp ;
  char *end ;
  size_t tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 43
  tmp = strchr((char const   *)name___0, '(');
#line 43
  p = tmp;
#line 43
  tmp___0 = strlen((char const   *)name___0);
#line 43
  end = (name___0 + tmp___0) - 1;
  }
#line 45
  if ((unsigned long )p == (unsigned long )((char *)0)) {
#line 46
    return (0);
  } else
#line 45
  if ((unsigned long )p == (unsigned long )name___0) {
#line 46
    return (0);
  } else
#line 45
  if ((int )*end != 41) {
#line 46
    return (0);
  }
#line 48
  if ((int )*(p + 1) == 40) {
#line 48
    if ((int )*(end + -1) == 41) {
      {
#line 49
      fatal("attempt to use unsupported feature: `%s\'", name___0);
      }
    }
  }
#line 51
  return (1);
}
}
#line 59 "/home/khheo/testset/make-3.76.1/ar.c"
void ar_parse_name(char *name___0 , char **arname_p , char **memname_p ) 
{ 
  char *p ;
  char *tmp ;
  char *end ;
  size_t tmp___0 ;

  {
  {
#line 63
  tmp = strchr((char const   *)name___0, '(');
#line 63
  p = tmp;
#line 63
  tmp___0 = strlen((char const   *)name___0);
#line 63
  end = (name___0 + tmp___0) - 1;
  }
#line 65
  if ((unsigned long )arname_p != (unsigned long )((char **)0)) {
    {
#line 66
    *arname_p = savestring(name___0, p - name___0);
    }
  }
#line 68
  if ((unsigned long )memname_p != (unsigned long )((char **)0)) {
    {
#line 69
    *memname_p = savestring(p + 1, end - (p + 1));
    }
  }
#line 70
  return;
}
}
#line 72
static long ar_member_date_1(int desc , char *mem , int truncated , long hdrpos ,
                             long datapos , long size , long date , int uid , int gid ,
                             int mode , char *name___0 ) ;
#line 77 "/home/khheo/testset/make-3.76.1/ar.c"
time_t ar_member_date(char *name___0 ) 
{ 
  char *arname ;
  int arname_used ;
  char *memname ;
  long val ;
  struct file *arfile ;
  int tmp ;
  time_t tmp___0 ;

  {
  {
#line 82
  arname_used = 0;
#line 86
  ar_parse_name(name___0, & arname, & memname);
#line 97
  arfile = lookup_file(arname);
  }
#line 98
  if ((unsigned long )arfile == (unsigned long )((struct file *)0)) {
    {
#line 98
    tmp = file_exists_p(arname);
    }
#line 98
    if (tmp) {
      {
#line 100
      arfile = enter_file(arname);
#line 101
      arname_used = 1;
      }
    }
  }
#line 104
  if ((unsigned long )arfile != (unsigned long )((struct file *)0)) {
    {
#line 105
    f_mtime(arfile, 0);
    }
  }
  {
#line 108
  val = ar_scan(arname, (long (*)())(& ar_member_date_1), (long )memname);
  }
#line 110
  if (! arname_used) {
    {
#line 111
    free((void *)arname);
    }
  }
  {
#line 112
  free((void *)memname);
  }
#line 114
  if (val <= 0L) {
#line 114
    tmp___0 = (time_t )-1;
  } else {
#line 114
    tmp___0 = val;
  }
#line 114
  return (tmp___0);
}
}
#line 120 "/home/khheo/testset/make-3.76.1/ar.c"
static long ar_member_date_1(int desc , char *mem , int truncated , long hdrpos ,
                             long datapos , long size , long date , int uid , int gid ,
                             int mode , char *name___0 ) 
{ 
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 130
  tmp___1 = ar_name_equal(name___0, mem, truncated);
  }
#line 130
  if (tmp___1) {
#line 130
    tmp___0 = date;
  } else {
#line 130
    tmp___0 = 0L;
  }
#line 130
  return (tmp___0);
}
}
#line 144 "/home/khheo/testset/make-3.76.1/ar.c"
int ar_touch(char *name___0 ) 
{ 
  char *arname ;
  char *memname ;
  int arname_used ;
  register int val ;
  struct file *arfile ;
  int tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 149
  arname_used = 0;
#line 152
  ar_parse_name(name___0, & arname, & memname);
#line 158
  arfile = lookup_file(arname);
  }
#line 159
  if ((unsigned long )arfile == (unsigned long )((struct file *)0)) {
    {
#line 161
    arfile = enter_file(arname);
#line 162
    arname_used = 1;
    }
  }
  {
#line 165
  f_mtime(arfile, 0);
#line 168
  val = 1;
#line 169
  tmp = ar_member_touch(arname, memname);
  }
  {
#line 171
  if (tmp == -1) {
#line 171
    goto case_neg_1;
  }
#line 174
  if (tmp == -2) {
#line 174
    goto case_neg_2;
  }
#line 177
  if (tmp == -3) {
#line 177
    goto case_neg_3;
  }
#line 180
  if (tmp == 1) {
#line 180
    goto case_1;
  }
#line 183
  if (tmp == 0) {
#line 183
    goto case_0;
  }
#line 186
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 172
  error("touch: Archive `%s\' does not exist", arname);
  }
#line 173
  goto switch_break;
  case_neg_2: /* CIL Label */ 
  {
#line 175
  error("touch: `%s\' is not a valid archive", arname);
  }
#line 176
  goto switch_break;
  case_neg_3: /* CIL Label */ 
  {
#line 178
  perror_with_name("touch: ", arname);
  }
#line 179
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 181
  error("touch: Member `%s\' does not exist in `%s\'", memname, arname);
  }
#line 182
  goto switch_break;
  case_0: /* CIL Label */ 
#line 184
  val = 0;
#line 185
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 187
  error("touch: Bad return code from ar_member_touch on `%s\'", name___0);
  }
  switch_break: /* CIL Label */ ;
  }
#line 190
  if (! arname_used) {
    {
#line 191
    free((void *)arname);
    }
  }
  {
#line 192
  free((void *)memname);
  }
#line 194
  return (val);
}
}
#line 212 "/home/khheo/testset/make-3.76.1/ar.c"
static long ar_glob_match(int desc , char *mem , int truncated , long hdrpos , long datapos ,
                          long size , long date , int uid , int gid , int mode , struct ar_glob_state *state ) 
{ 
  struct nameseq *new ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp15 ;

  {
  {
#line 223
  tmp___0 = fnmatch((char const   *)state->pattern, (char const   *)mem, 1 | (1 << 2));
  }
#line 223
  if (tmp___0 == 0) {
    {
#line 226
    tmp = xmalloc(state->size);
#line 226
    new = (struct nameseq *)tmp;
#line 227
    new->name = concat(state->arname, mem, ")");
#line 228
    new->next = state->chain;
#line 229
    state->chain = new;
#line 230
    (state->n) ++;
    }
  }
#line 233
  return (0L);
}
}
#line 238 "/home/khheo/testset/make-3.76.1/ar.c"
static int ar_glob_alphacompare(char **a , char **b ) 
{ 
  int tmp ;

  {
  {
#line 242
  tmp = strcmp((char const   *)*a, (char const   *)*b);
  }
#line 242
  return (tmp);
}
}
#line 247 "/home/khheo/testset/make-3.76.1/ar.c"
static int glob_pattern_p(char const   *pattern , int const   quote ) 
{ 
  register char const   *p ;
  int open___0 ;

  {
#line 253
  open___0 = 0;
#line 255
  p = pattern;
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! ((int const   )*p != 0)) {
#line 255
      goto while_break;
    }
    {
#line 259
    if ((int const   )*p == 42) {
#line 259
      goto case_42;
    }
#line 259
    if ((int const   )*p == 63) {
#line 259
      goto case_42;
    }
#line 262
    if ((int const   )*p == 92) {
#line 262
      goto case_92;
    }
#line 267
    if ((int const   )*p == 91) {
#line 267
      goto case_91;
    }
#line 271
    if ((int const   )*p == 93) {
#line 271
      goto case_93;
    }
#line 256
    goto switch_break;
    case_42: /* CIL Label */ 
    case_63: /* CIL Label */ 
#line 260
    return (1);
    case_92: /* CIL Label */ 
#line 263
    if (quote) {
#line 264
      p ++;
    }
#line 265
    goto switch_break;
    case_91: /* CIL Label */ 
#line 268
    open___0 = 1;
#line 269
    goto switch_break;
    case_93: /* CIL Label */ 
#line 272
    if (open___0) {
#line 273
      return (1);
    }
#line 274
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 255
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  return (0);
}
}
#line 283 "/home/khheo/testset/make-3.76.1/ar.c"
struct nameseq *ar_glob(char *arname , char *member_pattern , unsigned int size ) 
{ 
  struct ar_glob_state state ;
  char **names ;
  struct nameseq *n ;
  unsigned int i ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;

  {
  {
#line 293
  tmp = glob_pattern_p((char const   *)member_pattern, (int const   )1);
  }
#line 293
  if (! tmp) {
#line 294
    return ((struct nameseq *)0);
  }
  {
#line 298
  tmp___0 = strlen((char const   *)arname);
#line 298
  i = (unsigned int )tmp___0;
#line 299
  tmp___1 = __builtin_alloca((unsigned long )(i + 2U));
#line 299
  state.arname = (char *)tmp___1;
#line 300
  memmove((void *)state.arname, (void const   *)arname, (size_t )i);
#line 301
  *(state.arname + i) = (char )'(';
#line 302
  *(state.arname + (i + 1U)) = (char )'\000';
#line 303
  state.pattern = member_pattern;
#line 304
  state.size = size;
#line 305
  state.chain = (struct nameseq *)0;
#line 306
  state.n = 0U;
#line 307
  ar_scan(arname, (long (*)())(& ar_glob_match), (long )(& state));
  }
#line 309
  if ((unsigned long )state.chain == (unsigned long )((struct nameseq *)0)) {
#line 310
    return ((struct nameseq *)0);
  }
  {
#line 313
  tmp___2 = __builtin_alloca((unsigned long )state.n * sizeof(char *));
#line 313
  names = (char **)tmp___2;
#line 314
  i = 0U;
#line 315
  n = state.chain;
  }
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if (! ((unsigned long )n != (unsigned long )((struct nameseq *)0))) {
#line 315
      goto while_break;
    }
#line 316
    tmp___3 = i;
#line 316
    i ++;
#line 316
    *(names + tmp___3) = n->name;
#line 315
    n = n->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 319
  qsort((void *)((char *)names), (size_t )i, sizeof(*names), (int (*)(void const   * ,
                                                                      void const   * ))(& ar_glob_alphacompare));
#line 322
  i = 0U;
#line 323
  n = state.chain;
  }
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 323
    if (! ((unsigned long )n != (unsigned long )((struct nameseq *)0))) {
#line 323
      goto while_break___0;
    }
#line 324
    tmp___4 = i;
#line 324
    i ++;
#line 324
    n->name = *(names + tmp___4);
#line 323
    n = n->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 326
  return (state.chain);
}
}
#line 6 "/home/khheo/testset/make-3.76.1/version.c"
char *version_string  =    (char *)"3.76.1";
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 327 "/home/khheo/testset/make-3.76.1/make.h"
char *xrealloc(char *ptr , unsigned int size ) ;
#line 339
char *find_percent(char *pattern ) ;
#line 349
int dir_file_exists_p(char *dirname , char *filename ) ;
#line 353
char *dir_name(char *dir ) ;
#line 363
void build_vpath_lists(void) ;
#line 364
void construct_vpath_list(char *pattern , char *dirpath ) ;
#line 365
int vpath_search(char **file , time_t *mtime_ptr ) ;
#line 366
int gpath_search(char *file , int len ) ;
#line 412
int warn_undefined_variables_flag ;
#line 75 "/home/khheo/testset/make-3.76.1/variable.h"
char *variable_expand(char *line ) ;
#line 84
int pattern_matches(char *pattern , char *percent , char *word ) ;
#line 41 "/home/khheo/testset/make-3.76.1/vpath.c"
static struct vpath *vpaths  ;
#line 45 "/home/khheo/testset/make-3.76.1/vpath.c"
static struct vpath *general_vpath  ;
#line 49 "/home/khheo/testset/make-3.76.1/vpath.c"
static struct vpath *gpaths  ;
#line 51
static int selective_vpath_search(struct vpath *path , char **file , time_t *mtime_ptr ) ;
#line 57 "/home/khheo/testset/make-3.76.1/vpath.c"
void build_vpath_lists(void) 
{ 
  register struct vpath *new ;
  register struct vpath *old ;
  register struct vpath *nexto ;
  register char *p ;
  int save ;
  struct vpath *save_vpaths ;
  int save___0 ;
  struct vpath *save_vpaths___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 60
  new = (struct vpath *)0;
#line 65
  old = vpaths;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! ((unsigned long )old != (unsigned long )((struct vpath *)0))) {
#line 65
      goto while_break;
    }
#line 67
    nexto = old->next;
#line 68
    old->next = new;
#line 69
    new = old;
#line 65
    old = nexto;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 72
  vpaths = new;
#line 80
  save = warn_undefined_variables_flag;
#line 81
  warn_undefined_variables_flag = 0;
#line 83
  p = variable_expand((char *)"$(strip $(VPATH))");
#line 85
  warn_undefined_variables_flag = save;
  }
#line 88
  if ((int )*p != 0) {
    {
#line 91
    save_vpaths = vpaths;
#line 95
    vpaths = (struct vpath *)0;
#line 98
    construct_vpath_list("%", p);
#line 102
    general_vpath = vpaths;
#line 103
    vpaths = save_vpaths;
    }
  }
  {
#line 112
  save___0 = warn_undefined_variables_flag;
#line 113
  warn_undefined_variables_flag = 0;
#line 115
  p = variable_expand((char *)"$(strip $(GPATH))");
#line 117
  warn_undefined_variables_flag = save___0;
  }
#line 120
  if ((int )*p != 0) {
    {
#line 123
    save_vpaths___0 = vpaths;
#line 127
    vpaths = (struct vpath *)0;
#line 130
    construct_vpath_list("%", p);
#line 134
    gpaths = vpaths;
#line 135
    vpaths = save_vpaths___0;
    }
  }
#line 137
  return;
}
}
#line 158 "/home/khheo/testset/make-3.76.1/vpath.c"
void construct_vpath_list(char *pattern , char *dirpath ) 
{ 
  register unsigned int elem ;
  register char *p ;
  register char **vpath ;
  register unsigned int maxvpath ;
  unsigned int maxelem ;
  char *percent ;
  size_t tmp ;
  register struct vpath *path ;
  register struct vpath *lastpath ;
  struct vpath *next ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *v ;
  unsigned int len ;
  unsigned short const   **tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  struct vpath *path___0 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  char *__cil_tmp28 ;

  {
#line 169
  if ((unsigned long )pattern != (unsigned long )((char *)0)) {
    {
#line 171
    tmp = strlen((char const   *)pattern);
#line 171
    pattern = savestring(pattern, tmp);
#line 172
    percent = find_percent(pattern);
    }
  }
#line 175
  if ((unsigned long )dirpath == (unsigned long )((char *)0)) {
#line 180
    lastpath = (struct vpath *)0;
#line 181
    path = vpaths;
    {
#line 182
    while (1) {
      while_continue: /* CIL Label */ ;
#line 182
      if (! ((unsigned long )path != (unsigned long )((struct vpath *)0))) {
#line 182
        goto while_break;
      }
#line 184
      next = path->next;
#line 186
      if ((unsigned long )pattern == (unsigned long )((char *)0)) {
#line 186
        goto _L___1;
      } else
#line 186
      if ((unsigned long )percent == (unsigned long )((char *)0)) {
#line 186
        if ((unsigned long )path->percent == (unsigned long )((char *)0)) {
#line 186
          goto _L___2;
        } else {
#line 186
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 186
      if (percent - pattern == path->percent - path->pattern) {
        _L___2: /* CIL Label */ 
#line 186
        if ((unsigned long )pattern == (unsigned long )path->pattern) {
#line 186
          goto _L___1;
        } else
#line 186
        if ((int )*pattern == (int )*(path->pattern)) {
#line 186
          if ((int )*pattern == 0) {
#line 186
            goto _L___1;
          } else {
            {
#line 186
            tmp___0 = strcmp((char const   *)(pattern + 1), (char const   *)(path->pattern + 1));
            }
#line 186
            if (tmp___0) {
#line 203
              lastpath = path;
            } else {
              _L___1: /* CIL Label */ 
#line 192
              if ((unsigned long )lastpath == (unsigned long )((struct vpath *)0)) {
#line 193
                vpaths = path->next;
              } else {
#line 195
                lastpath->next = next;
              }
              {
#line 198
              free((void *)path->pattern);
#line 199
              free((void *)((char *)path->searchpath));
#line 200
              free((void *)((char *)path));
              }
            }
          }
        } else {
#line 203
          lastpath = path;
        }
      } else {
#line 203
        lastpath = path;
      }
#line 205
      path = next;
    }
    while_break: /* CIL Label */ ;
    }
#line 208
    if ((unsigned long )pattern != (unsigned long )((char *)0)) {
      {
#line 209
      free((void *)pattern);
      }
    }
#line 210
    return;
  }
#line 221
  maxelem = 2U;
#line 222
  p = dirpath;
  {
#line 223
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 223
    if (! ((int )*p != 0)) {
#line 223
      goto while_break___0;
    }
#line 224
    tmp___1 = p;
#line 224
    p ++;
#line 224
    if ((int )*tmp___1 == 58) {
#line 225
      maxelem ++;
    } else {
      {
#line 224
      tmp___2 = __ctype_b_loc();
      }
#line 224
      if ((int const   )*(*tmp___2 + (int )*p) & 1) {
#line 225
        maxelem ++;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 227
  tmp___3 = xmalloc((unsigned long )maxelem * sizeof(char *));
#line 227
  vpath = (char **)tmp___3;
#line 228
  maxvpath = 0U;
#line 231
  p = dirpath;
  }
  {
#line 232
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 232
    if (! ((int )*p == 58)) {
      {
#line 232
      tmp___4 = __ctype_b_loc();
      }
#line 232
      if (! ((int const   )*(*tmp___4 + (int )*p) & 1)) {
#line 232
        goto while_break___1;
      }
    }
#line 233
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 235
  elem = 0U;
  {
#line 236
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 236
    if (! ((int )*p != 0)) {
#line 236
      goto while_break___2;
    }
#line 242
    v = p;
    {
#line 243
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 243
      if ((int )*p != 0) {
#line 243
        if ((int )*p != 58) {
          {
#line 243
          tmp___5 = __ctype_b_loc();
          }
#line 243
          if ((int const   )*(*tmp___5 + (int )*p) & 1) {
#line 243
            goto while_break___3;
          }
        } else {
#line 243
          goto while_break___3;
        }
      } else {
#line 243
        goto while_break___3;
      }
#line 244
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 246
    len = (unsigned int )(p - v);
#line 253
    if (len > 1U) {
#line 253
      if ((int )*(p + -1) == 47) {
#line 254
        len --;
      }
    }
#line 256
    if (len > 1U) {
#line 256
      goto _L___4;
    } else
#line 256
    if ((int )*v != 46) {
      _L___4: /* CIL Label */ 
      {
#line 258
      v = savestring(v, len);
#line 262
      tmp___7 = dir_file_exists_p(v, "");
      }
#line 262
      if (tmp___7) {
        {
#line 265
        tmp___6 = elem;
#line 265
        elem ++;
#line 265
        *(vpath + tmp___6) = dir_name(v);
#line 266
        free((void *)v);
        }
#line 267
        if (len > maxvpath) {
#line 268
          maxvpath = len;
        }
      } else {
        {
#line 272
        free((void *)v);
        }
      }
    }
    {
#line 276
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 276
      if (! ((int )*p == 58)) {
        {
#line 276
        tmp___8 = __ctype_b_loc();
        }
#line 276
        if (! ((int const   )*(*tmp___8 + (int )*p) & 1)) {
#line 276
          goto while_break___4;
        }
      }
#line 277
      p ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 280
  if (elem > 0U) {
#line 286
    if (elem < maxelem - 1U) {
      {
#line 287
      tmp___9 = xrealloc((char *)vpath, (unsigned long )(elem + 1U) * sizeof(char *));
#line 287
      vpath = (char **)tmp___9;
      }
    }
    {
#line 291
    *(vpath + elem) = (char *)0;
#line 294
    tmp___10 = xmalloc(sizeof(struct vpath ));
#line 294
    path___0 = (struct vpath *)tmp___10;
#line 295
    path___0->searchpath = vpath;
#line 296
    path___0->maxlen = maxvpath;
#line 297
    path___0->next = vpaths;
#line 298
    vpaths = path___0;
#line 301
    path___0->pattern = pattern;
#line 302
    path___0->percent = percent;
#line 303
    tmp___11 = strlen((char const   *)pattern);
#line 303
    path___0->patlen = (unsigned int )tmp___11;
    }
  } else {
    {
#line 308
    free((void *)((char *)vpath));
    }
#line 309
    if ((unsigned long )pattern != (unsigned long )((char *)0)) {
      {
#line 310
      free((void *)pattern);
      }
    }
  }
#line 312
  return;
}
}
#line 317 "/home/khheo/testset/make-3.76.1/vpath.c"
int gpath_search(char *file , int len ) 
{ 
  register char **gp ;
  int tmp ;

  {
#line 324
  if (gpaths) {
#line 324
    if ((unsigned int )len <= gpaths->maxlen) {
#line 325
      gp = gpaths->searchpath;
      {
#line 325
      while (1) {
        while_continue: /* CIL Label */ ;
#line 325
        if (! ((unsigned long )*gp != (unsigned long )((void *)0))) {
#line 325
          goto while_break;
        }
        {
#line 326
        tmp = strncmp((char const   *)*gp, (char const   *)file, (size_t )len);
        }
#line 326
        if (! tmp) {
#line 326
          if ((int )*(*gp + len) == 0) {
#line 327
            return (1);
          }
        }
#line 325
        gp ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 329
  return (0);
}
}
#line 338 "/home/khheo/testset/make-3.76.1/vpath.c"
int vpath_search(char **file , time_t *mtime_ptr ) 
{ 
  register struct vpath *v ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 348
  if ((int )*(*file) == 47) {
#line 354
    return (0);
  } else
#line 348
  if ((unsigned long )vpaths == (unsigned long )((struct vpath *)0)) {
#line 348
    if ((unsigned long )general_vpath == (unsigned long )((struct vpath *)0)) {
#line 354
      return (0);
    }
  }
#line 356
  v = vpaths;
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 356
    if (! ((unsigned long )v != (unsigned long )((struct vpath *)0))) {
#line 356
      goto while_break;
    }
    {
#line 357
    tmp___0 = pattern_matches(v->pattern, v->percent, *file);
    }
#line 357
    if (tmp___0) {
      {
#line 358
      tmp = selective_vpath_search(v, file, mtime_ptr);
      }
#line 358
      if (tmp) {
#line 359
        return (1);
      }
    }
#line 356
    v = v->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  if ((unsigned long )general_vpath != (unsigned long )((struct vpath *)0)) {
    {
#line 361
    tmp___1 = selective_vpath_search(general_vpath, file, mtime_ptr);
    }
#line 361
    if (tmp___1) {
#line 363
      return (1);
    }
  }
#line 365
  return (0);
}
}
#line 375 "/home/khheo/testset/make-3.76.1/vpath.c"
static int selective_vpath_search(struct vpath *path , char **file , time_t *mtime_ptr ) 
{ 
  int not_target ;
  char *name___0 ;
  char *n ;
  char *filename ;
  register char **vpath ;
  unsigned int maxvpath ;
  register unsigned int i ;
  unsigned int flen ;
  unsigned int vlen ;
  unsigned int name_dplen ;
  int exists ;
  struct file *f ;
  struct file *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int exists_in_cache ;
  size_t tmp___3 ;
  char *tmp___4 ;
  struct file *f___0 ;
  struct file *tmp___5 ;
  int tmp___6 ;
  struct stat st ;
  int tmp___7 ;

  {
  {
#line 384
  vpath = path->searchpath;
#line 385
  maxvpath = path->maxlen;
#line 388
  exists = 0;
#line 394
  tmp = lookup_file(*file);
#line 394
  f = tmp;
  }
#line 395
  if ((unsigned long )f == (unsigned long )((struct file *)0)) {
#line 395
    tmp___0 = 1;
  } else
#line 395
  if (! f->is_target) {
#line 395
    tmp___0 = 1;
  } else {
#line 395
    tmp___0 = 0;
  }
  {
#line 395
  not_target = tmp___0;
#line 398
  tmp___1 = strlen((char const   *)*file);
#line 398
  flen = (unsigned int )tmp___1;
#line 404
  n = strrchr((char const   *)*file, '/');
  }
#line 413
  if ((unsigned long )n != (unsigned long )((char *)0)) {
#line 413
    name_dplen = (unsigned int )(n - *file);
  } else {
#line 413
    name_dplen = 0U;
  }
#line 414
  if (name_dplen > 0U) {
#line 414
    filename = n + 1;
  } else {
#line 414
    filename = *file;
  }
#line 415
  if (name_dplen > 0U) {
#line 416
    flen -= name_dplen + 1U;
  }
  {
#line 422
  tmp___2 = xmalloc(((((maxvpath + 1U) + name_dplen) + 1U) + flen) + 1U);
#line 422
  name___0 = tmp___2;
#line 425
  i = 0U;
  }
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! ((unsigned long )*(vpath + i) != (unsigned long )((char *)0))) {
#line 425
      goto while_break;
    }
    {
#line 427
    exists_in_cache = 0;
#line 429
    n = name___0;
#line 432
    tmp___3 = strlen((char const   *)*(vpath + i));
#line 432
    vlen = (unsigned int )tmp___3;
#line 433
    memmove((void *)n, (void const   *)*(vpath + i), (size_t )vlen);
#line 434
    n += vlen;
    }
#line 437
    if (name_dplen > 0U) {
      {
#line 440
      tmp___4 = n;
#line 440
      n ++;
#line 440
      *tmp___4 = (char )'/';
#line 442
      memmove((void *)n, (void const   *)*file, (size_t )name_dplen);
#line 443
      n += name_dplen;
      }
    }
#line 453
    if ((unsigned long )n != (unsigned long )name___0) {
#line 453
      if ((int )*(n + -1) != 47) {
        {
#line 455
        *n = (char )'/';
#line 456
        memmove((void *)(n + 1), (void const   *)filename, (size_t )(flen + 1U));
        }
      } else {
        {
#line 460
        memmove((void *)n, (void const   *)filename, (size_t )(flen + 1U));
        }
      }
    } else {
      {
#line 460
      memmove((void *)n, (void const   *)filename, (size_t )(flen + 1U));
      }
    }
    {
#line 476
    tmp___5 = lookup_file(name___0);
#line 476
    f___0 = tmp___5;
    }
#line 477
    if ((unsigned long )f___0 != (unsigned long )((struct file *)0)) {
#line 478
      if (not_target) {
#line 478
        tmp___6 = 1;
      } else
#line 478
      if (f___0->is_target) {
#line 478
        tmp___6 = 1;
      } else {
#line 478
        tmp___6 = 0;
      }
#line 478
      exists = tmp___6;
    }
#line 481
    if (! exists) {
      {
#line 491
      *n = (char )'\000';
#line 496
      exists = dir_file_exists_p(name___0, filename);
#line 496
      exists_in_cache = exists;
      }
    }
#line 500
    if (exists) {
#line 512
      *n = (char )'/';
#line 515
      if (! exists_in_cache) {
#line 515
        goto _L;
      } else {
        {
#line 515
        tmp___7 = stat((char const   */* __restrict  */)name___0, (struct stat */* __restrict  */)(& st));
        }
#line 515
        if (tmp___7 == 0) {
          _L: /* CIL Label */ 
          {
#line 521
          *file = savestring(name___0, ((n + 1) - name___0) + (long )flen);
          }
#line 523
          if ((unsigned long )mtime_ptr != (unsigned long )((time_t *)0)) {
#line 527
            if (exists_in_cache) {
#line 527
              *mtime_ptr = st.st_mtim.tv_sec;
            } else {
#line 527
              *mtime_ptr = (time_t )0;
            }
          }
          {
#line 529
          free((void *)name___0);
          }
#line 530
          return (1);
        } else {
#line 533
          exists = 0;
        }
      }
    }
#line 425
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 537
  free((void *)name___0);
  }
#line 538
  return (0);
}
}
#line 543 "/home/khheo/testset/make-3.76.1/vpath.c"
void print_vpath_data_base(void) 
{ 
  register unsigned int nvpaths ;
  register struct vpath *v ;
  register unsigned int i ;
  int tmp ;
  register char **path ;
  register unsigned int i___0 ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 549
  puts("\n# VPATH Search Paths\n");
#line 551
  nvpaths = 0U;
#line 552
  v = vpaths;
  }
  {
#line 552
  while (1) {
    while_continue: /* CIL Label */ ;
#line 552
    if (! ((unsigned long )v != (unsigned long )((struct vpath *)0))) {
#line 552
      goto while_break;
    }
    {
#line 556
    nvpaths ++;
#line 558
    printf((char const   */* __restrict  */)"vpath %s ", v->pattern);
#line 560
    i = 0U;
    }
    {
#line 560
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 560
      if (! ((unsigned long )*(v->searchpath + i) != (unsigned long )((char *)0))) {
#line 560
        goto while_break___0;
      }
#line 561
      if ((unsigned long )*(v->searchpath + (i + 1U)) == (unsigned long )((char *)0)) {
#line 561
        tmp = '\n';
      } else {
#line 561
        tmp = ':';
      }
      {
#line 561
      printf((char const   */* __restrict  */)"%s%c", *(v->searchpath + i), tmp);
#line 560
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 552
    v = v->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 565
  if ((unsigned long )vpaths == (unsigned long )((struct vpath *)0)) {
    {
#line 566
    puts("# No `vpath\' search paths.");
    }
  } else {
    {
#line 568
    printf((char const   */* __restrict  */)"\n# %u `vpath\' search paths.\n", nvpaths);
    }
  }
#line 570
  if ((unsigned long )general_vpath == (unsigned long )((struct vpath *)0)) {
    {
#line 571
    puts("\n# No general (`VPATH\' variable) search path.");
    }
  } else {
    {
#line 574
    path = general_vpath->searchpath;
#line 577
    fputs((char const   */* __restrict  */)"\n# General (`VPATH\' variable) search path:\n# ",
          (FILE */* __restrict  */)stdout);
#line 579
    i___0 = 0U;
    }
    {
#line 579
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 579
      if (! ((unsigned long )*(path + i___0) != (unsigned long )((char *)0))) {
#line 579
        goto while_break___1;
      }
#line 580
      if ((unsigned long )*(path + (i___0 + 1U)) == (unsigned long )((char *)0)) {
#line 580
        tmp___0 = '\n';
      } else {
#line 580
        tmp___0 = ':';
      }
      {
#line 580
      printf((char const   */* __restrict  */)"%s%c", *(path + i___0), tmp___0);
#line 579
      i___0 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 583
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 417 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 545
extern char **environ ;
#line 764
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) vfork)(void) ;
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 321 "/home/khheo/testset/make-3.76.1/make.h"
void makefile_fatal(char *file , unsigned int lineno , char *s1 , char *s2 , char *s3 ,
                    char *s4 , char *s5 , char *s6 ) ;
#line 328
char *find_next_token(char **ptr , unsigned int *lengthptr ) ;
#line 329
char *next_token(char *s ) ;
#line 330
char *end_of_token(char *s ) ;
#line 333
char *sindex(char *big , unsigned int blen , char *small , unsigned int slen ) ;
#line 334
char *lindex(char *s , char *limit , int c ) ;
#line 335
int alpha_compare(char **s1 , char **s2 ) ;
#line 406
char *reading_filename ;
#line 407
unsigned int *reading_lineno_ptr ;
#line 74 "/home/khheo/testset/make-3.76.1/variable.h"
char *variable_buffer_output(char *ptr , char *string , unsigned int length___0 ) ;
#line 77
char *allocated_variable_expand_for_file(char *line , struct file *file ) ;
#line 80
char *expand_argument(char *str , char *end ) ;
#line 83
int handle_function(char **op , char **stringp ) ;
#line 85
char *subst_expand(char *o , char *text , char *subst , char *replace , unsigned int slen ,
                   unsigned int rlen , int by_word , int suffix_only ) ;
#line 87
char *patsubst_expand(char *o , char *text , char *pattern , char *replace , char *pattern_percent ,
                      char *replace_percent ) ;
#line 94
void push_new_variable_scope(void) ;
#line 95
void pop_variable_scope(void) ;
#line 102
struct variable *lookup_variable(char *name___0 , unsigned int length___0 ) ;
#line 103
struct variable *define_variable(char *name___0 , unsigned int length___0 , char *value ,
                                 enum variable_origin origin , int recursive ) ;
#line 43 "/home/khheo/testset/make-3.76.1/dep.h"
struct nameseq *multi_glob(struct nameseq *chain , unsigned int size ) ;
#line 47
struct nameseq *parse_file_seq(char **stringp , int stopchar , unsigned int size ,
                               int strip ) ;
#line 52 "/home/khheo/testset/make-3.76.1/job.h"
void reap_children(int block , int err ) ;
#line 55
char **construct_command_argv(char *line , char **restp , struct file *file ) ;
#line 59
void child_execute_job(int stdin_fd , int stdout_fd , char **argv , char **envp ) ;
#line 35 "/home/khheo/testset/make-3.76.1/function.c"
static char *string_glob(char *line ) ;
#line 44 "/home/khheo/testset/make-3.76.1/function.c"
char *subst_expand(char *o , char *text , char *subst , char *replace , unsigned int slen ,
                   unsigned int rlen , int by_word , int suffix_only ) 
{ 
  register char *t ;
  register char *p ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
#line 52
  t = text;
#line 55
  if (slen == 0U) {
#line 55
    if (! by_word) {
#line 55
      if (! suffix_only) {
        {
#line 58
        tmp = strlen((char const   *)t);
#line 58
        o = variable_buffer_output(o, t, (unsigned int )tmp);
        }
#line 59
        if (rlen > 0U) {
          {
#line 60
          o = variable_buffer_output(o, replace, rlen);
          }
        }
#line 61
        return (o);
      }
    }
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (by_word | suffix_only) {
#line 66
      if (slen == 0U) {
        {
#line 69
        tmp___0 = next_token(t);
#line 69
        p = end_of_token(tmp___0);
        }
      } else {
#line 66
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 72
      p = sindex(t, 0, subst, slen);
      }
#line 73
      if ((unsigned long )p == (unsigned long )((char *)0)) {
        {
#line 76
        tmp___1 = strlen((char const   *)t);
#line 76
        o = variable_buffer_output(o, t, (unsigned int )tmp___1);
        }
#line 77
        return (o);
      }
    }
#line 82
    if ((unsigned long )p > (unsigned long )t) {
      {
#line 83
      o = variable_buffer_output(o, t, (unsigned int )(p - t));
      }
    }
#line 87
    if (by_word) {
#line 87
      if ((unsigned long )p > (unsigned long )t) {
        {
#line 87
        tmp___2 = __ctype_b_loc();
        }
#line 87
        if ((int const   )*(*tmp___2 + (int )*(p + -1)) & 1) {
#line 87
          goto _L___2;
        } else {
          {
#line 94
          o = variable_buffer_output(o, subst, slen);
          }
        }
      } else
      _L___2: /* CIL Label */ 
#line 87
      if ((int )*(p + slen) != 0) {
        {
#line 87
        tmp___3 = __ctype_b_loc();
        }
#line 87
        if ((int const   )*(*tmp___3 + (int )*(p + slen)) & 1) {
#line 87
          goto _L___1;
        } else {
          {
#line 94
          o = variable_buffer_output(o, subst, slen);
          }
        }
      } else {
#line 87
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 87
    if (suffix_only) {
#line 87
      if ((int )*(p + slen) != 0) {
        {
#line 87
        tmp___4 = __ctype_b_loc();
        }
#line 87
        if ((int const   )*(*tmp___4 + (int )*(p + slen)) & 1) {
#line 87
          goto _L___0;
        } else {
          {
#line 94
          o = variable_buffer_output(o, subst, slen);
          }
        }
      } else {
#line 87
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 95
    if (rlen > 0U) {
      {
#line 97
      o = variable_buffer_output(o, replace, rlen);
      }
    }
#line 100
    t = p + slen;
#line 64
    if (! ((int )*t != 0)) {
#line 64
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return (o);
}
}
#line 114 "/home/khheo/testset/make-3.76.1/function.c"
char *patsubst_expand(char *o , char *text , char *pattern , char *replace , char *pattern_percent ,
                      char *replace_percent ) 
{ 
  unsigned int pattern_prepercent_len ;
  unsigned int pattern_postpercent_len ;
  unsigned int replace_prepercent_len ;
  unsigned int replace_postpercent_len ;
  char *t ;
  unsigned int len ;
  int doneany ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  int fail ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 125
  doneany = 0;
#line 129
  if ((unsigned long )replace_percent == (unsigned long )((char *)0)) {
    {
#line 130
    replace_percent = find_percent(replace);
    }
  }
#line 131
  if ((unsigned long )replace_percent != (unsigned long )((char *)0)) {
    {
#line 135
    replace_prepercent_len = (unsigned int )(replace_percent - replace);
#line 136
    tmp = strlen((char const   *)(replace_percent + 1));
#line 136
    replace_postpercent_len = (unsigned int )tmp;
    }
  } else {
    {
#line 141
    tmp___0 = strlen((char const   *)replace);
#line 141
    replace_prepercent_len = (unsigned int )tmp___0;
    }
  }
#line 143
  if ((unsigned long )pattern_percent == (unsigned long )((char *)0)) {
    {
#line 144
    pattern_percent = find_percent(pattern);
    }
  }
#line 145
  if ((unsigned long )pattern_percent == (unsigned long )((char *)0)) {
    {
#line 147
    tmp___1 = strlen((char const   *)replace);
#line 147
    tmp___2 = strlen((char const   *)pattern);
#line 147
    tmp___3 = subst_expand(o, text, pattern, replace, (unsigned int )tmp___2, (unsigned int )tmp___1,
                           1, 0);
    }
#line 147
    return (tmp___3);
  }
  {
#line 152
  pattern_prepercent_len = (unsigned int )(pattern_percent - pattern);
#line 153
  tmp___4 = strlen((char const   *)(pattern_percent + 1));
#line 153
  pattern_postpercent_len = (unsigned int )tmp___4;
  }
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 155
    t = find_next_token(& text, & len);
    }
#line 155
    if (! ((unsigned long )t != (unsigned long )((char *)0))) {
#line 155
      goto while_break;
    }
#line 157
    fail = 0;
#line 160
    if (len < pattern_prepercent_len + pattern_postpercent_len) {
#line 161
      fail = 1;
    }
#line 164
    if (! fail) {
#line 164
      if (pattern_prepercent_len > 0U) {
#line 164
        if ((int )*t != (int )*pattern) {
#line 168
          fail = 1;
        } else
#line 164
        if ((int )*(t + (pattern_prepercent_len - 1U)) != (int )*(pattern_percent + -1)) {
#line 168
          fail = 1;
        } else {
          {
#line 164
          tmp___5 = strncmp((char const   *)(t + 1), (char const   *)(pattern + 1),
                            (size_t )(pattern_prepercent_len - 1U));
          }
#line 164
          if (tmp___5) {
#line 168
            fail = 1;
          }
        }
      }
    }
#line 171
    if (! fail) {
#line 171
      if (pattern_postpercent_len > 0U) {
#line 171
        if ((int )*(t + (len - 1U)) != (int )*(pattern_percent + pattern_postpercent_len)) {
#line 176
          fail = 1;
        } else
#line 171
        if ((int )*(t + (len - pattern_postpercent_len)) != (int )*(pattern_percent + 1)) {
#line 176
          fail = 1;
        } else {
          {
#line 171
          tmp___6 = strncmp((char const   *)(t + (len - pattern_postpercent_len)),
                            (char const   *)(pattern_percent + 1), (size_t )(pattern_postpercent_len - 1U));
          }
#line 171
          if (tmp___6) {
#line 176
            fail = 1;
          }
        }
      }
    }
#line 178
    if (fail) {
      {
#line 180
      o = variable_buffer_output(o, t, len);
      }
    } else {
      {
#line 186
      o = variable_buffer_output(o, replace, replace_prepercent_len);
      }
#line 188
      if ((unsigned long )replace_percent != (unsigned long )((char *)0)) {
        {
#line 192
        o = variable_buffer_output(o, t + pattern_prepercent_len, len - (pattern_prepercent_len + pattern_postpercent_len));
#line 196
        o = variable_buffer_output(o, replace_percent + 1, replace_postpercent_len);
        }
      }
    }
#line 202
    if (fail) {
      {
#line 205
      o = variable_buffer_output(o, (char *)" ", 1U);
#line 206
      doneany = 1;
      }
    } else
#line 202
    if (replace_prepercent_len > 0U) {
      {
#line 205
      o = variable_buffer_output(o, (char *)" ", 1U);
#line 206
      doneany = 1;
      }
    } else
#line 202
    if ((unsigned long )replace_percent != (unsigned long )((char *)0)) {
#line 202
      if (len + replace_postpercent_len > 0U) {
        {
#line 205
        o = variable_buffer_output(o, (char *)" ", 1U);
#line 206
        doneany = 1;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  if (doneany) {
#line 211
    o --;
  }
#line 213
  return (o);
}
}
#line 253 "/home/khheo/testset/make-3.76.1/function.c"
static struct __anonstruct_function_table_57 function_table[23]  = 
#line 253
  {      {(char *)"subst", 5U, (enum function )0}, 
        {(char *)"addsuffix", 9U, (enum function )1}, 
        {(char *)"addprefix", 9U, (enum function )2}, 
        {(char *)"dir", 3U, (enum function )3}, 
        {(char *)"notdir", 6U, (enum function )4}, 
        {(char *)"suffix", 6U, (enum function )5}, 
        {(char *)"basename", 8U, (enum function )6}, 
        {(char *)"wildcard", 8U, (enum function )7}, 
        {(char *)"firstword", 9U, (enum function )8}, 
        {(char *)"word", 4U, (enum function )9}, 
        {(char *)"words", 5U, (enum function )10}, 
        {(char *)"wordlist", 8U, (enum function )11}, 
        {(char *)"findstring", 10U, (enum function )12}, 
        {(char *)"strip", 5U, (enum function )13}, 
        {(char *)"join", 4U, (enum function )14}, 
        {(char *)"patsubst", 8U, (enum function )15}, 
        {(char *)"filter", 6U, (enum function )16}, 
        {(char *)"filter-out", 10U, (enum function )17}, 
        {(char *)"foreach", 7U, (enum function )18}, 
        {(char *)"sort", 4U, (enum function )19}, 
        {(char *)"origin", 6U, (enum function )20}, 
        {(char *)"shell", 5U, (enum function )21}, 
        {(char *)0, 0U, (enum function )22}};
#line 287 "/home/khheo/testset/make-3.76.1/function.c"
int pattern_matches(char *pattern , char *percent , char *word ) 
{ 
  unsigned int sfxlen ;
  unsigned int wordlen ;
  unsigned int len ;
  size_t tmp ;
  char *new ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 293
  if ((unsigned long )percent == (unsigned long )((char *)0)) {
    {
#line 295
    tmp = strlen((char const   *)pattern);
#line 295
    len = (unsigned int )(tmp + 1UL);
#line 296
    tmp___0 = __builtin_alloca((unsigned long )len);
#line 296
    new = (char *)tmp___0;
#line 297
    memmove((void *)new, (void const   *)pattern, (size_t )len);
#line 298
    pattern = new;
#line 299
    percent = find_percent(pattern);
    }
#line 300
    if ((unsigned long )percent == (unsigned long )((char *)0)) {
#line 301
      if ((unsigned long )pattern == (unsigned long )word) {
#line 301
        tmp___2 = 1;
      } else
#line 301
      if ((int )*pattern == (int )*word) {
#line 301
        if ((int )*pattern == 0) {
#line 301
          tmp___2 = 1;
        } else {
          {
#line 301
          tmp___1 = strcmp((char const   *)(pattern + 1), (char const   *)(word + 1));
          }
#line 301
          if (tmp___1) {
#line 301
            tmp___2 = 0;
          } else {
#line 301
            tmp___2 = 1;
          }
        }
      } else {
#line 301
        tmp___2 = 0;
      }
#line 301
      return (tmp___2);
    }
  }
  {
#line 304
  tmp___3 = strlen((char const   *)(percent + 1));
#line 304
  sfxlen = (unsigned int )tmp___3;
#line 305
  tmp___4 = strlen((char const   *)word);
#line 305
  wordlen = (unsigned int )tmp___4;
  }
#line 307
  if ((long )wordlen < (percent - pattern) + (long )sfxlen) {
#line 309
    return (0);
  } else {
    {
#line 307
    tmp___5 = strncmp((char const   *)pattern, (char const   *)word, (size_t )(percent - pattern));
    }
#line 307
    if (tmp___5) {
#line 309
      return (0);
    }
  }
  {
#line 311
  tmp___6 = strcmp((char const   *)(percent + 1), (char const   *)(word + (wordlen - sfxlen)));
  }
#line 311
  if (tmp___6) {
#line 311
    tmp___7 = 0;
  } else {
#line 311
    tmp___7 = 1;
  }
#line 311
  return (tmp___7);
}
}
#line 314 "/home/khheo/testset/make-3.76.1/function.c"
int shell_function_pid  =    0;
#line 314 "/home/khheo/testset/make-3.76.1/function.c"
int shell_function_completed  ;
#line 329 "/home/khheo/testset/make-3.76.1/function.c"
static char *expand_function(char *o , enum function function , char *text , char *end ) 
{ 
  char *p ;
  char *p2 ;
  char *p3 ;
  unsigned int i ;
  unsigned int j ;
  unsigned int len ;
  int doneany ;
  int count ;
  char endparen ;
  char startparen ;
  int tmp ;
  char **argv ;
  char *error_prefix ;
  char **envp ;
  int pipedes[2] ;
  int pid ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *buffer ;
  unsigned int maxlen ;
  int cc ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  ssize_t tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  register struct variable *v ;
  size_t tmp___10 ;
  struct variable *tmp___11 ;
  char **words ;
  char *tmp___12 ;
  unsigned int nwords ;
  register unsigned int wordi ;
  char *t ;
  char *tmp___13 ;
  unsigned int tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  char *var ;
  char *list ;
  register struct variable *v___0 ;
  size_t tmp___18 ;
  char *result___0 ;
  char save ;
  size_t tmp___19 ;
  struct word *words___0 ;
  struct word *wordtail ;
  struct word *wp ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  struct word *w ;
  void *tmp___22 ;
  char *percent ;
  char save___0 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  register char *tp ;
  register char *pp ;
  unsigned int tlen ;
  unsigned int plen ;
  unsigned short const   **tmp___29 ;
  unsigned short const   **tmp___30 ;
  size_t tmp___31 ;
  size_t tmp___32 ;
  size_t tmp___33 ;
  int tmp___34 ;
  char *tmp___35 ;
  char buf___0[20] ;
  size_t tmp___36 ;
  int tmp___37 ;
  unsigned short const   **tmp___38 ;
  int tmp___39 ;
  unsigned int k ;
  char *tmp___40 ;
  size_t tmp___41 ;
  char *tmp___42 ;
  char const   *tmp___43 ;
  char const   *tmp___44 ;
  size_t tmp___45 ;
  void *__cil_tmp92 ;
  void *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;

  {
#line 338
  doneany = 0;
#line 340
  endparen = *end;
#line 340
  if ((int )*end == 41) {
#line 340
    tmp = '(';
  } else {
#line 340
    tmp = '{';
  }
#line 340
  startparen = (char )tmp;
  {
#line 349
  if ((unsigned int )function == 21U) {
#line 349
    goto case_21;
  }
#line 722
  if ((unsigned int )function == 20U) {
#line 722
    goto case_20;
  }
#line 764
  if ((unsigned int )function == 19U) {
#line 764
    goto case_19;
  }
#line 814
  if ((unsigned int )function == 18U) {
#line 814
    goto case_18;
  }
#line 883
  if ((unsigned int )function == 17U) {
#line 883
    goto case_17;
  }
#line 883
  if ((unsigned int )function == 16U) {
#line 883
    goto case_17;
  }
#line 966
  if ((unsigned int )function == 15U) {
#line 966
    goto case_15;
  }
#line 1006
  if ((unsigned int )function == 14U) {
#line 1006
    goto case_14;
  }
#line 1060
  if ((unsigned int )function == 13U) {
#line 1060
    goto case_13;
  }
#line 1085
  if ((unsigned int )function == 7U) {
#line 1085
    goto case_7;
  }
#line 1098
  if ((unsigned int )function == 0U) {
#line 1098
    goto case_0___0;
  }
#line 1138
  if ((unsigned int )function == 8U) {
#line 1138
    goto case_8;
  }
#line 1151
  if ((unsigned int )function == 9U) {
#line 1151
    goto case_9;
  }
#line 1202
  if ((unsigned int )function == 10U) {
#line 1202
    goto case_10;
  }
#line 1220
  if ((unsigned int )function == 11U) {
#line 1220
    goto case_11;
  }
#line 1305
  if ((unsigned int )function == 12U) {
#line 1305
    goto case_12;
  }
#line 1333
  if ((unsigned int )function == 2U) {
#line 1333
    goto case_2___0;
  }
#line 1333
  if ((unsigned int )function == 1U) {
#line 1333
    goto case_2___0;
  }
#line 1372
  if ((unsigned int )function == 6U) {
#line 1372
    goto case_6___0;
  }
#line 1372
  if ((unsigned int )function == 3U) {
#line 1372
    goto case_6___0;
  }
#line 1427
  if ((unsigned int )function == 5U) {
#line 1427
    goto case_5___0;
  }
#line 1427
  if ((unsigned int )function == 4U) {
#line 1427
    goto case_5___0;
  }
#line 344
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 345
  abort();
  }
#line 346
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 371
  text = expand_argument(text, end);
#line 375
  argv = construct_command_argv(text, (char **)((void *)0), (struct file *)0);
  }
#line 377
  if ((unsigned long )argv == (unsigned long )((char **)0)) {
#line 378
    goto switch_break;
  }
#line 389
  envp = environ;
#line 397
  if ((unsigned long )reading_filename != (unsigned long )((char *)0)) {
    {
#line 399
    tmp___0 = strlen((char const   *)reading_filename);
#line 399
    tmp___1 = __builtin_alloca(tmp___0 + 100UL);
#line 399
    error_prefix = (char *)tmp___1;
#line 400
    sprintf((char */* __restrict  */)error_prefix, (char const   */* __restrict  */)"%s:%u: ",
            reading_filename, *reading_lineno_ptr);
    }
  } else {
#line 404
    error_prefix = (char *)"";
  }
  {
#line 507
  tmp___2 = pipe((int *)(pipedes));
  }
#line 507
  if (tmp___2 < 0) {
    {
#line 510
    perror_with_name(error_prefix, "pipe");
    }
#line 511
    goto switch_break;
  }
  {
#line 515
  pid = vfork();
  }
#line 516
  if (pid < 0) {
    {
#line 517
    perror_with_name(error_prefix, "fork");
    }
  } else
#line 518
  if (pid == 0) {
    {
#line 519
    child_execute_job(0, pipedes[1], argv, envp);
    }
  } else {
    {
#line 536
    shell_function_pid = pid;
#line 538
    shell_function_completed = 0;
#line 541
    free((void *)*(argv + 0));
#line 542
    free((void *)((char *)argv));
#line 545
    close(pipedes[1]);
#line 550
    maxlen = 200U;
#line 551
    tmp___3 = xmalloc(maxlen + 1U);
#line 551
    buffer = tmp___3;
#line 554
    i = 0U;
    }
    {
#line 555
    while (1) {
      while_continue: /* CIL Label */ ;
#line 557
      if (i == maxlen) {
        {
#line 559
        maxlen += 512U;
#line 560
        tmp___4 = xrealloc(buffer, maxlen + 1U);
#line 560
        buffer = tmp___4;
        }
      }
      {
#line 563
      tmp___5 = __errno_location();
#line 563
      *tmp___5 = 0;
#line 564
      tmp___6 = read(pipedes[0], (void *)(buffer + i), (size_t )(maxlen - i));
#line 564
      cc = (int )tmp___6;
      }
#line 565
      if (cc > 0) {
#line 566
        i += (unsigned int )cc;
      }
#line 555
      if (! (cc > 0)) {
        {
#line 555
        tmp___7 = __errno_location();
        }
#line 555
        if (! (*tmp___7 == 4)) {
#line 555
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 579
    close(pipedes[0]);
    }
    {
#line 584
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 584
      if (! (shell_function_completed == 0)) {
#line 584
        goto while_break___0;
      }
      {
#line 585
      reap_children(1, 0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 587
    shell_function_pid = 0;
#line 593
    if (shell_function_completed == -1) {
      {
#line 598
      fputs((char const   */* __restrict  */)buffer, (FILE */* __restrict  */)stderr);
#line 599
      fflush(stderr);
      }
    } else
#line 606
    if (i > 0U) {
#line 608
      if ((int )*(buffer + (i - 1U)) == 10) {
#line 610
        if (i > 1U) {
#line 610
          if ((int )*(buffer + (i - 2U)) == 13) {
#line 611
            i --;
          }
        }
#line 612
        i --;
#line 612
        *(buffer + i) = (char )'\000';
      } else {
#line 615
        *(buffer + i) = (char )'\000';
      }
#line 617
      p = buffer;
#line 618
      p2 = p;
      {
#line 618
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 618
        if (! ((int )*p != 0)) {
#line 618
          goto while_break___1;
        }
#line 620
        if ((int )*(p + 0) == 13) {
#line 620
          if ((int )*(p + 1) == 10) {
#line 621
            goto __Cont;
          }
        }
#line 622
        if ((int )*p == 10) {
#line 623
          tmp___8 = p2;
#line 623
          p2 ++;
#line 623
          *tmp___8 = (char )' ';
        } else {
#line 625
          tmp___9 = p2;
#line 625
          p2 ++;
#line 625
          *tmp___9 = *p;
        }
        __Cont: /* CIL Label */ 
#line 618
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 627
      *p2 = (char )'\000';
#line 628
      o = variable_buffer_output(o, buffer, i);
      }
    }
    {
#line 632
    free((void *)buffer);
    }
  }
  {
#line 717
  free((void *)text);
  }
#line 718
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 724
  text = expand_argument(text, end);
#line 727
  tmp___10 = strlen((char const   *)text);
#line 727
  tmp___11 = lookup_variable(text, (unsigned int )tmp___10);
#line 727
  v = tmp___11;
  }
#line 728
  if ((unsigned long )v == (unsigned long )((struct variable *)0)) {
    {
#line 729
    o = variable_buffer_output(o, (char *)"undefined", 9U);
    }
  } else {
    {
#line 737
    if ((unsigned int )v->origin == 0U) {
#line 737
      goto case_0;
    }
#line 740
    if ((unsigned int )v->origin == 1U) {
#line 740
      goto case_1;
    }
#line 743
    if ((unsigned int )v->origin == 2U) {
#line 743
      goto case_2;
    }
#line 746
    if ((unsigned int )v->origin == 3U) {
#line 746
      goto case_3;
    }
#line 749
    if ((unsigned int )v->origin == 4U) {
#line 749
      goto case_4;
    }
#line 752
    if ((unsigned int )v->origin == 5U) {
#line 752
      goto case_5;
    }
#line 755
    if ((unsigned int )v->origin == 6U) {
#line 755
      goto case_6;
    }
#line 733
    goto switch_default___0;
    switch_default___0: /* CIL Label */ 
    {
#line 735
    abort();
    }
#line 736
    goto switch_break___0;
    case_0: /* CIL Label */ 
    {
#line 738
    o = variable_buffer_output(o, (char *)"default", 7U);
    }
#line 739
    goto switch_break___0;
    case_1: /* CIL Label */ 
    {
#line 741
    o = variable_buffer_output(o, (char *)"environment", 11U);
    }
#line 742
    goto switch_break___0;
    case_2: /* CIL Label */ 
    {
#line 744
    o = variable_buffer_output(o, (char *)"file", 4U);
    }
#line 745
    goto switch_break___0;
    case_3: /* CIL Label */ 
    {
#line 747
    o = variable_buffer_output(o, (char *)"environment override", 20U);
    }
#line 748
    goto switch_break___0;
    case_4: /* CIL Label */ 
    {
#line 750
    o = variable_buffer_output(o, (char *)"command line", 12U);
    }
#line 751
    goto switch_break___0;
    case_5: /* CIL Label */ 
    {
#line 753
    o = variable_buffer_output(o, (char *)"override", 8U);
    }
#line 754
    goto switch_break___0;
    case_6: /* CIL Label */ 
    {
#line 756
    o = variable_buffer_output(o, (char *)"automatic", 9U);
    }
#line 757
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 761
  free((void *)text);
  }
#line 762
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 766
  text = expand_argument(text, end);
#line 769
  tmp___12 = xmalloc(10UL * sizeof(char *));
#line 769
  words = (char **)tmp___12;
#line 770
  nwords = 10U;
#line 771
  wordi = 0U;
#line 775
  t = text;
  }
  {
#line 776
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 776
    p = find_next_token(& t, & len);
    }
#line 776
    if (! ((unsigned long )p != (unsigned long )((char *)0))) {
#line 776
      goto while_break___2;
    }
#line 778
    if (wordi >= nwords - 1U) {
      {
#line 780
      nwords *= 2U;
#line 781
      tmp___13 = xrealloc((char *)words, (unsigned long )nwords * sizeof(char *));
#line 781
      words = (char **)tmp___13;
      }
    }
    {
#line 784
    tmp___14 = wordi;
#line 784
    wordi ++;
#line 784
    *(words + tmp___14) = savestring(p, len);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 787
  if (wordi > 0U) {
    {
#line 790
    qsort((void *)((char *)words), (size_t )wordi, sizeof(char *), (int (*)(void const   * ,
                                                                            void const   * ))(& alpha_compare));
#line 793
    i = 0U;
    }
    {
#line 793
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 793
      if (! (i < wordi)) {
#line 793
        goto while_break___3;
      }
      {
#line 795
      tmp___15 = strlen((char const   *)*(words + i));
#line 795
      len = (unsigned int )tmp___15;
      }
#line 796
      if (i == wordi - 1U) {
        {
#line 799
        o = variable_buffer_output(o, *(words + i), len);
#line 800
        o = variable_buffer_output(o, (char *)" ", 1U);
        }
      } else {
        {
#line 796
        tmp___16 = strlen((char const   *)*(words + (i + 1U)));
        }
#line 796
        if (tmp___16 != (size_t )len) {
          {
#line 799
          o = variable_buffer_output(o, *(words + i), len);
#line 800
          o = variable_buffer_output(o, (char *)" ", 1U);
          }
        } else {
          {
#line 796
          tmp___17 = strcmp((char const   *)*(words + i), (char const   *)*(words + (i + 1U)));
          }
#line 796
          if (tmp___17) {
            {
#line 799
            o = variable_buffer_output(o, *(words + i), len);
#line 800
            o = variable_buffer_output(o, (char *)" ", 1U);
            }
          }
        }
      }
      {
#line 802
      free((void *)*(words + i));
#line 793
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 805
    o --;
  }
  {
#line 808
  free((void *)((char *)words));
#line 811
  free((void *)text);
  }
#line 812
  goto switch_break;
  case_18: /* CIL Label */ 
#line 821
  count = 0;
#line 822
  p = text;
  {
#line 822
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 822
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 822
      goto while_break___4;
    }
#line 824
    if ((int )*p == (int )startparen) {
#line 825
      count ++;
    } else
#line 826
    if ((int )*p == (int )endparen) {
#line 827
      count --;
    } else
#line 828
    if ((int )*p == 44) {
#line 828
      if (count <= 0) {
#line 829
        goto while_break___4;
      }
    }
#line 822
    p ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 831
  if ((unsigned long )p == (unsigned long )end) {
#line 832
    if ((unsigned long )reading_filename != (unsigned long )((char *)0)) {
      {
#line 832
      makefile_fatal(reading_filename, *reading_lineno_ptr, "insufficient arguments to function `%s\'",
                     "foreach");
      }
    } else {
      {
#line 832
      fatal("insufficient arguments to function `%s\'", "foreach");
      }
    }
  }
  {
#line 833
  var = expand_argument(text, p);
#line 835
  p2 = p + 1;
#line 836
  count = 0;
#line 837
  p = p2;
  }
  {
#line 837
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 837
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 837
      goto while_break___5;
    }
#line 839
    if ((int )*p == (int )startparen) {
#line 840
      count ++;
    } else
#line 841
    if ((int )*p == (int )endparen) {
#line 842
      count --;
    } else
#line 843
    if ((int )*p == 44) {
#line 843
      if (count <= 0) {
#line 844
        goto while_break___5;
      }
    }
#line 837
    p ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 846
  if ((unsigned long )p == (unsigned long )end) {
#line 847
    if ((unsigned long )reading_filename != (unsigned long )((char *)0)) {
      {
#line 847
      makefile_fatal(reading_filename, *reading_lineno_ptr, "insufficient arguments to function `%s\'",
                     "foreach");
      }
    } else {
      {
#line 847
      fatal("insufficient arguments to function `%s\'", "foreach");
      }
    }
  }
  {
#line 848
  list = expand_argument(p2, p);
#line 850
  p ++;
#line 851
  text = savestring(p, end - p);
#line 853
  push_new_variable_scope();
#line 854
  tmp___18 = strlen((char const   *)var);
#line 854
  v___0 = define_variable(var, (unsigned int )tmp___18, (char *)"", (enum variable_origin )6,
                          0);
#line 855
  p3 = list;
  }
  {
#line 856
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 856
    p = find_next_token(& p3, & len);
    }
#line 856
    if (! ((unsigned long )p != (unsigned long )((char *)0))) {
#line 856
      goto while_break___6;
    }
    {
#line 859
    save = *(p + len);
#line 860
    *(p + len) = (char )'\000';
#line 861
    v___0->value = p;
#line 862
    result___0 = allocated_variable_expand_for_file(text, (struct file *)0);
#line 863
    *(p + len) = save;
#line 865
    tmp___19 = strlen((char const   *)result___0);
#line 865
    o = variable_buffer_output(o, result___0, (unsigned int )tmp___19);
#line 866
    o = variable_buffer_output(o, (char *)" ", 1U);
#line 867
    doneany = 1;
#line 868
    free((void *)result___0);
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 870
  if (doneany) {
#line 872
    o --;
  }
  {
#line 874
  pop_variable_scope();
#line 876
  free((void *)var);
#line 877
  free((void *)list);
#line 878
  free((void *)text);
  }
#line 880
  goto switch_break;
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
#line 893
  count = 0;
#line 894
  p = text;
  {
#line 894
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 894
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 894
      goto while_break___7;
    }
#line 896
    if ((int )*p == (int )startparen) {
#line 897
      count ++;
    } else
#line 898
    if ((int )*p == (int )endparen) {
#line 899
      count --;
    } else
#line 900
    if ((int )*p == 44) {
#line 900
      if (count <= 0) {
#line 901
        goto while_break___7;
      }
    }
#line 894
    p ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 903
  if ((unsigned long )p == (unsigned long )end) {
#line 904
    if ((unsigned long )reading_filename != (unsigned long )((char *)0)) {
#line 904
      if ((unsigned int )function == 16U) {
#line 904
        tmp___20 = "filter";
      } else {
#line 904
        tmp___20 = "filter-out";
      }
      {
#line 904
      makefile_fatal(reading_filename, *reading_lineno_ptr, "insufficient arguments to function `%s\'",
                     tmp___20);
      }
    } else {
#line 904
      if ((unsigned int )function == 16U) {
#line 904
        tmp___21 = "filter";
      } else {
#line 904
        tmp___21 = "filter-out";
      }
      {
#line 904
      fatal("insufficient arguments to function `%s\'", tmp___21);
      }
    }
  }
  {
#line 905
  p2 = expand_argument(text, p);
#line 907
  text = expand_argument(p + 1, end);
#line 910
  wordtail = (struct word *)0;
#line 910
  words___0 = wordtail;
#line 911
  p3 = text;
  }
  {
#line 912
  while (1) {
    while_continue___8: /* CIL Label */ ;
    {
#line 912
    p = find_next_token(& p3, & len);
    }
#line 912
    if (! ((unsigned long )p != (unsigned long )((char *)0))) {
#line 912
      goto while_break___8;
    }
    {
#line 914
    tmp___22 = __builtin_alloca(sizeof(struct word ));
#line 914
    w = (struct word *)tmp___22;
    }
#line 915
    if ((unsigned long )words___0 == (unsigned long )((struct word *)0)) {
#line 916
      words___0 = w;
    } else {
#line 918
      wordtail->next = w;
    }
#line 919
    wordtail = w;
#line 921
    if ((int )*p3 != 0) {
#line 922
      p3 ++;
    }
#line 923
    *(p + len) = (char )'\000';
#line 924
    w->word = p;
#line 925
    w->matched = 0;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 928
  if ((unsigned long )words___0 != (unsigned long )((struct word *)0)) {
#line 930
    wordtail->next = (struct word *)0;
#line 933
    p3 = p2;
    {
#line 934
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 934
      p = find_next_token(& p3, & len);
      }
#line 934
      if (! ((unsigned long )p != (unsigned long )((char *)0))) {
#line 934
        goto while_break___9;
      }
      {
#line 937
      save___0 = *(p + len);
#line 938
      *(p + len) = (char )'\000';
#line 940
      percent = find_percent(p);
#line 941
      wp = words___0;
      }
      {
#line 941
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 941
        if (! ((unsigned long )wp != (unsigned long )((struct word *)0))) {
#line 941
          goto while_break___10;
        }
#line 942
        if ((unsigned long )percent == (unsigned long )((char *)0)) {
#line 942
          if ((unsigned long )p == (unsigned long )wp->word) {
#line 942
            tmp___24 = 1;
          } else
#line 942
          if ((int )*p == (int )*(wp->word)) {
#line 942
            if ((int )*p == 0) {
#line 942
              tmp___24 = 1;
            } else {
              {
#line 942
              tmp___23 = strcmp((char const   *)(p + 1), (char const   *)(wp->word + 1));
              }
#line 942
              if (tmp___23) {
#line 942
                tmp___24 = 0;
              } else {
#line 942
                tmp___24 = 1;
              }
            }
          } else {
#line 942
            tmp___24 = 0;
          }
#line 942
          tmp___26 = tmp___24;
        } else {
          {
#line 942
          tmp___25 = pattern_matches(p, percent, wp->word);
#line 942
          tmp___26 = tmp___25;
          }
        }
#line 942
        wp->matched |= tmp___26;
#line 941
        wp = wp->next;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 945
      *(p + len) = save___0;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 949
    wp = words___0;
    {
#line 949
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 949
      if (! ((unsigned long )wp != (unsigned long )((struct word *)0))) {
#line 949
        goto while_break___11;
      }
#line 950
      if ((unsigned int )function == 16U) {
#line 950
        tmp___28 = wp->matched;
      } else {
#line 950
        tmp___28 = ! wp->matched;
      }
#line 950
      if (tmp___28) {
        {
#line 952
        tmp___27 = strlen((char const   *)wp->word);
#line 952
        o = variable_buffer_output(o, wp->word, (unsigned int )tmp___27);
#line 953
        o = variable_buffer_output(o, (char *)" ", 1U);
#line 954
        doneany = 1;
        }
      }
#line 949
      wp = wp->next;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 956
    if (doneany) {
#line 958
      o --;
    }
  }
  {
#line 961
  free((void *)p2);
#line 962
  free((void *)text);
  }
#line 964
  goto switch_break;
  case_15: /* CIL Label */ 
#line 968
  count = 0;
#line 969
  p = text;
  {
#line 969
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 969
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 969
      goto while_break___12;
    }
#line 971
    if ((int )*p == (int )startparen) {
#line 972
      count ++;
    } else
#line 973
    if ((int )*p == (int )endparen) {
#line 974
      count --;
    } else
#line 975
    if ((int )*p == 44) {
#line 975
      if (count <= 0) {
#line 976
        goto while_break___12;
      }
    }
#line 969
    p ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 978
  if ((unsigned long )p == (unsigned long )end) {
#line 979
    if ((unsigned long )reading_filename != (unsigned long )((char *)0)) {
      {
#line 979
      makefile_fatal(reading_filename, *reading_lineno_ptr, "insufficient arguments to function `%s\'",
                     "patsubst");
      }
    } else {
      {
#line 979
      fatal("insufficient arguments to function `%s\'", "patsubst");
      }
    }
  }
#line 981
  p2 = p;
#line 982
  count = 0;
#line 983
  p ++;
  {
#line 983
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 983
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 983
      goto while_break___13;
    }
#line 985
    if ((int )*p == (int )startparen) {
#line 986
      count ++;
    } else
#line 987
    if ((int )*p == (int )endparen) {
#line 988
      count --;
    } else
#line 989
    if ((int )*p == 44) {
#line 989
      if (count <= 0) {
#line 990
        goto while_break___13;
      }
    }
#line 983
    p ++;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 992
  if ((unsigned long )p == (unsigned long )end) {
#line 993
    if ((unsigned long )reading_filename != (unsigned long )((char *)0)) {
      {
#line 993
      makefile_fatal(reading_filename, *reading_lineno_ptr, "insufficient arguments to function `%s\'",
                     "patsubst");
      }
    } else {
      {
#line 993
      fatal("insufficient arguments to function `%s\'", "patsubst");
      }
    }
  }
  {
#line 995
  text = expand_argument(text, p2);
#line 996
  p3 = expand_argument(p2 + 1, p);
#line 997
  p2 = expand_argument(p + 1, end);
#line 999
  o = patsubst_expand(o, p2, text, p3, (char *)0, (char *)0);
#line 1001
  free((void *)text);
#line 1002
  free((void *)p3);
#line 1003
  free((void *)p2);
  }
#line 1004
  goto switch_break;
  case_14: /* CIL Label */ 
#line 1008
  count = 0;
#line 1009
  p = text;
  {
#line 1009
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 1009
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 1009
      goto while_break___14;
    }
#line 1011
    if ((int )*p == (int )startparen) {
#line 1012
      count ++;
    } else
#line 1013
    if ((int )*p == (int )endparen) {
#line 1014
      count --;
    } else
#line 1015
    if ((int )*p == 44) {
#line 1015
      if (count <= 0) {
#line 1016
        goto while_break___14;
      }
    }
#line 1009
    p ++;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 1018
  if ((unsigned long )p == (unsigned long )end) {
#line 1019
    if ((unsigned long )reading_filename != (unsigned long )((char *)0)) {
      {
#line 1019
      makefile_fatal(reading_filename, *reading_lineno_ptr, "insufficient arguments to function `%s\'",
                     "join");
      }
    } else {
      {
#line 1019
      fatal("insufficient arguments to function `%s\'", "join");
      }
    }
  }
  {
#line 1020
  text = expand_argument(text, p);
#line 1022
  p = expand_argument(p + 1, end);
#line 1030
  p2 = text;
#line 1031
  p3 = p;
  }
  {
#line 1032
  while (1) {
    while_continue___15: /* CIL Label */ ;
    {
#line 1036
    tp = find_next_token(& p2, & tlen);
    }
#line 1037
    if ((unsigned long )tp != (unsigned long )((char *)0)) {
      {
#line 1038
      o = variable_buffer_output(o, tp, tlen);
      }
    }
    {
#line 1040
    pp = find_next_token(& p3, & plen);
    }
#line 1041
    if ((unsigned long )pp != (unsigned long )((char *)0)) {
      {
#line 1042
      o = variable_buffer_output(o, pp, plen);
      }
    }
#line 1044
    if ((unsigned long )tp != (unsigned long )((char *)0)) {
      {
#line 1046
      o = variable_buffer_output(o, (char *)" ", 1U);
#line 1047
      doneany = 1;
      }
    } else
#line 1044
    if ((unsigned long )pp != (unsigned long )((char *)0)) {
      {
#line 1046
      o = variable_buffer_output(o, (char *)" ", 1U);
#line 1047
      doneany = 1;
      }
    }
#line 1032
    if (! ((unsigned long )tp != (unsigned long )((char *)0))) {
#line 1032
      if (! ((unsigned long )pp != (unsigned long )((char *)0))) {
#line 1032
        goto while_break___15;
      }
    }
  }
  while_break___15: /* CIL Label */ ;
  }
#line 1051
  if (doneany) {
#line 1053
    o --;
  }
  {
#line 1056
  free((void *)text);
#line 1057
  free((void *)p);
  }
#line 1058
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 1062
  text = expand_argument(text, end);
#line 1064
  p2 = text;
  }
  {
#line 1065
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 1065
    if (! ((int )*p2 != 0)) {
#line 1065
      goto while_break___16;
    }
    {
#line 1067
    while (1) {
      while_continue___17: /* CIL Label */ ;
      {
#line 1067
      tmp___29 = __ctype_b_loc();
      }
#line 1067
      if (! ((int const   )*(*tmp___29 + (int )*p2) & 8192)) {
#line 1067
        goto while_break___17;
      }
#line 1068
      p2 ++;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 1069
    p = p2;
#line 1070
    i = 0U;
    {
#line 1070
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 1070
      if ((int )*p2 != 0) {
        {
#line 1070
        tmp___30 = __ctype_b_loc();
        }
#line 1070
        if ((int const   )*(*tmp___30 + (int )*p2) & 8192) {
#line 1070
          goto while_break___18;
        }
      } else {
#line 1070
        goto while_break___18;
      }
#line 1070
      p2 ++;
#line 1070
      i ++;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 1072
    if (! i) {
#line 1073
      goto while_break___16;
    }
    {
#line 1074
    o = variable_buffer_output(o, p, i);
#line 1075
    o = variable_buffer_output(o, (char *)" ", 1U);
#line 1076
    doneany = 1;
    }
  }
  while_break___16: /* CIL Label */ ;
  }
#line 1078
  if (doneany) {
#line 1080
    o --;
  }
  {
#line 1082
  free((void *)text);
  }
#line 1083
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1086
  text = expand_argument(text, end);
#line 1091
  p = string_glob(text);
#line 1092
  tmp___31 = strlen((char const   *)p);
#line 1092
  o = variable_buffer_output(o, p, (unsigned int )tmp___31);
#line 1095
  free((void *)text);
  }
#line 1096
  goto switch_break;
  case_0___0: /* CIL Label */ 
#line 1100
  count = 0;
#line 1101
  p = text;
  {
#line 1101
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 1101
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 1101
      goto while_break___19;
    }
#line 1103
    if ((int )*p == (int )startparen) {
#line 1104
      count ++;
    } else
#line 1105
    if ((int )*p == (int )endparen) {
#line 1106
      count --;
    } else
#line 1107
    if ((int )*p == 44) {
#line 1107
      if (count <= 0) {
#line 1108
        goto while_break___19;
      }
    }
#line 1101
    p ++;
  }
  while_break___19: /* CIL Label */ ;
  }
#line 1110
  if ((unsigned long )p == (unsigned long )end) {
#line 1111
    if ((unsigned long )reading_filename != (unsigned long )((char *)0)) {
      {
#line 1111
      makefile_fatal(reading_filename, *reading_lineno_ptr, "insufficient arguments to function `%s\'",
                     "subst");
      }
    } else {
      {
#line 1111
      fatal("insufficient arguments to function `%s\'", "subst");
      }
    }
  }
#line 1113
  p2 = p;
#line 1114
  count = 0;
#line 1115
  p ++;
  {
#line 1115
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 1115
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 1115
      goto while_break___20;
    }
#line 1117
    if ((int )*p == (int )startparen) {
#line 1118
      count ++;
    } else
#line 1119
    if ((int )*p == (int )endparen) {
#line 1120
      count --;
    } else
#line 1121
    if ((int )*p == 44) {
#line 1121
      if (count <= 0) {
#line 1122
        goto while_break___20;
      }
    }
#line 1115
    p ++;
  }
  while_break___20: /* CIL Label */ ;
  }
#line 1124
  if ((unsigned long )p == (unsigned long )end) {
#line 1125
    if ((unsigned long )reading_filename != (unsigned long )((char *)0)) {
      {
#line 1125
      makefile_fatal(reading_filename, *reading_lineno_ptr, "insufficient arguments to function `%s\'",
                     "subst");
      }
    } else {
      {
#line 1125
      fatal("insufficient arguments to function `%s\'", "subst");
      }
    }
  }
  {
#line 1127
  text = expand_argument(text, p2);
#line 1128
  p3 = expand_argument(p2 + 1, p);
#line 1129
  p2 = expand_argument(p + 1, end);
#line 1131
  tmp___32 = strlen((char const   *)p3);
#line 1131
  tmp___33 = strlen((char const   *)text);
#line 1131
  o = subst_expand(o, p2, text, p3, (unsigned int )tmp___33, (unsigned int )tmp___32,
                   0, 0);
#line 1133
  free((void *)text);
#line 1134
  free((void *)p3);
#line 1135
  free((void *)p2);
  }
#line 1136
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1140
  text = expand_argument(text, end);
#line 1143
  p2 = text;
#line 1144
  p = find_next_token(& p2, & i);
  }
#line 1145
  if ((unsigned long )p != (unsigned long )((char *)0)) {
    {
#line 1146
    o = variable_buffer_output(o, p, i);
    }
  }
  {
#line 1148
  free((void *)text);
  }
#line 1149
  goto switch_break;
  case_9: /* CIL Label */ 
#line 1153
  count = 0;
#line 1154
  p = text;
  {
#line 1154
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 1154
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 1154
      goto while_break___21;
    }
#line 1156
    if ((int )*p == (int )startparen) {
#line 1157
      count ++;
    } else
#line 1158
    if ((int )*p == (int )endparen) {
#line 1159
      count --;
    } else
#line 1160
    if ((int )*p == 44) {
#line 1160
      if (count <= 0) {
#line 1161
        goto while_break___21;
      }
    }
#line 1154
    p ++;
  }
  while_break___21: /* CIL Label */ ;
  }
#line 1163
  if ((unsigned long )p == (unsigned long )end) {
#line 1164
    if ((unsigned long )reading_filename != (unsigned long )((char *)0)) {
      {
#line 1164
      makefile_fatal(reading_filename, *reading_lineno_ptr, "insufficient arguments to function `%s\'",
                     "word");
      }
    } else {
      {
#line 1164
      fatal("insufficient arguments to function `%s\'", "word");
      }
    }
  }
  {
#line 1165
  text = expand_argument(text, p);
#line 1167
  p3 = expand_argument(p + 1, end);
#line 1170
  p2 = text;
  }
  {
#line 1170
  while (1) {
    while_continue___22: /* CIL Label */ ;
#line 1170
    if (! ((int )*p2 != 0)) {
#line 1170
      goto while_break___22;
    }
#line 1171
    if ((int )*p2 < 48) {
#line 1171
      goto _L;
    } else
#line 1171
    if ((int )*p2 > 57) {
      _L: /* CIL Label */ 
#line 1173
      if ((unsigned long )reading_filename != (unsigned long )((char *)0)) {
        {
#line 1174
        makefile_fatal(reading_filename, *reading_lineno_ptr, "non-numeric first argument to `word\' function");
        }
      } else {
        {
#line 1177
        fatal("non-numeric first argument to `word\' function");
        }
      }
    }
#line 1170
    p2 ++;
  }
  while_break___22: /* CIL Label */ ;
  }
  {
#line 1180
  tmp___34 = atoi((char const   *)text);
#line 1180
  i = (unsigned int )tmp___34;
  }
#line 1181
  if (i == 0U) {
#line 1183
    if ((unsigned long )reading_filename != (unsigned long )((char *)0)) {
      {
#line 1184
      makefile_fatal(reading_filename, *reading_lineno_ptr, "the `word\' function takes a one-origin index argument");
      }
    } else {
      {
#line 1188
      fatal("the `word\' function takes a one-origin index argument");
      }
    }
  }
#line 1191
  p2 = p3;
  {
#line 1192
  while (1) {
    while_continue___23: /* CIL Label */ ;
    {
#line 1192
    p = find_next_token(& p2, & len);
    }
#line 1192
    if (! ((unsigned long )p != (unsigned long )((char *)0))) {
#line 1192
      goto while_break___23;
    }
#line 1193
    i --;
#line 1193
    if (i == 0U) {
#line 1194
      goto while_break___23;
    }
  }
  while_break___23: /* CIL Label */ ;
  }
#line 1195
  if (i == 0U) {
    {
#line 1196
    o = variable_buffer_output(o, p, len);
    }
  }
  {
#line 1198
  free((void *)text);
#line 1199
  free((void *)p3);
  }
#line 1200
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 1204
  text = expand_argument(text, end);
#line 1206
  i = 0U;
#line 1207
  p2 = text;
  }
  {
#line 1208
  while (1) {
    while_continue___24: /* CIL Label */ ;
    {
#line 1208
    tmp___35 = find_next_token(& p2, (unsigned int *)0);
    }
#line 1208
    if (! ((unsigned long )tmp___35 != (unsigned long )((char *)0))) {
#line 1208
      goto while_break___24;
    }
#line 1209
    i ++;
  }
  while_break___24: /* CIL Label */ ;
  }
  {
#line 1213
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d",
          i);
#line 1214
  tmp___36 = strlen((char const   *)(buf___0));
#line 1214
  o = variable_buffer_output(o, buf___0, (unsigned int )tmp___36);
#line 1217
  free((void *)text);
  }
#line 1218
  goto switch_break;
  case_11: /* CIL Label */ 
#line 1222
  count = 0;
#line 1223
  p = text;
  {
#line 1223
  while (1) {
    while_continue___25: /* CIL Label */ ;
#line 1223
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 1223
      goto while_break___25;
    }
#line 1225
    if ((int )*p == (int )startparen) {
#line 1226
      count ++;
    } else
#line 1227
    if ((int )*p == (int )endparen) {
#line 1228
      count --;
    } else
#line 1229
    if ((int )*p == 44) {
#line 1229
      if (count <= 0) {
#line 1230
        goto while_break___25;
      }
    }
#line 1223
    p ++;
  }
  while_break___25: /* CIL Label */ ;
  }
#line 1232
  if ((unsigned long )p == (unsigned long )end) {
#line 1233
    if ((unsigned long )reading_filename != (unsigned long )((char *)0)) {
      {
#line 1233
      makefile_fatal(reading_filename, *reading_lineno_ptr, "insufficient arguments to function `%s\'",
                     "wordlist");
      }
    } else {
      {
#line 1233
      fatal("insufficient arguments to function `%s\'", "wordlist");
      }
    }
  }
  {
#line 1234
  text = expand_argument(text, p);
#line 1237
  p2 = text;
  }
  {
#line 1237
  while (1) {
    while_continue___26: /* CIL Label */ ;
#line 1237
    if (! ((int )*p2 != 0)) {
#line 1237
      goto while_break___26;
    }
#line 1238
    if ((int )*p2 < 48) {
#line 1238
      goto _L___0;
    } else
#line 1238
    if ((int )*p2 > 57) {
      _L___0: /* CIL Label */ 
#line 1240
      if ((unsigned long )reading_filename != (unsigned long )((char *)0)) {
        {
#line 1241
        makefile_fatal(reading_filename, *reading_lineno_ptr, "non-numeric first argument to `wordlist\' function");
        }
      } else {
        {
#line 1244
        fatal("non-numeric first argument to `wordlist\' function");
        }
      }
    }
#line 1237
    p2 ++;
  }
  while_break___26: /* CIL Label */ ;
  }
  {
#line 1246
  tmp___37 = atoi((char const   *)text);
#line 1246
  i = (unsigned int )tmp___37;
#line 1247
  free((void *)text);
#line 1250
  p2 = p + 1;
  }
  {
#line 1250
  while (1) {
    while_continue___27: /* CIL Label */ ;
    {
#line 1250
    tmp___38 = __ctype_b_loc();
    }
#line 1250
    if (! ((int const   )*(*tmp___38 + (int )*p2) & 1)) {
#line 1250
      goto while_break___27;
    }
#line 1250
    p2 ++;
  }
  while_break___27: /* CIL Label */ ;
  }
#line 1252
  count = 0;
#line 1253
  p = p2;
  {
#line 1253
  while (1) {
    while_continue___28: /* CIL Label */ ;
#line 1253
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 1253
      goto while_break___28;
    }
#line 1255
    if ((int )*p == (int )startparen) {
#line 1256
      count ++;
    } else
#line 1257
    if ((int )*p == (int )endparen) {
#line 1258
      count --;
    } else
#line 1259
    if ((int )*p == 44) {
#line 1259
      if (count <= 0) {
#line 1260
        goto while_break___28;
      }
    }
#line 1253
    p ++;
  }
  while_break___28: /* CIL Label */ ;
  }
#line 1262
  if ((unsigned long )p == (unsigned long )end) {
#line 1263
    if ((unsigned long )reading_filename != (unsigned long )((char *)0)) {
      {
#line 1263
      makefile_fatal(reading_filename, *reading_lineno_ptr, "insufficient arguments to function `%s\'",
                     "wordlist");
      }
    } else {
      {
#line 1263
      fatal("insufficient arguments to function `%s\'", "wordlist");
      }
    }
  }
  {
#line 1264
  text = expand_argument(p2, p);
#line 1266
  p2 = text;
  }
  {
#line 1266
  while (1) {
    while_continue___29: /* CIL Label */ ;
#line 1266
    if (! ((int )*p2 != 0)) {
#line 1266
      goto while_break___29;
    }
#line 1267
    if ((int )*p2 < 48) {
#line 1267
      goto _L___1;
    } else
#line 1267
    if ((int )*p2 > 57) {
      _L___1: /* CIL Label */ 
#line 1269
      if ((unsigned long )reading_filename != (unsigned long )((char *)0)) {
        {
#line 1270
        makefile_fatal(reading_filename, *reading_lineno_ptr, "non-numeric second argument to `wordlist\' function");
        }
      } else {
        {
#line 1273
        fatal("non-numeric second argument to `wordlist\' function");
        }
      }
    }
#line 1266
    p2 ++;
  }
  while_break___29: /* CIL Label */ ;
  }
  {
#line 1275
  tmp___39 = atoi((char const   *)text);
#line 1275
  j = (unsigned int )tmp___39;
#line 1276
  free((void *)text);
  }
#line 1278
  if (j > i) {
#line 1279
    j -= i;
  } else {
#line 1283
    k = j;
#line 1284
    j = i - j;
#line 1285
    i = k;
  }
  {
#line 1287
  j ++;
#line 1290
  text = expand_argument(p + 1, end);
#line 1291
  p2 = text;
  }
  {
#line 1293
  while (1) {
    while_continue___30: /* CIL Label */ ;
    {
#line 1293
    p = find_next_token(& p2, & len);
    }
#line 1293
    if ((unsigned long )p != (unsigned long )((char *)0)) {
#line 1293
      i --;
#line 1293
      if (! i) {
#line 1293
        goto while_break___30;
      }
    } else {
#line 1293
      goto while_break___30;
    }
  }
  while_break___30: /* CIL Label */ ;
  }
#line 1295
  if (p) {
    {
#line 1297
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 1297
      j --;
#line 1297
      if (j) {
        {
#line 1297
        tmp___40 = find_next_token(& p2, & len);
        }
#line 1297
        if (! ((unsigned long )tmp___40 != (unsigned long )((char *)0))) {
#line 1297
          goto while_break___31;
        }
      } else {
#line 1297
        goto while_break___31;
      }
    }
    while_break___31: /* CIL Label */ ;
    }
    {
#line 1299
    o = variable_buffer_output(o, p, (unsigned int )(p2 - p));
    }
  }
  {
#line 1302
  free((void *)text);
  }
#line 1303
  goto switch_break;
  case_12: /* CIL Label */ 
#line 1307
  count = 0;
#line 1308
  p = text;
  {
#line 1308
  while (1) {
    while_continue___32: /* CIL Label */ ;
#line 1308
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 1308
      goto while_break___32;
    }
#line 1310
    if ((int )*p == (int )startparen) {
#line 1311
      count ++;
    } else
#line 1312
    if ((int )*p == (int )endparen) {
#line 1313
      count --;
    } else
#line 1314
    if ((int )*p == 44) {
#line 1314
      if (count <= 0) {
#line 1315
        goto while_break___32;
      }
    }
#line 1308
    p ++;
  }
  while_break___32: /* CIL Label */ ;
  }
#line 1317
  if ((unsigned long )p == (unsigned long )end) {
#line 1318
    if ((unsigned long )reading_filename != (unsigned long )((char *)0)) {
      {
#line 1318
      makefile_fatal(reading_filename, *reading_lineno_ptr, "insufficient arguments to function `%s\'",
                     "findstring");
      }
    } else {
      {
#line 1318
      fatal("insufficient arguments to function `%s\'", "findstring");
      }
    }
  }
  {
#line 1319
  text = expand_argument(text, p);
#line 1321
  p = expand_argument(p + 1, end);
#line 1324
  tmp___41 = strlen((char const   *)text);
#line 1324
  i = (unsigned int )tmp___41;
#line 1325
  tmp___42 = sindex(p, 0, text, i);
  }
#line 1325
  if ((unsigned long )tmp___42 != (unsigned long )((char *)0)) {
    {
#line 1326
    o = variable_buffer_output(o, text, i);
    }
  }
  {
#line 1328
  free((void *)p);
#line 1329
  free((void *)text);
  }
#line 1330
  goto switch_break;
  case_2___0: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
#line 1335
  count = 0;
#line 1336
  p = text;
  {
#line 1336
  while (1) {
    while_continue___33: /* CIL Label */ ;
#line 1336
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 1336
      goto while_break___33;
    }
#line 1338
    if ((int )*p == (int )startparen) {
#line 1339
      count ++;
    } else
#line 1340
    if ((int )*p == (int )endparen) {
#line 1341
      count --;
    } else
#line 1342
    if ((int )*p == 44) {
#line 1342
      if (count <= 0) {
#line 1343
        goto while_break___33;
      }
    }
#line 1336
    p ++;
  }
  while_break___33: /* CIL Label */ ;
  }
#line 1345
  if ((unsigned long )p == (unsigned long )end) {
#line 1346
    if ((unsigned long )reading_filename != (unsigned long )((char *)0)) {
#line 1346
      if ((unsigned int )function == 1U) {
#line 1346
        tmp___43 = "addsuffix";
      } else {
#line 1346
        tmp___43 = "addprefix";
      }
      {
#line 1346
      makefile_fatal(reading_filename, *reading_lineno_ptr, "insufficient arguments to function `%s\'",
                     tmp___43);
      }
    } else {
#line 1346
      if ((unsigned int )function == 1U) {
#line 1346
        tmp___44 = "addsuffix";
      } else {
#line 1346
        tmp___44 = "addprefix";
      }
      {
#line 1346
      fatal("insufficient arguments to function `%s\'", tmp___44);
      }
    }
  }
  {
#line 1347
  text = expand_argument(text, p);
#line 1348
  tmp___45 = strlen((char const   *)text);
#line 1348
  i = (unsigned int )tmp___45;
#line 1350
  p2 = expand_argument(p + 1, end);
#line 1352
  p3 = p2;
  }
  {
#line 1353
  while (1) {
    while_continue___34: /* CIL Label */ ;
    {
#line 1353
    p = find_next_token(& p3, & len);
    }
#line 1353
    if (! ((unsigned long )p != (unsigned long )((char *)0))) {
#line 1353
      goto while_break___34;
    }
#line 1355
    if ((unsigned int )function == 2U) {
      {
#line 1356
      o = variable_buffer_output(o, text, i);
      }
    }
    {
#line 1357
    o = variable_buffer_output(o, p, len);
    }
#line 1358
    if ((unsigned int )function == 1U) {
      {
#line 1359
      o = variable_buffer_output(o, text, i);
      }
    }
    {
#line 1360
    o = variable_buffer_output(o, (char *)" ", 1U);
#line 1361
    doneany = 1;
    }
  }
  while_break___34: /* CIL Label */ ;
  }
#line 1363
  if (doneany) {
#line 1365
    o --;
  }
  {
#line 1367
  free((void *)p2);
#line 1368
  free((void *)text);
  }
#line 1369
  goto switch_break;
  case_6___0: /* CIL Label */ 
  case_3___0: /* CIL Label */ 
  {
#line 1374
  text = expand_argument(text, end);
#line 1376
  p3 = text;
  }
  {
#line 1377
  while (1) {
    while_continue___35: /* CIL Label */ ;
    {
#line 1377
    p2 = find_next_token(& p3, & len);
    }
#line 1377
    if (! ((unsigned long )p2 != (unsigned long )((char *)0))) {
#line 1377
      goto while_break___35;
    }
#line 1379
    p = p2 + len;
    {
#line 1388
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 1388
      if ((unsigned long )p >= (unsigned long )p2) {
#line 1388
        if ((int )*p != 47) {
#line 1388
          if (! ((unsigned int )function != 6U)) {
#line 1388
            if (! ((int )*p != 46)) {
#line 1388
              goto while_break___36;
            }
          }
        } else {
#line 1388
          goto while_break___36;
        }
      } else {
#line 1388
        goto while_break___36;
      }
#line 1392
      p --;
    }
    while_break___36: /* CIL Label */ ;
    }
#line 1393
    if ((unsigned long )p >= (unsigned long )p2) {
#line 1393
      if ((unsigned int )function == 3U) {
        {
#line 1394
        p ++;
#line 1394
        o = variable_buffer_output(o, p2, (unsigned int )(p - p2));
        }
      } else {
#line 1393
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 1395
    if ((unsigned long )p >= (unsigned long )p2) {
#line 1395
      if ((int )*p == 46) {
        {
#line 1396
        o = variable_buffer_output(o, p2, (unsigned int )(p - p2));
        }
      } else {
#line 1395
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1402
    if ((unsigned int )function == 3U) {
      {
#line 1407
      o = variable_buffer_output(o, (char *)"./", 2U);
      }
    } else {
      {
#line 1414
      o = variable_buffer_output(o, p2, len);
      }
    }
    {
#line 1416
    o = variable_buffer_output(o, (char *)" ", 1U);
#line 1417
    doneany = 1;
    }
  }
  while_break___35: /* CIL Label */ ;
  }
#line 1419
  if (doneany) {
#line 1421
    o --;
  }
  {
#line 1423
  free((void *)text);
  }
#line 1424
  goto switch_break;
  case_5___0: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  {
#line 1429
  text = expand_argument(text, end);
#line 1431
  p3 = text;
  }
  {
#line 1432
  while (1) {
    while_continue___37: /* CIL Label */ ;
    {
#line 1432
    p2 = find_next_token(& p3, & len);
    }
#line 1432
    if (! ((unsigned long )p2 != (unsigned long )((char *)0))) {
#line 1432
      goto while_break___37;
    }
#line 1434
    p = p2 + len;
    {
#line 1443
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 1443
      if ((unsigned long )p >= (unsigned long )p2) {
#line 1443
        if ((int )*p != 47) {
#line 1443
          if (! ((unsigned int )function != 5U)) {
#line 1443
            if (! ((int )*p != 46)) {
#line 1443
              goto while_break___38;
            }
          }
        } else {
#line 1443
          goto while_break___38;
        }
      } else {
#line 1443
        goto while_break___38;
      }
#line 1447
      p --;
    }
    while_break___38: /* CIL Label */ ;
    }
#line 1448
    if ((unsigned long )p >= (unsigned long )p2) {
#line 1450
      if ((unsigned int )function == 4U) {
#line 1451
        p ++;
      } else
#line 1452
      if ((int )*p != 46) {
#line 1453
        goto while_continue___37;
      }
      {
#line 1454
      o = variable_buffer_output(o, p, (unsigned int )((long )len - (p - p2)));
      }
    } else
#line 1464
    if ((unsigned int )function == 4U) {
      {
#line 1465
      o = variable_buffer_output(o, p2, len);
      }
    }
#line 1467
    if ((unsigned int )function == 4U) {
      {
#line 1469
      o = variable_buffer_output(o, (char *)" ", 1U);
#line 1470
      doneany = 1;
      }
    } else
#line 1467
    if ((unsigned long )p >= (unsigned long )p2) {
      {
#line 1469
      o = variable_buffer_output(o, (char *)" ", 1U);
#line 1470
      doneany = 1;
      }
    }
  }
  while_break___37: /* CIL Label */ ;
  }
#line 1473
  if (doneany) {
#line 1475
    o --;
  }
  {
#line 1477
  free((void *)text);
  }
#line 1478
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1481
  return (o);
}
}
#line 1540 "/home/khheo/testset/make-3.76.1/function.c"
static char const   errmsg[49]  = 
#line 1540
  {      (char const   )'u',      (char const   )'n',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )'m',      (char const   )'i',      (char const   )'n', 
        (char const   )'a',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'c',      (char const   )'a',      (char const   )'l', 
        (char const   )'l',      (char const   )' ',      (char const   )'t',      (char const   )'o', 
        (char const   )' ',      (char const   )'f',      (char const   )'u',      (char const   )'n', 
        (char const   )'c',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'`',      (char const   )'%', 
        (char const   )'s',      (char const   )'\'',      (char const   )':',      (char const   )' ', 
        (char const   )'m',      (char const   )'i',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'`',      (char const   )'%',      (char const   )'c',      (char const   )'\'', 
        (char const   )'\000'};
#line 1489 "/home/khheo/testset/make-3.76.1/function.c"
int handle_function(char **op , char **stringp ) 
{ 
  register unsigned int code ;
  unsigned int maxlen ;
  char *beg ;
  char *endref ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char openparen ;
  char closeparen ;
  int tmp___1 ;
  int count ;
  char *argbeg ;
  register char *p ;

  {
  {
#line 1497
  beg = *stringp + 1;
#line 1500
  endref = lindex(beg, beg + 11, '\000');
  }
#line 1501
  if ((unsigned long )endref != (unsigned long )((char *)0)) {
#line 1501
    maxlen = (unsigned int )(endref - beg);
  } else {
#line 1501
    maxlen = 11U;
  }
#line 1503
  code = 0U;
  {
#line 1503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1503
    if (! ((unsigned long )function_table[code].name != (unsigned long )((char *)0))) {
#line 1503
      goto while_break;
    }
#line 1505
    if (maxlen < function_table[code].len) {
#line 1506
      goto __Cont;
    }
    {
#line 1507
    endref = beg + function_table[code].len;
#line 1508
    tmp = __ctype_b_loc();
    }
#line 1508
    if ((int const   )*(*tmp + (int )*endref) & 1) {
      {
#line 1508
      tmp___0 = strncmp((char const   *)function_table[code].name, (char const   *)beg,
                        (size_t )function_table[code].len);
      }
#line 1508
      if (! tmp___0) {
#line 1511
        goto while_break;
      }
    }
    __Cont: /* CIL Label */ 
#line 1503
    code ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1513
  if ((unsigned long )function_table[code].name != (unsigned long )((char *)0)) {
#line 1518
    openparen = *(beg + -1);
#line 1518
    if ((int )openparen == 40) {
#line 1518
      tmp___1 = ')';
    } else {
#line 1518
      tmp___1 = '}';
    }
    {
#line 1518
    closeparen = (char )tmp___1;
#line 1519
    count = 0;
#line 1524
    p = next_token(endref);
#line 1525
    argbeg = p;
    }
    {
#line 1530
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1530
      if (! ((int )*p != 0)) {
#line 1530
        goto while_break___0;
      }
#line 1532
      if ((int )*p == (int )openparen) {
#line 1533
        count ++;
      } else
#line 1534
      if ((int )*p == (int )closeparen) {
#line 1534
        count --;
#line 1534
        if (count < 0) {
#line 1535
          goto while_break___0;
        }
      }
#line 1530
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1538
    if (count >= 0) {
#line 1542
      if ((unsigned long )reading_filename == (unsigned long )((char *)0)) {
        {
#line 1543
        fatal(errmsg, function_table[code].name, (int )closeparen);
        }
      } else {
        {
#line 1545
        makefile_fatal(reading_filename, *reading_lineno_ptr, errmsg, function_table[code].name,
                       (int )closeparen);
        }
      }
    }
    {
#line 1551
    *op = expand_function(*op, function_table[code].function, argbeg, p);
#line 1552
    *stringp = p;
    }
#line 1553
    return (1);
  }
#line 1556
  return (0);
}
}
#line 1566 "/home/khheo/testset/make-3.76.1/function.c"
static char *result  =    (char *)0;
#line 1567 "/home/khheo/testset/make-3.76.1/function.c"
static unsigned int length  ;
#line 1562 "/home/khheo/testset/make-3.76.1/function.c"
static char *string_glob(char *line ) 
{ 
  register struct nameseq *chain ;
  register unsigned int idx ;
  struct nameseq *tmp ;
  char *tmp___0 ;
  register char *name___0 ;
  unsigned int len ;
  size_t tmp___1 ;
  struct nameseq *next ;
  char *tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1571
  tmp = parse_file_seq(& line, '\000', (unsigned int )sizeof(struct nameseq ), 0);
#line 1571
  chain = multi_glob(tmp, (unsigned int )sizeof(struct nameseq ));
  }
#line 1579
  if ((unsigned long )result == (unsigned long )((char *)0)) {
    {
#line 1581
    length = 100U;
#line 1582
    tmp___0 = xmalloc(100);
#line 1582
    result = tmp___0;
    }
  }
#line 1585
  idx = 0U;
  {
#line 1586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1586
    if (! ((unsigned long )chain != (unsigned long )((struct nameseq *)0))) {
#line 1586
      goto while_break;
    }
    {
#line 1588
    name___0 = chain->name;
#line 1589
    tmp___1 = strlen((char const   *)name___0);
#line 1589
    len = (unsigned int )tmp___1;
#line 1591
    next = chain->next;
#line 1592
    free((void *)((char *)chain));
#line 1593
    chain = next;
#line 1597
    tmp___4 = file_exists_p(name___0);
    }
#line 1597
    if (tmp___4) {
#line 1599
      if ((idx + len) + 1U > length) {
        {
#line 1601
        length += (len + 1U) * 2U;
#line 1602
        tmp___2 = xrealloc(result, length);
#line 1602
        result = tmp___2;
        }
      }
      {
#line 1604
      memmove((void *)(result + idx), (void const   *)name___0, (size_t )len);
#line 1605
      idx += len;
#line 1606
      tmp___3 = idx;
#line 1606
      idx ++;
#line 1606
      *(result + tmp___3) = (char )' ';
      }
    }
    {
#line 1609
    free((void *)name___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1613
  if (idx == 0U) {
#line 1614
    *(result + 0) = (char )'\000';
  } else {
#line 1616
    *(result + (idx - 1U)) = (char )'\000';
  }
#line 1618
  return (result);
}
}
#line 320 "/home/khheo/testset/make-3.76.1/make.h"
void makefile_error(char *file , unsigned int lineno , char *s1 , char *s2 , char *s3 ,
                    char *s4 , char *s5 , char *s6 ) ;
#line 71 "/home/khheo/testset/make-3.76.1/variable.h"
struct variable_set_list *current_variable_set_list ;
#line 76
char *variable_expand_for_file(char *line , struct file *file ) ;
#line 91
char *recursively_expand(struct variable *v ) ;
#line 31 "/home/khheo/testset/make-3.76.1/expand.c"
static unsigned int variable_buffer_length  ;
#line 32 "/home/khheo/testset/make-3.76.1/expand.c"
static char *variable_buffer  ;
#line 41 "/home/khheo/testset/make-3.76.1/expand.c"
char *variable_buffer_output(char *ptr , char *string , unsigned int length___0 ) 
{ 
  register unsigned int newlen ;
  unsigned int offset ;
  char *tmp ;

  {
#line 46
  newlen = (unsigned int )((long )length___0 + (ptr - variable_buffer));
#line 48
  if (newlen > variable_buffer_length) {
#line 50
    offset = (unsigned int )(ptr - variable_buffer);
#line 51
    if (newlen + 100U > 2U * variable_buffer_length) {
#line 51
      variable_buffer_length = newlen + 100U;
    } else {
#line 51
      variable_buffer_length = 2U * variable_buffer_length;
    }
    {
#line 54
    tmp = xrealloc(variable_buffer, variable_buffer_length);
#line 54
    variable_buffer = tmp;
#line 56
    ptr = variable_buffer + offset;
    }
  }
  {
#line 59
  memmove((void *)ptr, (void const   *)string, (size_t )length___0);
  }
#line 60
  return (ptr + length___0);
}
}
#line 65 "/home/khheo/testset/make-3.76.1/expand.c"
static char *initialize_variable_output(void) 
{ 
  char *tmp ;

  {
#line 70
  if ((unsigned long )variable_buffer == (unsigned long )((char *)0)) {
    {
#line 72
    variable_buffer_length = 200U;
#line 73
    tmp = xmalloc(variable_buffer_length);
#line 73
    variable_buffer = tmp;
#line 74
    *(variable_buffer + 0) = (char )'\000';
    }
  }
#line 77
  return (variable_buffer);
}
}
#line 82 "/home/khheo/testset/make-3.76.1/expand.c"
char *recursively_expand(struct variable *v ) 
{ 
  char *value ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 88
  if (v->expanding) {
#line 91
    if ((unsigned long )reading_filename == (unsigned long )((char *)0)) {
      {
#line 92
      fatal("Recursive variable `%s\' references itself (eventually)", v->name);
      }
    } else {
      {
#line 95
      makefile_fatal(reading_filename, *reading_lineno_ptr, "Recursive variable `%s\' references itself (eventually)",
                     v->name);
      }
    }
  }
  {
#line 101
  v->expanding = 1U;
#line 102
  value = allocated_variable_expand_for_file(v->value, (struct file *)0);
#line 103
  v->expanding = 0U;
  }
#line 105
  return (value);
}
}
#line 120
__inline static void warn_undefined(char *name___0 , unsigned int length___0 ) ;
#line 120 "/home/khheo/testset/make-3.76.1/expand.c"
static char const   warnmsg[35]  = 
#line 120
  {      (char const   )'w',      (char const   )'a',      (char const   )'r',      (char const   )'n', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )':', 
        (char const   )' ',      (char const   )'u',      (char const   )'n',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'i',      (char const   )'n', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'v', 
        (char const   )'a',      (char const   )'r',      (char const   )'i',      (char const   )'a', 
        (char const   )'b',      (char const   )'l',      (char const   )'e',      (char const   )' ', 
        (char const   )'`',      (char const   )'%',      (char const   )'.',      (char const   )'*', 
        (char const   )'s',      (char const   )'\'',      (char const   )'\000'};
#line 111 "/home/khheo/testset/make-3.76.1/expand.c"
__inline static void warn_undefined(char *name___0 , unsigned int length___0 ) 
{ 


  {
#line 118
  if (warn_undefined_variables_flag) {
#line 121
    if ((unsigned long )reading_filename != (unsigned long )((char *)0)) {
      {
#line 122
      makefile_error(reading_filename, *reading_lineno_ptr, warnmsg, length___0, name___0);
      }
    } else {
      {
#line 125
      error(warnmsg, length___0, name___0);
      }
    }
  }
#line 127
  return;
}
}
#line 132 "/home/khheo/testset/make-3.76.1/expand.c"
__inline static char *reference_variable(char *o , char *name___0 , unsigned int length___0 ) 
{ 
  register struct variable *v ;
  struct variable *tmp ;
  char *value ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 140
  tmp = lookup_variable(name___0, length___0);
#line 140
  v = tmp;
  }
#line 142
  if ((unsigned long )v == (unsigned long )((struct variable *)0)) {
    {
#line 143
    warn_undefined(name___0, length___0);
    }
  }
#line 145
  if ((unsigned long )v != (unsigned long )((struct variable *)0)) {
#line 145
    if ((int )*(v->value) != 0) {
#line 147
      if (v->recursive) {
        {
#line 147
        tmp___0 = recursively_expand(v);
#line 147
        tmp___1 = tmp___0;
        }
      } else {
#line 147
        tmp___1 = v->value;
      }
      {
#line 147
      value = tmp___1;
#line 148
      tmp___2 = strlen((char const   *)value);
#line 148
      o = variable_buffer_output(o, value, (unsigned int )tmp___2);
      }
#line 149
      if (v->recursive) {
        {
#line 150
        free((void *)value);
        }
      }
    }
  }
#line 153
  return (o);
}
}
#line 161 "/home/khheo/testset/make-3.76.1/expand.c"
char *variable_expand(char *line ) 
{ 
  register struct variable *v ;
  register char *p ;
  register char *o ;
  register char *p1 ;
  size_t tmp ;
  size_t tmp___0 ;
  char openparen ;
  char closeparen ;
  int tmp___1 ;
  register char *beg ;
  int free_beg ;
  char *op ;
  char *begp ;
  char *end ;
  char *colon ;
  int tmp___2 ;
  int count ;
  char *subst_beg ;
  char *subst_end ;
  char *replace_beg ;
  char *replace_end ;
  char *value ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *pattern ;
  char *percent ;
  void *tmp___5 ;
  char *replace ;
  void *tmp___6 ;
  size_t tmp___7 ;
  unsigned short const   **tmp___8 ;
  char name___0[5] ;
  size_t tmp___9 ;
  char *tmp___10 ;
  void *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
  {
#line 168
  p = line;
#line 169
  o = initialize_variable_output();
  }
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 177
    p1 = strchr((char const   *)p, '$');
    }
#line 179
    if ((unsigned long )p1 != (unsigned long )((char *)0)) {
#line 179
      tmp___0 = (size_t )(p1 - p);
    } else {
      {
#line 179
      tmp = strlen((char const   *)p);
#line 179
      tmp___0 = tmp + 1UL;
      }
    }
    {
#line 179
    o = variable_buffer_output(o, p, (unsigned int )tmp___0);
    }
#line 181
    if ((unsigned long )p1 == (unsigned long )((char *)0)) {
#line 182
      goto while_break;
    }
#line 183
    p = p1 + 1;
    {
#line 189
    if ((int )*p == 36) {
#line 189
      goto case_36;
    }
#line 195
    if ((int )*p == 123) {
#line 195
      goto case_123;
    }
#line 195
    if ((int )*p == 40) {
#line 195
      goto case_123;
    }
#line 345
    if ((int )*p == 0) {
#line 345
      goto case_0;
    }
#line 348
    goto switch_default;
    case_36: /* CIL Label */ 
    {
#line 191
    o = variable_buffer_output(o, p, 1U);
    }
#line 192
    goto switch_break;
    case_123: /* CIL Label */ 
    case_40: /* CIL Label */ 
#line 198
    openparen = *p;
#line 199
    if ((int )openparen == 40) {
#line 199
      tmp___1 = ')';
    } else {
#line 199
      tmp___1 = '}';
    }
    {
#line 199
    closeparen = (char )tmp___1;
#line 200
    beg = p + 1;
#line 201
    free_beg = 0;
#line 205
    op = o;
#line 206
    begp = p;
#line 207
    tmp___2 = handle_function(& op, & begp);
    }
#line 207
    if (tmp___2) {
#line 209
      o = op;
#line 210
      p = begp;
#line 211
      goto switch_break;
    }
    {
#line 217
    end = strchr((char const   *)beg, (int )closeparen);
    }
#line 218
    if ((unsigned long )end == (unsigned long )((char *)0)) {
#line 221
      if ((unsigned long )reading_filename != (unsigned long )((char *)0)) {
        {
#line 222
        makefile_fatal(reading_filename, *reading_lineno_ptr, "unterminated variable reference");
        }
      } else {
        {
#line 225
        fatal("unterminated variable reference");
        }
      }
    }
    {
#line 227
    p1 = lindex(beg, end, '$');
    }
#line 228
    if ((unsigned long )p1 != (unsigned long )((char *)0)) {
#line 232
      count = 0;
#line 233
      p = beg;
      {
#line 233
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 233
        if (! ((int )*p != 0)) {
#line 233
          goto while_break___0;
        }
#line 235
        if ((int )*p == (int )openparen) {
#line 236
          count ++;
        } else
#line 237
        if ((int )*p == (int )closeparen) {
#line 237
          count --;
#line 237
          if (count < 0) {
#line 238
            goto while_break___0;
          }
        }
#line 233
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 243
      if (count < 0) {
        {
#line 245
        beg = expand_argument(beg, p);
#line 246
        free_beg = 1;
#line 247
        end = strchr((char const   *)beg, '\000');
        }
      }
    } else {
#line 254
      p = end;
    }
    {
#line 260
    colon = lindex(beg, end, ':');
    }
#line 261
    if ((unsigned long )colon != (unsigned long )((char *)0)) {
      {
#line 266
      subst_beg = colon + 1;
#line 267
      subst_end = strchr((char const   *)subst_beg, '=');
      }
#line 268
      if ((unsigned long )subst_end == (unsigned long )((char *)0)) {
#line 272
        colon = (char *)0;
      } else {
        {
#line 275
        replace_beg = subst_end + 1;
#line 276
        replace_end = end;
#line 280
        v = lookup_variable(beg, (unsigned int )(colon - beg));
        }
#line 281
        if ((unsigned long )v == (unsigned long )((struct variable *)0)) {
          {
#line 282
          warn_undefined(beg, (unsigned int )(colon - beg));
          }
        }
#line 284
        if ((unsigned long )v != (unsigned long )((struct variable *)0)) {
#line 284
          if ((int )*(v->value) != 0) {
#line 286
            if (v->recursive) {
              {
#line 286
              tmp___3 = recursively_expand(v);
#line 286
              tmp___4 = tmp___3;
              }
            } else {
#line 286
              tmp___4 = v->value;
            }
#line 286
            value = tmp___4;
#line 289
            if (free_beg) {
#line 291
              *subst_end = (char )'\000';
#line 292
              pattern = subst_beg;
            } else {
              {
#line 296
              tmp___5 = __builtin_alloca((unsigned long )((subst_end - subst_beg) + 1L));
#line 296
              pattern = (char *)tmp___5;
#line 298
              memmove((void *)pattern, (void const   *)subst_beg, (size_t )(subst_end - subst_beg));
#line 299
              *(pattern + (subst_end - subst_beg)) = (char )'\000';
              }
            }
            {
#line 301
            percent = find_percent(pattern);
            }
#line 302
            if ((unsigned long )percent != (unsigned long )((char *)0)) {
#line 305
              if (free_beg) {
#line 307
                *replace_end = (char )'\000';
#line 308
                replace = replace_beg;
              } else {
                {
#line 312
                tmp___6 = __builtin_alloca((unsigned long )((replace_end - replace_beg) + 1L));
#line 312
                replace = (char *)tmp___6;
#line 315
                memmove((void *)replace, (void const   *)replace_beg, (size_t )(replace_end - replace_beg));
#line 317
                *(replace + (replace_end - replace_beg)) = (char )'\000';
                }
              }
              {
#line 320
              o = patsubst_expand(o, value, pattern, replace, percent, (char *)0);
              }
            } else {
              {
#line 324
              tmp___7 = strlen((char const   *)pattern);
#line 324
              o = subst_expand(o, value, pattern, replace_beg, (unsigned int )tmp___7,
                               (unsigned int )(end - replace_beg), 0, 1);
              }
            }
#line 329
            if (v->recursive) {
              {
#line 330
              free((void *)value);
              }
            }
          }
        }
      }
    }
#line 335
    if ((unsigned long )colon == (unsigned long )((char *)0)) {
      {
#line 338
      o = reference_variable(o, beg, (unsigned int )(end - beg));
      }
    }
#line 340
    if (free_beg) {
      {
#line 341
      free((void *)beg);
      }
    }
#line 343
    goto switch_break;
    case_0: /* CIL Label */ 
#line 346
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 349
    tmp___8 = __ctype_b_loc();
    }
#line 349
    if ((int const   )*(*tmp___8 + (int )*(p + -1)) & 1) {
#line 350
      goto switch_break;
    }
    {
#line 358
    name___0[0] = (char )'$';
#line 359
    name___0[1] = (char )'(';
#line 360
    name___0[2] = *p;
#line 361
    name___0[3] = (char )')';
#line 362
    name___0[4] = (char )'\000';
#line 363
    p1 = allocated_variable_expand_for_file(name___0, (struct file *)0);
#line 364
    tmp___9 = strlen((char const   *)p1);
#line 364
    o = variable_buffer_output(o, p1, (unsigned int )tmp___9);
#line 365
    free((void *)p1);
    }
#line 368
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 371
    if ((int )*p == 0) {
#line 372
      goto while_break;
    } else {
#line 374
      p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 377
  variable_buffer_output(o, (char *)"", 1U);
#line 378
  tmp___10 = initialize_variable_output();
  }
#line 378
  return (tmp___10);
}
}
#line 387 "/home/khheo/testset/make-3.76.1/expand.c"
char *expand_argument(char *str , char *end ) 
{ 
  char *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 393
  if ((int )*end == 0) {
#line 394
    tmp = str;
  } else {
    {
#line 397
    tmp___0 = __builtin_alloca((unsigned long )((end - str) + 1L));
#line 397
    tmp = (char *)tmp___0;
#line 398
    memmove((void *)tmp, (void const   *)str, (size_t )(end - str));
#line 399
    *(tmp + (end - str)) = (char )'\000';
    }
  }
  {
#line 402
  tmp___1 = allocated_variable_expand_for_file(tmp, (struct file *)0);
  }
#line 402
  return (tmp___1);
}
}
#line 408 "/home/khheo/testset/make-3.76.1/expand.c"
char *variable_expand_for_file(char *line , struct file *file ) 
{ 
  char *result___0 ;
  struct variable_set_list *save ;
  char *tmp ;

  {
#line 416
  if ((unsigned long )file == (unsigned long )((struct file *)0)) {
    {
#line 417
    tmp = variable_expand(line);
    }
#line 417
    return (tmp);
  }
  {
#line 419
  save = current_variable_set_list;
#line 420
  current_variable_set_list = file->variables;
#line 421
  reading_filename = (file->cmds)->filename;
#line 422
  reading_lineno_ptr = & (file->cmds)->lineno;
#line 423
  result___0 = variable_expand(line);
#line 424
  current_variable_set_list = save;
#line 425
  reading_filename = (char *)0;
#line 426
  reading_lineno_ptr = (unsigned int *)0;
  }
#line 428
  return (result___0);
}
}
#line 434 "/home/khheo/testset/make-3.76.1/expand.c"
char *allocated_variable_expand_for_file(char *line , struct file *file ) 
{ 
  char *value ;
  char *obuf ;
  unsigned int olen ;

  {
  {
#line 441
  obuf = variable_buffer;
#line 442
  olen = variable_buffer_length;
#line 444
  variable_buffer = (char *)0;
#line 446
  value = variable_expand_for_file(line, file);
#line 453
  variable_buffer = obuf;
#line 454
  variable_buffer_length = olen;
  }
#line 456
  return (value);
}
}
#line 580 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 411 "/home/khheo/testset/make-3.76.1/make.h"
int env_overrides ;
#line 425
unsigned int makelevel ;
#line 96 "/home/khheo/testset/make-3.76.1/variable.h"
void define_automatic_variables(void) ;
#line 97
void initialize_file_variables(struct file *file ) ;
#line 98
void print_file_variables(struct file *file ) ;
#line 99
void merge_variable_set_lists(struct variable_set_list **setlist0 , struct variable_set_list *setlist1 ) ;
#line 100
struct variable *try_variable_definition(char *filename , unsigned int lineno , char *line ,
                                         enum variable_origin origin ) ;
#line 105
struct variable *define_variable_for_file(char *name___0 , unsigned int length___0 ,
                                          char *value , enum variable_origin origin ,
                                          int recursive , struct file *file ) ;
#line 107
char **target_environment(struct file *file ) ;
#line 109 "/home/khheo/testset/make-3.76.1/variable.h"
int export_all_variables  ;
#line 40 "/home/khheo/testset/make-3.76.1/variable.c"
static struct variable *variable_table[523]  ;
#line 41 "/home/khheo/testset/make-3.76.1/variable.c"
static struct variable_set global_variable_set  =    {variable_table, 523U};
#line 43 "/home/khheo/testset/make-3.76.1/variable.c"
static struct variable_set_list global_setlist  =    {(struct variable_set_list *)0, & global_variable_set};
#line 45 "/home/khheo/testset/make-3.76.1/variable.c"
struct variable_set_list *current_variable_set_list  =    & global_setlist;
#line 47
static struct variable *define_variable_in_set(char *name___0 , unsigned int length___0 ,
                                               char *value , enum variable_origin origin ,
                                               int recursive , struct variable_set *set ) ;
#line 61 "/home/khheo/testset/make-3.76.1/variable.c"
static struct variable *define_variable_in_set(char *name___0 , unsigned int length___0 ,
                                               char *value , enum variable_origin origin ,
                                               int recursive , struct variable_set *set ) 
{ 
  register unsigned int i ;
  register unsigned int hashval ;
  register struct variable *v ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;

  {
#line 74
  hashval = 0U;
#line 75
  i = 0U;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (i < length___0)) {
#line 75
      goto while_break;
    }
#line 76
    hashval += (unsigned int )*(name___0 + i);
#line 76
    hashval = (hashval << 7) + (hashval >> 20);
#line 75
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  hashval %= set->buckets;
#line 79
  v = *(set->table + hashval);
  {
#line 79
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 79
    if (! ((unsigned long )v != (unsigned long )((struct variable *)0))) {
#line 79
      goto while_break___0;
    }
#line 80
    if ((int )*(v->name) == (int )*name___0) {
      {
#line 80
      tmp = strncmp((char const   *)(v->name + 1), (char const   *)(name___0 + 1),
                    (size_t )(length___0 - 1U));
      }
#line 80
      if (! tmp) {
#line 80
        if ((int )*(v->name + length___0) == 0) {
#line 83
          goto while_break___0;
        }
      }
    }
#line 79
    v = v->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 85
  if (env_overrides) {
#line 85
    if ((unsigned int )origin == 1U) {
#line 86
      origin = (enum variable_origin )3;
    }
  }
#line 88
  if ((unsigned long )v != (unsigned long )((struct variable *)0)) {
#line 90
    if (env_overrides) {
#line 90
      if ((unsigned int )v->origin == 1U) {
#line 93
        v->origin = (enum variable_origin )3;
      }
    }
#line 98
    if ((int )origin >= (int )v->origin) {
#line 100
      if ((unsigned long )v->value != (unsigned long )((char *)0)) {
        {
#line 101
        free((void *)v->value);
        }
      }
      {
#line 102
      tmp___0 = strlen((char const   *)value);
#line 102
      v->value = savestring(value, tmp___0);
#line 103
      v->origin = origin;
#line 104
      v->recursive = (unsigned int )recursive;
      }
    }
#line 106
    return (v);
  }
  {
#line 111
  tmp___1 = xmalloc(sizeof(struct variable ));
#line 111
  v = (struct variable *)tmp___1;
#line 112
  v->name = savestring(name___0, length___0);
#line 113
  tmp___2 = strlen((char const   *)value);
#line 113
  v->value = savestring(value, tmp___2);
#line 114
  v->origin = origin;
#line 115
  v->recursive = (unsigned int )recursive;
#line 116
  v->expanding = 0U;
#line 117
  v->export = (enum __anonenum_export_56 )3;
#line 118
  v->next = *(set->table + hashval);
#line 119
  *(set->table + hashval) = v;
  }
#line 120
  return (v);
}
}
#line 125 "/home/khheo/testset/make-3.76.1/variable.c"
struct variable *define_variable(char *name___0 , unsigned int length___0 , char *value ,
                                 enum variable_origin origin , int recursive ) 
{ 
  struct variable *tmp ;

  {
  {
#line 133
  tmp = define_variable_in_set(name___0, length___0, value, origin, recursive, current_variable_set_list->set);
  }
#line 133
  return (tmp);
}
}
#line 139 "/home/khheo/testset/make-3.76.1/variable.c"
struct variable *define_variable_for_file(char *name___0 , unsigned int length___0 ,
                                          char *value , enum variable_origin origin ,
                                          int recursive , struct file *file ) 
{ 
  struct variable *tmp ;

  {
  {
#line 148
  tmp = define_variable_in_set(name___0, length___0, value, origin, recursive, (file->variables)->set);
  }
#line 148
  return (tmp);
}
}
#line 157 "/home/khheo/testset/make-3.76.1/variable.c"
struct variable *lookup_variable(char *name___0 , unsigned int length___0 ) 
{ 
  register struct variable_set_list *setlist ;
  register unsigned int i ;
  register unsigned int rawhash ;
  register struct variable_set *set ;
  register unsigned int hashval ;
  register struct variable *v ;
  int tmp ;

  {
#line 165
  rawhash = 0U;
#line 167
  i = 0U;
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (i < length___0)) {
#line 167
      goto while_break;
    }
#line 168
    rawhash += (unsigned int )*(name___0 + i);
#line 168
    rawhash = (rawhash << 7) + (rawhash >> 20);
#line 167
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  setlist = current_variable_set_list;
  {
#line 170
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 170
    if (! ((unsigned long )setlist != (unsigned long )((struct variable_set_list *)0))) {
#line 170
      goto while_break___0;
    }
#line 173
    set = setlist->set;
#line 174
    hashval = rawhash % set->buckets;
#line 177
    v = *(set->table + hashval);
    {
#line 177
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 177
      if (! ((unsigned long )v != (unsigned long )((struct variable *)0))) {
#line 177
        goto while_break___1;
      }
#line 178
      if ((int )*(v->name) == (int )*name___0) {
        {
#line 178
        tmp = strncmp((char const   *)(v->name + 1), (char const   *)(name___0 + 1),
                      (size_t )(length___0 - 1U));
        }
#line 178
        if (! tmp) {
#line 178
          if ((int )*(v->name + length___0) == 0) {
#line 181
            return (v);
          }
        }
      }
#line 177
      v = v->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 170
    setlist = setlist->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 184
  return ((struct variable *)0);
}
}
#line 191 "/home/khheo/testset/make-3.76.1/variable.c"
void initialize_file_variables(struct file *file ) 
{ 
  register struct variable_set_list *l ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 195
  l = file->variables;
#line 196
  if ((unsigned long )l == (unsigned long )((struct variable_set_list *)0)) {
    {
#line 198
    tmp = xmalloc(sizeof(struct variable_set_list ));
#line 198
    l = (struct variable_set_list *)tmp;
#line 200
    tmp___0 = xmalloc(sizeof(struct variable_set ));
#line 200
    l->set = (struct variable_set *)tmp___0;
#line 201
    (l->set)->buckets = 23U;
#line 202
    tmp___1 = xmalloc((unsigned long )(l->set)->buckets * sizeof(struct variable *));
#line 202
    (l->set)->table = (struct variable **)tmp___1;
#line 204
    memset((void *)((char *)(l->set)->table), 0, (unsigned long )(l->set)->buckets * sizeof(struct variable *));
#line 206
    file->variables = l;
    }
  }
#line 209
  if ((unsigned long )file->parent == (unsigned long )((struct file *)0)) {
#line 210
    l->next = & global_setlist;
  } else {
#line 213
    if ((unsigned long )(file->parent)->variables == (unsigned long )((struct variable_set_list *)0)) {
      {
#line 214
      initialize_file_variables(file->parent);
      }
    }
#line 215
    l->next = (file->parent)->variables;
  }
#line 217
  return;
}
}
#line 222 "/home/khheo/testset/make-3.76.1/variable.c"
void pop_variable_scope(void) 
{ 
  register struct variable_set_list *setlist ;
  register struct variable_set *set ;
  register unsigned int i ;
  register struct variable *next ;
  register struct variable *v ;

  {
  {
#line 225
  setlist = current_variable_set_list;
#line 226
  set = setlist->set;
#line 229
  current_variable_set_list = setlist->next;
#line 230
  free((void *)((char *)setlist));
#line 232
  i = 0U;
  }
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (! (i < set->buckets)) {
#line 232
      goto while_break;
    }
#line 234
    next = *(set->table + i);
    {
#line 235
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 235
      if (! ((unsigned long )next != (unsigned long )((struct variable *)0))) {
#line 235
        goto while_break___0;
      }
      {
#line 237
      v = next;
#line 238
      next = v->next;
#line 240
      free((void *)v->name);
#line 241
      free((void *)((char *)v));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 232
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 244
  free((void *)((char *)set->table));
#line 245
  free((void *)((char *)set));
  }
#line 246
  return;
}
}
#line 250 "/home/khheo/testset/make-3.76.1/variable.c"
void push_new_variable_scope(void) 
{ 
  register struct variable_set_list *setlist ;
  register struct variable_set *set ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 256
  tmp = xmalloc(sizeof(struct variable_set ));
#line 256
  set = (struct variable_set *)tmp;
#line 257
  set->buckets = 13U;
#line 258
  tmp___0 = xmalloc((unsigned long )set->buckets * sizeof(struct variable *));
#line 258
  set->table = (struct variable **)tmp___0;
#line 260
  memset((void *)((char *)set->table), 0, (unsigned long )set->buckets * sizeof(struct variable *));
#line 262
  tmp___1 = xmalloc(sizeof(struct variable_set_list ));
#line 262
  setlist = (struct variable_set_list *)tmp___1;
#line 264
  setlist->set = set;
#line 265
  setlist->next = current_variable_set_list;
#line 266
  current_variable_set_list = setlist;
  }
#line 267
  return;
}
}
#line 271 "/home/khheo/testset/make-3.76.1/variable.c"
static void merge_variable_sets(struct variable_set *set0 , struct variable_set *set1 ) 
{ 
  register unsigned int bucket1 ;
  register struct variable *v1 ;
  struct variable *next ;
  unsigned int bucket0 ;
  register struct variable *v0 ;
  register char *n ;
  int tmp ;

  {
#line 277
  bucket1 = 0U;
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! (bucket1 < set1->buckets)) {
#line 277
      goto while_break;
    }
#line 279
    v1 = *(set1->table + bucket1);
    {
#line 280
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 280
      if (! ((unsigned long )v1 != (unsigned long )((struct variable *)0))) {
#line 280
        goto while_break___0;
      }
#line 282
      next = v1->next;
#line 286
      if (set1->buckets >= set0->buckets) {
#line 287
        bucket0 = bucket1;
      } else {
#line 291
        bucket0 = 0U;
#line 292
        n = v1->name;
        {
#line 292
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 292
          if (! ((int )*n != 0)) {
#line 292
            goto while_break___1;
          }
#line 293
          bucket0 += (unsigned int )*n;
#line 293
          bucket0 = (bucket0 << 7) + (bucket0 >> 20);
#line 292
          n ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 295
      bucket0 %= set0->buckets;
#line 297
      v0 = *(set0->table + bucket0);
      {
#line 297
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 297
        if (! ((unsigned long )v0 != (unsigned long )((struct variable *)0))) {
#line 297
          goto while_break___2;
        }
#line 298
        if ((unsigned long )v0->name == (unsigned long )v1->name) {
#line 299
          goto while_break___2;
        } else
#line 298
        if ((int )*(v0->name) == (int )*(v1->name)) {
#line 298
          if ((int )*(v0->name) == 0) {
#line 299
            goto while_break___2;
          } else {
            {
#line 298
            tmp = strcmp((char const   *)(v0->name + 1), (char const   *)(v1->name + 1));
            }
#line 298
            if (! tmp) {
#line 299
              goto while_break___2;
            }
          }
        }
#line 297
        v0 = v0->next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 301
      if ((unsigned long )v0 == (unsigned long )((struct variable *)0)) {
#line 304
        v1->next = *(set0->table + bucket0);
#line 305
        *(set0->table + bucket0) = v1;
      } else {
        {
#line 311
        free((void *)v1->value);
#line 312
        free((void *)((char *)v1));
        }
      }
#line 315
      v1 = next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 277
    bucket1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return;
}
}
#line 322 "/home/khheo/testset/make-3.76.1/variable.c"
void merge_variable_set_lists(struct variable_set_list **setlist0 , struct variable_set_list *setlist1 ) 
{ 
  register struct variable_set_list *list0 ;
  struct variable_set_list *last0 ;
  struct variable_set_list *next ;

  {
#line 326
  list0 = *setlist0;
#line 327
  last0 = (struct variable_set_list *)0;
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 329
    if ((unsigned long )setlist1 != (unsigned long )((struct variable_set_list *)0)) {
#line 329
      if (! ((unsigned long )list0 != (unsigned long )((struct variable_set_list *)0))) {
#line 329
        goto while_break;
      }
    } else {
#line 329
      goto while_break;
    }
    {
#line 331
    next = setlist1;
#line 332
    setlist1 = setlist1->next;
#line 334
    merge_variable_sets(list0->set, next->set);
#line 336
    last0 = list0;
#line 337
    list0 = list0->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 340
  if ((unsigned long )setlist1 != (unsigned long )((struct variable_set_list *)0)) {
#line 342
    if ((unsigned long )last0 == (unsigned long )((struct variable_set_list *)0)) {
#line 343
      *setlist0 = setlist1;
    } else {
#line 345
      last0->next = setlist1;
    }
  }
#line 347
  return;
}
}
#line 358
char default_shell[8] ;
#line 352 "/home/khheo/testset/make-3.76.1/variable.c"
void define_automatic_variables(void) 
{ 
  register struct variable *v ;
  char buf___0[200] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;

  {
  {
#line 363
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%u",
          makelevel);
#line 364
  define_variable((char *)"MAKELEVEL", 9U, buf___0, (enum variable_origin )1, 0);
  }
#line 366
  if ((unsigned long )remote_description == (unsigned long )((char *)0)) {
#line 366
    tmp = "";
  } else
#line 366
  if ((int )*(remote_description + 0) == 0) {
#line 366
    tmp = "";
  } else {
#line 366
    tmp = (char const   *)remote_description;
  }
#line 366
  if ((unsigned long )remote_description == (unsigned long )((char *)0)) {
#line 366
    tmp___0 = "";
  } else
#line 366
  if ((int )*(remote_description + 0) == 0) {
#line 366
    tmp___0 = "";
  } else {
#line 366
    tmp___0 = "-";
  }
  {
#line 366
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%s%s%s",
          version_string, tmp___0, tmp);
#line 372
  define_variable((char *)"MAKE_VERSION", 12U, buf___0, (enum variable_origin )0,
                  0);
#line 400
  v = define_variable((char *)"SHELL", 5U, default_shell, (enum variable_origin )0,
                      0);
#line 401
  v->export = (enum __anonenum_export_56 )0;
  }
#line 408
  if ((int )*(v->value) == 0) {
    {
#line 410
    free((void *)v->value);
#line 411
    v->origin = (enum variable_origin )2;
#line 412
    tmp___1 = strlen((char const   *)(default_shell));
#line 412
    v->value = savestring(default_shell, tmp___1);
    }
  } else
#line 408
  if ((unsigned int )v->origin == 1U) {
    {
#line 410
    free((void *)v->value);
#line 411
    v->origin = (enum variable_origin )2;
#line 412
    tmp___1 = strlen((char const   *)(default_shell));
#line 412
    v->value = savestring(default_shell, tmp___1);
    }
  } else
#line 408
  if ((unsigned int )v->origin == 3U) {
    {
#line 410
    free((void *)v->value);
#line 411
    v->origin = (enum variable_origin )2;
#line 412
    tmp___1 = strlen((char const   *)(default_shell));
#line 412
    v->value = savestring(default_shell, tmp___1);
    }
  }
  {
#line 417
  v = define_variable((char *)"MAKEFILES", 9U, (char *)"", (enum variable_origin )0,
                      0);
#line 418
  v->export = (enum __anonenum_export_56 )2;
#line 423
  define_variable((char *)"@D", 2U, (char *)"$(patsubst %/,%,$(dir $@))", (enum variable_origin )6,
                  1);
#line 424
  define_variable((char *)"%D", 2U, (char *)"$(patsubst %/,%,$(dir $%))", (enum variable_origin )6,
                  1);
#line 425
  define_variable((char *)"*D", 2U, (char *)"$(patsubst %/,%,$(dir $*))", (enum variable_origin )6,
                  1);
#line 426
  define_variable((char *)"<D", 2U, (char *)"$(patsubst %/,%,$(dir $<))", (enum variable_origin )6,
                  1);
#line 427
  define_variable((char *)"?D", 2U, (char *)"$(patsubst %/,%,$(dir $?))", (enum variable_origin )6,
                  1);
#line 428
  define_variable((char *)"^D", 2U, (char *)"$(patsubst %/,%,$(dir $^))", (enum variable_origin )6,
                  1);
#line 429
  define_variable((char *)"+D", 2U, (char *)"$(patsubst %/,%,$(dir $+))", (enum variable_origin )6,
                  1);
#line 430
  define_variable((char *)"@F", 2U, (char *)"$(notdir $@)", (enum variable_origin )6,
                  1);
#line 431
  define_variable((char *)"%F", 2U, (char *)"$(notdir $%)", (enum variable_origin )6,
                  1);
#line 432
  define_variable((char *)"*F", 2U, (char *)"$(notdir $*)", (enum variable_origin )6,
                  1);
#line 433
  define_variable((char *)"<F", 2U, (char *)"$(notdir $<)", (enum variable_origin )6,
                  1);
#line 434
  define_variable((char *)"?F", 2U, (char *)"$(notdir $?)", (enum variable_origin )6,
                  1);
#line 435
  define_variable((char *)"^F", 2U, (char *)"$(notdir $^)", (enum variable_origin )6,
                  1);
#line 436
  define_variable((char *)"+F", 2U, (char *)"$(notdir $+)", (enum variable_origin )6,
                  1);
  }
#line 437
  return;
}
}
#line 445 "/home/khheo/testset/make-3.76.1/variable.c"
char **target_environment(struct file *file ) 
{ 
  struct variable_set_list *set_list ;
  register struct variable_set_list *s ;
  struct variable_bucket **table ;
  unsigned int buckets ;
  register unsigned int i ;
  register unsigned int nvariables ;
  char **result___0 ;
  unsigned int mklev_hash ;
  char *p ;
  char *tmp ;
  void *tmp___0 ;
  register struct variable_set *set ;
  register struct variable *v ;
  unsigned int j ;
  register struct variable_bucket *ov ;
  register char *p___0 ;
  int tmp___1 ;
  int tmp___2 ;
  register struct variable_bucket *entry ;
  void *tmp___3 ;
  char *tmp___4 ;
  register struct variable_bucket *b ;
  register struct variable *v___0 ;
  char *value ;
  char *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  char *tmp___8 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
#line 463
  if ((unsigned long )file == (unsigned long )((struct file *)0)) {
#line 464
    set_list = current_variable_set_list;
  } else {
#line 466
    set_list = file->variables;
  }
#line 469
  s = set_list;
#line 470
  buckets = (s->set)->buckets;
#line 471
  s = s->next;
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (! ((unsigned long )s != (unsigned long )((struct variable_set_list *)0))) {
#line 471
      goto while_break;
    }
#line 472
    if ((s->set)->buckets < buckets) {
#line 473
      buckets = (s->set)->buckets;
    }
#line 471
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  p = (char *)"MAKELEVEL";
#line 478
  mklev_hash = 0U;
  {
#line 479
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 479
    if (! ((int )*p != 0)) {
#line 479
      goto while_break___0;
    }
#line 480
    tmp = p;
#line 480
    p ++;
#line 480
    mklev_hash += (unsigned int )*tmp;
#line 480
    mklev_hash = (mklev_hash << 7) + (mklev_hash >> 20);
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 484
  tmp___0 = __builtin_alloca((unsigned long )buckets * sizeof(struct variable_bucket *));
#line 484
  table = (struct variable_bucket **)tmp___0;
#line 486
  memset((void *)((char *)table), 0, (unsigned long )buckets * sizeof(struct variable_bucket *));
#line 490
  nvariables = 0U;
#line 491
  s = set_list;
  }
  {
#line 491
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 491
    if (! ((unsigned long )s != (unsigned long )((struct variable_set_list *)0))) {
#line 491
      goto while_break___1;
    }
#line 493
    set = s->set;
#line 494
    i = 0U;
    {
#line 494
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 494
      if (! (i < set->buckets)) {
#line 494
        goto while_break___2;
      }
#line 497
      v = *(set->table + i);
      {
#line 497
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 497
        if (! ((unsigned long )v != (unsigned long )((struct variable *)0))) {
#line 497
          goto while_break___3;
        }
#line 499
        j = i % buckets;
#line 501
        p___0 = v->name;
#line 503
        if (i == mklev_hash % set->buckets) {
#line 503
          if ((unsigned long )v->name == (unsigned long )"MAKELEVEL") {
#line 507
            goto __Cont;
          } else
#line 503
          if ((int )*(v->name) == (int )*"MAKELEVEL") {
#line 503
            if ((int )*(v->name) == 0) {
#line 507
              goto __Cont;
            } else {
              {
#line 503
              tmp___1 = strcmp((char const   *)(v->name + 1), "MAKELEVEL" + 1);
              }
#line 503
              if (! tmp___1) {
#line 507
                goto __Cont;
              }
            }
          }
        }
        {
#line 511
        if ((unsigned int )v->export == 3U) {
#line 511
          goto case_3;
        }
#line 531
        if ((unsigned int )v->export == 0U) {
#line 531
          goto case_0;
        }
#line 534
        if ((unsigned int )v->export == 1U) {
#line 534
          goto case_1;
        }
#line 537
        if ((unsigned int )v->export == 2U) {
#line 537
          goto case_2;
        }
#line 509
        goto switch_break;
        case_3: /* CIL Label */ 
#line 512
        if ((unsigned int )v->origin == 0U) {
#line 514
          goto __Cont;
        } else
#line 512
        if ((unsigned int )v->origin == 6U) {
#line 514
          goto __Cont;
        }
#line 516
        if (! export_all_variables) {
#line 516
          if ((unsigned int )v->origin != 4U) {
#line 516
            if ((unsigned int )v->origin != 1U) {
#line 516
              if ((unsigned int )v->origin != 3U) {
#line 519
                goto __Cont;
              }
            }
          }
        }
#line 521
        if ((int )*p___0 != 95) {
#line 521
          if ((int )*p___0 < 65) {
#line 521
            goto _L;
          } else
#line 521
          if ((int )*p___0 > 90) {
            _L: /* CIL Label */ 
#line 521
            if ((int )*p___0 < 97) {
#line 523
              goto __Cont;
            } else
#line 521
            if ((int )*p___0 > 122) {
#line 523
              goto __Cont;
            }
          }
        }
#line 524
        p___0 ++;
        {
#line 524
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 524
          if (! ((int )*p___0 != 0)) {
#line 524
            goto while_break___4;
          }
#line 525
          if ((int )*p___0 != 95) {
#line 525
            if ((int )*p___0 < 97) {
#line 525
              goto _L___1;
            } else
#line 525
            if ((int )*p___0 > 122) {
              _L___1: /* CIL Label */ 
#line 525
              if ((int )*p___0 < 65) {
#line 525
                goto _L___0;
              } else
#line 525
              if ((int )*p___0 > 90) {
                _L___0: /* CIL Label */ 
#line 525
                if ((int )*p___0 < 48) {
#line 527
                  goto while_break___4;
                } else
#line 525
                if ((int )*p___0 > 57) {
#line 527
                  goto while_break___4;
                }
              }
            }
          }
#line 524
          p___0 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 528
        if ((int )*p___0 != 0) {
#line 529
          goto __Cont;
        }
        case_0: /* CIL Label */ 
#line 532
        goto switch_break;
        case_1: /* CIL Label */ 
#line 535
        goto __Cont;
        case_2: /* CIL Label */ 
#line 538
        if ((unsigned int )v->origin == 0U) {
#line 539
          goto __Cont;
        }
#line 540
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 543
        ov = *(table + j);
        {
#line 543
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 543
          if (! ((unsigned long )ov != (unsigned long )((struct variable_bucket *)0))) {
#line 543
            goto while_break___5;
          }
#line 544
          if ((unsigned long )v->name == (unsigned long )(ov->variable)->name) {
#line 545
            goto while_break___5;
          } else
#line 544
          if ((int )*(v->name) == (int )*((ov->variable)->name)) {
#line 544
            if ((int )*(v->name) == 0) {
#line 545
              goto while_break___5;
            } else {
              {
#line 544
              tmp___2 = strcmp((char const   *)(v->name + 1), (char const   *)((ov->variable)->name + 1));
              }
#line 544
              if (! tmp___2) {
#line 545
                goto while_break___5;
              }
            }
          }
#line 543
          ov = ov->next;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 546
        if ((unsigned long )ov == (unsigned long )((struct variable_bucket *)0)) {
          {
#line 549
          tmp___3 = __builtin_alloca(sizeof(struct variable_bucket ));
#line 549
          entry = (struct variable_bucket *)tmp___3;
#line 551
          entry->next = *(table + j);
#line 552
          entry->variable = v;
#line 553
          *(table + j) = entry;
#line 554
          nvariables ++;
          }
        }
        __Cont: /* CIL Label */ 
#line 497
        v = v->next;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 494
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 491
    s = s->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 560
  tmp___4 = xmalloc((unsigned long )(nvariables + 2U) * sizeof(char *));
#line 560
  result___0 = (char **)tmp___4;
#line 561
  nvariables = 0U;
#line 562
  i = 0U;
  }
  {
#line 562
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 562
    if (! (i < buckets)) {
#line 562
      goto while_break___6;
    }
#line 565
    b = *(table + i);
    {
#line 565
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 565
      if (! ((unsigned long )b != (unsigned long )((struct variable_bucket *)0))) {
#line 565
        goto while_break___7;
      }
#line 567
      v___0 = b->variable;
#line 571
      if (v___0->recursive) {
#line 571
        if ((unsigned int )v___0->origin != 1U) {
#line 571
          if ((unsigned int )v___0->origin != 3U) {
            {
#line 574
            tmp___5 = recursively_expand(v___0);
#line 574
            value = tmp___5;
#line 580
            tmp___6 = nvariables;
#line 580
            nvariables ++;
#line 580
            *(result___0 + tmp___6) = concat(v___0->name, "=", value);
#line 581
            free((void *)value);
            }
          } else {
            {
#line 592
            tmp___7 = nvariables;
#line 592
            nvariables ++;
#line 592
            *(result___0 + tmp___7) = concat(v___0->name, "=", v___0->value);
            }
          }
        } else {
          {
#line 592
          tmp___7 = nvariables;
#line 592
          nvariables ++;
#line 592
          *(result___0 + tmp___7) = concat(v___0->name, "=", v___0->value);
          }
        }
      } else {
        {
#line 592
        tmp___7 = nvariables;
#line 592
        nvariables ++;
#line 592
        *(result___0 + tmp___7) = concat(v___0->name, "=", v___0->value);
        }
      }
#line 565
      b = b->next;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 562
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 596
  tmp___8 = xmalloc(100);
#line 596
  *(result___0 + nvariables) = tmp___8;
#line 597
  sprintf((char */* __restrict  */)*(result___0 + nvariables), (char const   */* __restrict  */)"MAKELEVEL=%u",
          makelevel + 1U);
#line 598
  nvariables ++;
#line 598
  *(result___0 + nvariables) = (char *)0;
  }
#line 600
  return (result___0);
}
}
#line 619 "/home/khheo/testset/make-3.76.1/variable.c"
struct variable *try_variable_definition(char *filename , unsigned int lineno , char *line ,
                                         enum variable_origin origin ) 
{ 
  register int c ;
  register char *p ;
  register char *beg ;
  register char *end ;
  enum __anonenum_flavor_57 flavor ;
  char *name___0 ;
  char *expanded_name ;
  char *value ;
  struct variable *v ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char closeparen ;
  int count ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  unsigned int oldlen ;
  unsigned int newlen ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 627
  p = line;
#line 630
  flavor = (enum __anonenum_flavor_57 )0;
  {
#line 634
  while (1) {
    while_continue: /* CIL Label */ ;
#line 636
    tmp = p;
#line 636
    p ++;
#line 636
    c = (int )*tmp;
#line 637
    if (c == 0) {
#line 638
      return ((struct variable *)0);
    } else
#line 637
    if (c == 35) {
#line 638
      return ((struct variable *)0);
    }
#line 639
    if (c == 61) {
#line 641
      end = p - 1;
#line 642
      flavor = (enum __anonenum_flavor_57 )2;
#line 643
      goto while_break;
    } else
#line 645
    if (c == 58) {
#line 646
      if ((int )*p == 61) {
#line 648
        tmp___0 = p;
#line 648
        p ++;
#line 648
        end = tmp___0 - 1;
#line 649
        flavor = (enum __anonenum_flavor_57 )1;
#line 650
        goto while_break;
      } else {
#line 654
        return ((struct variable *)0);
      }
    } else
#line 655
    if (c == 43) {
#line 655
      if ((int )*p == 61) {
#line 657
        tmp___1 = p;
#line 657
        p ++;
#line 657
        end = tmp___1 - 1;
#line 658
        flavor = (enum __anonenum_flavor_57 )3;
#line 659
        goto while_break;
      } else {
#line 655
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 661
    if (c == 36) {
#line 667
      tmp___2 = p;
#line 667
      p ++;
#line 667
      c = (int )*tmp___2;
#line 668
      if (c == 40) {
#line 669
        closeparen = (char )')';
      } else
#line 670
      if (c == 123) {
#line 671
        closeparen = (char )'}';
      } else {
#line 673
        goto while_continue;
      }
#line 677
      count = 0;
      {
#line 678
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 678
        if (! ((int )*p != 0)) {
#line 678
          goto while_break___0;
        }
#line 680
        if ((int )*p == c) {
#line 681
          count ++;
        } else
#line 682
        if ((int )*p == (int )closeparen) {
#line 682
          count --;
#line 682
          if (count < 0) {
#line 684
            p ++;
#line 685
            goto while_break___0;
          }
        }
#line 678
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 691
  beg = next_token(line);
  }
  {
#line 692
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 692
    if ((unsigned long )end > (unsigned long )beg) {
      {
#line 692
      tmp___3 = __ctype_b_loc();
      }
#line 692
      if (! ((int const   )*(*tmp___3 + (int )*(end + -1)) & 1)) {
#line 692
        goto while_break___1;
      }
    } else {
#line 692
      goto while_break___1;
    }
#line 693
    end --;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 694
  p = next_token(p);
#line 697
  tmp___4 = __builtin_alloca((unsigned long )((end - beg) + 1L));
#line 697
  name___0 = (char *)tmp___4;
#line 698
  memmove((void *)name___0, (void const   *)beg, (size_t )(end - beg));
#line 699
  *(name___0 + (end - beg)) = (char )'\000';
#line 700
  expanded_name = allocated_variable_expand_for_file(name___0, (struct file *)0);
  }
#line 702
  if ((int )*(expanded_name + 0) == 0) {
#line 704
    if ((unsigned long )filename == (unsigned long )((char *)0)) {
      {
#line 705
      fatal("empty variable name");
      }
    } else {
      {
#line 707
      makefile_fatal(filename, lineno, "empty variable name");
      }
    }
  }
  {
#line 714
  if ((unsigned int )flavor == 0U) {
#line 714
    goto case_0;
  }
#line 718
  if ((unsigned int )flavor == 1U) {
#line 718
    goto case_1;
  }
#line 722
  if ((unsigned int )flavor == 2U) {
#line 722
    goto case_2;
  }
#line 727
  if ((unsigned int )flavor == 3U) {
#line 727
    goto case_3;
  }
#line 712
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 716
  abort();
  }
#line 717
  return ((struct variable *)0);
  case_1: /* CIL Label */ 
  {
#line 720
  value = variable_expand(p);
  }
#line 721
  goto switch_break;
  case_2: /* CIL Label */ 
#line 725
  value = p;
#line 726
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 730
  tmp___5 = strlen((char const   *)expanded_name);
#line 730
  v = lookup_variable(expanded_name, (unsigned int )tmp___5);
  }
#line 731
  if ((unsigned long )v == (unsigned long )((struct variable *)0)) {
#line 735
    value = p;
#line 736
    flavor = (enum __anonenum_flavor_57 )2;
  } else {
#line 744
    if (v->recursive) {
#line 747
      flavor = (enum __anonenum_flavor_57 )2;
    } else {
      {
#line 752
      p = variable_expand(p);
      }
    }
    {
#line 754
    tmp___6 = strlen((char const   *)v->value);
#line 754
    oldlen = (unsigned int )tmp___6;
#line 755
    tmp___7 = strlen((char const   *)p);
#line 755
    newlen = (unsigned int )tmp___7;
#line 756
    tmp___8 = __builtin_alloca((unsigned long )(((oldlen + 1U) + newlen) + 1U));
#line 756
    value = (char *)tmp___8;
#line 757
    memmove((void *)value, (void const   *)v->value, (size_t )oldlen);
#line 758
    *(value + oldlen) = (char )' ';
#line 759
    memmove((void *)(value + (oldlen + 1U)), (void const   *)p, (size_t )(newlen + 1U));
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 845
  tmp___9 = strlen((char const   *)expanded_name);
#line 845
  v = define_variable(expanded_name, (unsigned int )tmp___9, value, origin, (unsigned int )flavor == 2U);
#line 848
  free((void *)expanded_name);
  }
#line 850
  return (v);
}
}
#line 855 "/home/khheo/testset/make-3.76.1/variable.c"
static void print_variable(struct variable *v , char *prefix ) 
{ 
  char *origin ;
  register char *p ;
  char const   *tmp ;
  char *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 864
  if ((unsigned int )v->origin == 0U) {
#line 864
    goto case_0;
  }
#line 867
  if ((unsigned int )v->origin == 1U) {
#line 867
    goto case_1;
  }
#line 870
  if ((unsigned int )v->origin == 2U) {
#line 870
    goto case_2;
  }
#line 873
  if ((unsigned int )v->origin == 3U) {
#line 873
    goto case_3;
  }
#line 876
  if ((unsigned int )v->origin == 4U) {
#line 876
    goto case_4;
  }
#line 879
  if ((unsigned int )v->origin == 5U) {
#line 879
    goto case_5;
  }
#line 882
  if ((unsigned int )v->origin == 6U) {
#line 882
    goto case_6;
  }
#line 886
  goto switch_default;
  case_0: /* CIL Label */ 
#line 865
  origin = (char *)"default";
#line 866
  goto switch_break;
  case_1: /* CIL Label */ 
#line 868
  origin = (char *)"environment";
#line 869
  goto switch_break;
  case_2: /* CIL Label */ 
#line 871
  origin = (char *)"makefile";
#line 872
  goto switch_break;
  case_3: /* CIL Label */ 
#line 874
  origin = (char *)"environment under -e";
#line 875
  goto switch_break;
  case_4: /* CIL Label */ 
#line 877
  origin = (char *)"command line";
#line 878
  goto switch_break;
  case_5: /* CIL Label */ 
#line 880
  origin = (char *)"`override\' directive";
#line 881
  goto switch_break;
  case_6: /* CIL Label */ 
#line 883
  origin = (char *)"automatic";
#line 884
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 887
  abort();
  }
#line 888
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 890
  printf((char const   */* __restrict  */)"# %s\n", origin);
#line 892
  fputs((char const   */* __restrict  */)prefix, (FILE */* __restrict  */)stdout);
  }
#line 895
  if (v->recursive) {
    {
#line 895
    tmp___0 = strchr((char const   *)v->value, '\n');
    }
#line 895
    if ((unsigned long )tmp___0 != (unsigned long )((char *)0)) {
      {
#line 896
      printf((char const   */* __restrict  */)"define %s\n%s\nendef\n", v->name, v->value);
      }
    } else {
#line 895
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 901
    if (v->recursive) {
#line 901
      tmp = "";
    } else {
#line 901
      tmp = ":";
    }
    {
#line 901
    printf((char const   */* __restrict  */)"%s %s= ", v->name, tmp);
#line 904
    p = next_token(v->value);
    }
#line 905
    if ((unsigned long )p != (unsigned long )v->value) {
#line 905
      if ((int )*p == 0) {
        {
#line 907
        printf((char const   */* __restrict  */)"$(subst ,,%s)", v->value);
        }
      } else {
#line 905
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 908
    if (v->recursive) {
      {
#line 909
      fputs((char const   */* __restrict  */)v->value, (FILE */* __restrict  */)stdout);
      }
    } else {
#line 912
      p = v->value;
      {
#line 912
      while (1) {
        while_continue: /* CIL Label */ ;
#line 912
        if (! ((int )*p != 0)) {
#line 912
          goto while_break;
        }
#line 914
        if ((int )*p == 36) {
          {
#line 915
          putchar('$');
          }
        }
        {
#line 916
        putchar((int )*p);
#line 912
        p ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 918
    putchar('\n');
    }
  }
#line 920
  return;
}
}
#line 926 "/home/khheo/testset/make-3.76.1/variable.c"
static void print_variable_set(struct variable_set *set , char *prefix ) 
{ 
  register unsigned int i ;
  register unsigned int nvariables ;
  register unsigned int per_bucket ;
  register struct variable *v ;
  register unsigned int this_bucket ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 934
  nvariables = 0U;
#line 934
  per_bucket = nvariables;
#line 935
  i = 0U;
  {
#line 935
  while (1) {
    while_continue: /* CIL Label */ ;
#line 935
    if (! (i < set->buckets)) {
#line 935
      goto while_break;
    }
#line 937
    this_bucket = 0U;
#line 939
    v = *(set->table + i);
    {
#line 939
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 939
      if (! ((unsigned long )v != (unsigned long )((struct variable *)0))) {
#line 939
        goto while_break___0;
      }
      {
#line 941
      this_bucket ++;
#line 942
      print_variable(v, prefix);
#line 939
      v = v->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 945
    nvariables += this_bucket;
#line 946
    if (this_bucket > per_bucket) {
#line 947
      per_bucket = this_bucket;
    }
#line 935
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 950
  if (nvariables == 0U) {
    {
#line 951
    puts("# No variables.");
    }
  } else {
    {
#line 954
    printf((char const   */* __restrict  */)"# %u variables in %u hash buckets.\n",
           nvariables, set->buckets);
#line 957
    printf((char const   */* __restrict  */)"# average of %.1f variables per bucket, max %u in one bucket.\n",
           (double )nvariables / (double )set->buckets, per_bucket);
    }
  }
#line 971
  return;
}
}
#line 976 "/home/khheo/testset/make-3.76.1/variable.c"
void print_variable_data_base(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;

  {
  {
#line 979
  puts("\n# Variables\n");
#line 981
  print_variable_set(& global_variable_set, (char *)"");
  }
#line 982
  return;
}
}
#line 987 "/home/khheo/testset/make-3.76.1/variable.c"
void print_file_variables(struct file *file ) 
{ 
  char *__cil_tmp2 ;

  {
#line 991
  if ((unsigned long )file->variables != (unsigned long )((struct variable_set_list *)0)) {
    {
#line 992
    print_variable_set((file->variables)->set, (char *)"# ");
    }
  }
#line 993
  return;
}
}
#line 355 "/home/khheo/testset/make-3.76.1/make.h"
void define_default_variables(void) ;
#line 356
void set_default_suffixes(void) ;
#line 357
void install_default_suffix_rules(void) ;
#line 358
void install_default_implicit_rules(void) ;
#line 411
int no_builtin_rules_flag ;
#line 48 "/home/khheo/testset/make-3.76.1/rule.h"
struct file *suffix_file ;
#line 52
void install_pattern_rule(struct pspec *p , int terminal ) ;
#line 38 "/home/khheo/testset/make-3.76.1/default.c"
static char default_suffixes[131]  = 
#line 38 "/home/khheo/testset/make-3.76.1/default.c"
  {      (char )'.',      (char )'o',      (char )'u',      (char )'t', 
        (char )' ',      (char )'.',      (char )'a',      (char )' ', 
        (char )'.',      (char )'l',      (char )'n',      (char )' ', 
        (char )'.',      (char )'o',      (char )' ',      (char )'.', 
        (char )'c',      (char )' ',      (char )'.',      (char )'c', 
        (char )'c',      (char )' ',      (char )'.',      (char )'C', 
        (char )' ',      (char )'.',      (char )'p',      (char )' ', 
        (char )'.',      (char )'f',      (char )' ',      (char )'.', 
        (char )'F',      (char )' ',      (char )'.',      (char )'r', 
        (char )' ',      (char )'.',      (char )'y',      (char )' ', 
        (char )'.',      (char )'l',      (char )' ',      (char )'.', 
        (char )'s',      (char )' ',      (char )'.',      (char )'S', 
        (char )' ',      (char )'.',      (char )'m',      (char )'o', 
        (char )'d',      (char )' ',      (char )'.',      (char )'s', 
        (char )'y',      (char )'m',      (char )' ',      (char )'.', 
        (char )'d',      (char )'e',      (char )'f',      (char )' ', 
        (char )'.',      (char )'h',      (char )' ',      (char )'.', 
        (char )'i',      (char )'n',      (char )'f',      (char )'o', 
        (char )' ',      (char )'.',      (char )'d',      (char )'v', 
        (char )'i',      (char )' ',      (char )'.',      (char )'t', 
        (char )'e',      (char )'x',      (char )' ',      (char )'.', 
        (char )'t',      (char )'e',      (char )'x',      (char )'i', 
        (char )'n',      (char )'f',      (char )'o',      (char )' ', 
        (char )'.',      (char )'t',      (char )'e',      (char )'x', 
        (char )'i',      (char )' ',      (char )'.',      (char )'t', 
        (char )'x',      (char )'i',      (char )'n',      (char )'f', 
        (char )'o',      (char )' ',      (char )'.',      (char )'w', 
        (char )' ',      (char )'.',      (char )'c',      (char )'h', 
        (char )' ',      (char )'.',      (char )'w',      (char )'e', 
        (char )'b',      (char )' ',      (char )'.',      (char )'s', 
        (char )'h',      (char )' ',      (char )'.',      (char )'e', 
        (char )'l',      (char )'c',      (char )' ',      (char )'.', 
        (char )'e',      (char )'l',      (char )'\000'};
#line 49 "/home/khheo/testset/make-3.76.1/default.c"
static struct pspec default_pattern_rules[5]  = {      {(char *)"(%)", (char *)"%", (char *)"$(AR) $(ARFLAGS) $@ $<"}, 
        {(char *)"%.out", (char *)"%", (char *)"@rm -f $@ \n cp $< $@"}, 
        {(char *)"%.c", (char *)"%.w %.ch", (char *)"$(CTANGLE) $^ $@"}, 
        {(char *)"%.tex", (char *)"%.w %.ch", (char *)"$(CWEAVE) $^ $@"}, 
        {(char *)0, (char *)0, (char *)0}};
#line 73 "/home/khheo/testset/make-3.76.1/default.c"
static struct pspec default_terminal_rules[5]  = {      {(char *)"%", (char *)"%,v", (char *)"$(CHECKOUT,v)"}, 
        {(char *)"%", (char *)"RCS/%,v", (char *)"$(CHECKOUT,v)"}, 
        {(char *)"%", (char *)"s.%", (char *)"$(GET) $(GFLAGS) $(SCCS_OUTPUT_OPTION) $<"}, 
        {(char *)"%",
      (char *)"SCCS/s.%", (char *)"$(GET) $(GFLAGS) $(SCCS_OUTPUT_OPTION) $<"}, 
        {(char *)0, (char *)0, (char *)0}};
#line 104 "/home/khheo/testset/make-3.76.1/default.c"
static char *default_suffix_rules[88]  = 
#line 104
  {      (char *)".o",      (char *)"$(LINK.o) $^ $(LOADLIBES) $(LDLIBS) -o $@",      (char *)".s",      (char *)"$(LINK.s) $^ $(LOADLIBES) $(LDLIBS) -o $@", 
        (char *)".S",      (char *)"$(LINK.S) $^ $(LOADLIBES) $(LDLIBS) -o $@",      (char *)".c",      (char *)"$(LINK.c) $^ $(LOADLIBES) $(LDLIBS) -o $@", 
        (char *)".cc",      (char *)"$(LINK.cc) $^ $(LOADLIBES) $(LDLIBS) -o $@",      (char *)".C",      (char *)"$(LINK.C) $^ $(LOADLIBES) $(LDLIBS) -o $@", 
        (char *)".f",      (char *)"$(LINK.f) $^ $(LOADLIBES) $(LDLIBS) -o $@",      (char *)".p",      (char *)"$(LINK.p) $^ $(LOADLIBES) $(LDLIBS) -o $@", 
        (char *)".F",      (char *)"$(LINK.F) $^ $(LOADLIBES) $(LDLIBS) -o $@",      (char *)".r",      (char *)"$(LINK.r) $^ $(LOADLIBES) $(LDLIBS) -o $@", 
        (char *)".mod",      (char *)"$(COMPILE.mod) -o $@ -e $@ $^",      (char *)".def.sym",      (char *)"$(COMPILE.def) -o $@ $<", 
        (char *)".sh",      (char *)"cat $< >$@ \n chmod a+x $@",      (char *)".s.o",      (char *)"$(COMPILE.s) -o $@ $<", 
        (char *)".S.o",      (char *)"$(COMPILE.S) -o $@ $<",      (char *)".c.o",      (char *)"$(COMPILE.c) $< $(OUTPUT_OPTION)", 
        (char *)".cc.o",      (char *)"$(COMPILE.cc) $< $(OUTPUT_OPTION)",      (char *)".C.o",      (char *)"$(COMPILE.C) $< $(OUTPUT_OPTION)", 
        (char *)".f.o",      (char *)"$(COMPILE.f) $< $(OUTPUT_OPTION)",      (char *)".p.o",      (char *)"$(COMPILE.p) $< $(OUTPUT_OPTION)", 
        (char *)".F.o",      (char *)"$(COMPILE.F) $< $(OUTPUT_OPTION)",      (char *)".r.o",      (char *)"$(COMPILE.r) $< $(OUTPUT_OPTION)", 
        (char *)".mod.o",      (char *)"$(COMPILE.mod) -o $@ $<",      (char *)".c.ln",      (char *)"$(LINT.c) -C$* $<", 
        (char *)".y.ln",      (char *)"$(YACC.y) $< \n $(LINT.c) -C$* y.tab.c \n $(RM) y.tab.c",      (char *)".l.ln",      (char *)"@$(RM) $*.c\n $(LEX.l) $< > $*.c\n$(LINT.c) -i $*.c -o $@\n $(RM) $*.c", 
        (char *)".y.c",      (char *)"$(YACC.y) $< \n mv -f y.tab.c $@",      (char *)".l.c",      (char *)"@$(RM) $@ \n $(LEX.l) $< > $@", 
        (char *)".F.f",      (char *)"$(PREPROCESS.F) $< $(OUTPUT_OPTION)",      (char *)".r.f",      (char *)"$(PREPROCESS.r) $< $(OUTPUT_OPTION)", 
        (char *)".l.r",      (char *)"$(LEX.l) $< > $@ \n mv -f lex.yy.r $@",      (char *)".S.s",      (char *)"$(PREPROCESS.S) $< > $@", 
        (char *)".texinfo.info",      (char *)"$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@",      (char *)".texi.info",      (char *)"$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@", 
        (char *)".txinfo.info",      (char *)"$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@",      (char *)".tex.dvi",      (char *)"$(TEX) $<", 
        (char *)".texinfo.dvi",      (char *)"$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<",      (char *)".texi.dvi",      (char *)"$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<", 
        (char *)".txinfo.dvi",      (char *)"$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<",      (char *)".w.c",      (char *)"$(CTANGLE) $< - $@", 
        (char *)".web.p",      (char *)"$(TANGLE) $<",      (char *)".w.tex",      (char *)"$(CWEAVE) $< - $@", 
        (char *)".web.tex",      (char *)"$(WEAVE) $<",      (char *)0,      (char *)0};
#line 269 "/home/khheo/testset/make-3.76.1/default.c"
static char *default_variables[110]  = 
#line 269
  {      (char *)"AR",      (char *)"ar",      (char *)"ARFLAGS",      (char *)"rv", 
        (char *)"AS",      (char *)"as",      (char *)"CC",      (char *)"cc", 
        (char *)"CXX",      (char *)"g++",      (char *)"CHECKOUT,v",      (char *)"+$(patsubst $@-noexist,$(CO) $(COFLAGS) $< $@,\t\t $(filter-out $@,$(firstword $(wildcard $@) $@-noexist)))", 
        (char *)"CO",      (char *)"co",      (char *)"CPP",      (char *)"$(CC) -E", 
        (char *)"FC",      (char *)"f77",      (char *)"F77",      (char *)"$(FC)", 
        (char *)"F77FLAGS",      (char *)"$(FFLAGS)",      (char *)"GET",      (char *)"get", 
        (char *)"LD",      (char *)"ld",      (char *)"LEX",      (char *)"lex", 
        (char *)"LINT",      (char *)"lint",      (char *)"M2C",      (char *)"m2c", 
        (char *)"PC",      (char *)"pc",      (char *)"YACC",      (char *)"yacc", 
        (char *)"MAKEINFO",      (char *)"makeinfo",      (char *)"TEX",      (char *)"tex", 
        (char *)"TEXI2DVI",      (char *)"texi2dvi",      (char *)"WEAVE",      (char *)"weave", 
        (char *)"CWEAVE",      (char *)"cweave",      (char *)"TANGLE",      (char *)"tangle", 
        (char *)"CTANGLE",      (char *)"ctangle",      (char *)"RM",      (char *)"rm -f", 
        (char *)"LINK.o",      (char *)"$(CC) $(LDFLAGS) $(TARGET_ARCH)",      (char *)"COMPILE.c",      (char *)"$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c", 
        (char *)"LINK.c",      (char *)"$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",      (char *)"COMPILE.cc",      (char *)"$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c", 
        (char *)"COMPILE.C",      (char *)"$(COMPILE.cc)",      (char *)"LINK.cc",      (char *)"$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)", 
        (char *)"LINK.C",      (char *)"$(LINK.cc)",      (char *)"YACC.y",      (char *)"$(YACC) $(YFLAGS)", 
        (char *)"LEX.l",      (char *)"$(LEX) $(LFLAGS) -t",      (char *)"COMPILE.f",      (char *)"$(FC) $(FFLAGS) $(TARGET_ARCH) -c", 
        (char *)"LINK.f",      (char *)"$(FC) $(FFLAGS) $(LDFLAGS) $(TARGET_ARCH)",      (char *)"COMPILE.F",      (char *)"$(FC) $(FFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c", 
        (char *)"LINK.F",      (char *)"$(FC) $(FFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",      (char *)"COMPILE.r",      (char *)"$(FC) $(FFLAGS) $(RFLAGS) $(TARGET_ARCH) -c", 
        (char *)"LINK.r",      (char *)"$(FC) $(FFLAGS) $(RFLAGS) $(LDFLAGS) $(TARGET_ARCH)",      (char *)"COMPILE.def",      (char *)"$(M2C) $(M2FLAGS) $(DEFFLAGS) $(TARGET_ARCH)", 
        (char *)"COMPILE.mod",      (char *)"$(M2C) $(M2FLAGS) $(MODFLAGS) $(TARGET_ARCH)",      (char *)"COMPILE.p",      (char *)"$(PC) $(PFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c", 
        (char *)"LINK.p",      (char *)"$(PC) $(PFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",      (char *)"LINK.s",      (char *)"$(CC) $(ASFLAGS) $(LDFLAGS) $(TARGET_MACH)", 
        (char *)"COMPILE.s",      (char *)"$(AS) $(ASFLAGS) $(TARGET_MACH)",      (char *)"LINK.S",      (char *)"$(CC) $(ASFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_MACH)", 
        (char *)"COMPILE.S",      (char *)"$(CC) $(ASFLAGS) $(CPPFLAGS) $(TARGET_MACH) -c",      (char *)"PREPROCESS.S",      (char *)"$(CC) -E $(CPPFLAGS)", 
        (char *)"PREPROCESS.F",      (char *)"$(FC) $(FFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -F",      (char *)"PREPROCESS.r",      (char *)"$(FC) $(FFLAGS) $(RFLAGS) $(TARGET_ARCH) -F", 
        (char *)"LINT.c",      (char *)"$(LINT) $(LINTFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",      (char *)"OUTPUT_OPTION",      (char *)"-o $@", 
        (char *)0,      (char *)0};
#line 426 "/home/khheo/testset/make-3.76.1/default.c"
void set_default_suffixes(void) 
{ 
  char *p ;
  struct nameseq *tmp ;
  struct nameseq *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 429
  suffix_file = enter_file(".SUFFIXES");
  }
#line 431
  if (no_builtin_rules_flag) {
    {
#line 432
    define_variable((char *)"SUFFIXES", 8U, (char *)"", (enum variable_origin )0,
                    0);
    }
  } else {
    {
#line 435
    p = default_suffixes;
#line 436
    tmp = parse_file_seq(& p, '\000', (unsigned int )sizeof(struct dep ), 1);
#line 436
    tmp___0 = multi_glob(tmp, (unsigned int )sizeof(struct dep ));
#line 436
    suffix_file->deps = (struct dep *)tmp___0;
#line 439
    define_variable((char *)"SUFFIXES", 8U, default_suffixes, (enum variable_origin )0,
                    0);
    }
  }
#line 441
  return;
}
}
#line 448 "/home/khheo/testset/make-3.76.1/default.c"
void install_default_suffix_rules(void) 
{ 
  register char **s ;
  register struct file *f ;
  struct file *tmp ;
  char *tmp___0 ;

  {
#line 453
  if (no_builtin_rules_flag) {
#line 454
    return;
  }
#line 456
  s = default_suffix_rules;
  {
#line 456
  while (1) {
    while_continue: /* CIL Label */ ;
#line 456
    if (! ((unsigned long )*s != (unsigned long )((char *)0))) {
#line 456
      goto while_break;
    }
    {
#line 458
    tmp = enter_file(*(s + 0));
#line 458
    f = tmp;
    }
#line 460
    if ((unsigned long )f->cmds == (unsigned long )((struct commands *)0)) {
      {
#line 462
      tmp___0 = xmalloc(sizeof(struct commands ));
#line 462
      f->cmds = (struct commands *)tmp___0;
#line 463
      (f->cmds)->filename = (char *)0;
#line 464
      (f->cmds)->commands = *(s + 1);
#line 465
      (f->cmds)->command_lines = (char **)0;
      }
    }
#line 456
    s += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 468
  return;
}
}
#line 473 "/home/khheo/testset/make-3.76.1/default.c"
void install_default_implicit_rules(void) 
{ 
  register struct pspec *p ;

  {
#line 478
  if (no_builtin_rules_flag) {
#line 479
    return;
  }
#line 481
  p = default_pattern_rules;
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 481
    if (! ((unsigned long )p->target != (unsigned long )((char *)0))) {
#line 481
      goto while_break;
    }
    {
#line 482
    install_pattern_rule(p, 0);
#line 481
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 484
  p = default_terminal_rules;
  {
#line 484
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 484
    if (! ((unsigned long )p->target != (unsigned long )((char *)0))) {
#line 484
      goto while_break___0;
    }
    {
#line 485
    install_pattern_rule(p, 1);
#line 484
    p ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 486
  return;
}
}
#line 488 "/home/khheo/testset/make-3.76.1/default.c"
void define_default_variables(void) 
{ 
  register char **s ;
  size_t tmp ;

  {
#line 493
  s = default_variables;
  {
#line 493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 493
    if (! ((unsigned long )*s != (unsigned long )((char *)0))) {
#line 493
      goto while_break;
    }
    {
#line 494
    tmp = strlen((char const   *)*(s + 0));
#line 494
    define_variable(*(s + 0), (unsigned int )tmp, *(s + 1), (enum variable_origin )0,
                    1);
#line 493
    s += 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 495
  return;
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 336 "/home/khheo/testset/make-3.76.1/make.h"
void print_spaces(unsigned int n ) ;
#line 351
int file_impossible_p(char *filename ) ;
#line 352
void file_impossible(char *filename ) ;
#line 410
int debug_flag ;
#line 40 "/home/khheo/testset/make-3.76.1/rule.h"
struct rule *pattern_rules ;
#line 42
unsigned int num_pattern_rules ;
#line 44
unsigned int max_pattern_deps ;
#line 45
unsigned int max_pattern_targets ;
#line 46
unsigned int max_pattern_dep_length ;
#line 87 "/home/khheo/testset/make-3.76.1/filedef.h"
unsigned int num_intermediates ;
#line 24 "/home/khheo/testset/make-3.76.1/implicit.c"
static int pattern_search(struct file *file , int archive , unsigned int depth , unsigned int recursions ) ;
#line 33 "/home/khheo/testset/make-3.76.1/implicit.c"
int try_implicit_rule(struct file *file , unsigned int depth ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (debug_flag) {
      {
#line 38
      print_spaces(depth);
#line 38
      printf((char const   */* __restrict  */)"Looking for an implicit rule for `%s\'.\n",
             file->name);
#line 38
      fflush(stdout);
      }
    }
#line 38
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 45
  tmp = pattern_search(file, 0, depth, 0U);
  }
#line 45
  if (tmp) {
#line 46
    return (1);
  }
  {
#line 51
  tmp___1 = ar_name(file->name);
  }
#line 51
  if (tmp___1) {
    {
#line 53
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 53
      if (debug_flag) {
        {
#line 53
        print_spaces(depth);
#line 53
        printf((char const   */* __restrict  */)"Looking for archive-member implicit rule for `%s\'.\n",
               file->name);
#line 53
        fflush(stdout);
        }
      }
#line 53
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 54
    tmp___0 = pattern_search(file, 1, depth, 0U);
    }
#line 54
    if (tmp___0) {
#line 55
      return (1);
    }
  }
#line 59
  return (0);
}
}
#line 82 "/home/khheo/testset/make-3.76.1/implicit.c"
static int pattern_search(struct file *file , int archive , unsigned int depth , unsigned int recursions ) 
{ 
  char *filename ;
  char *tmp ;
  char *tmp___0 ;
  unsigned int namelen ;
  size_t tmp___1 ;
  char *lastslash ;
  struct file *intermediate_file ;
  struct file **intermediate_files ;
  void *tmp___2 ;
  char **intermediate_patterns ;
  void *tmp___3 ;
  char **found_files ;
  void *tmp___4 ;
  unsigned int deps_found ;
  register char *depname ;
  void *tmp___5 ;
  register char *stem ;
  register unsigned int stemlen ;
  struct rule **tryrules ;
  void *tmp___6 ;
  unsigned int nrules ;
  unsigned int *matches ;
  void *tmp___7 ;
  char *checked_lastslash ;
  void *tmp___8 ;
  unsigned int foundrule ;
  int intermed_ok ;
  int specific_rule_matched ;
  register unsigned int i ;
  register struct rule *rule ;
  register struct dep *dep ;
  char *p ;
  char *vp ;
  int tmp___9 ;
  char *target ;
  char *suffix ;
  int check_lastslash ;
  char *tmp___10 ;
  int tmp___11 ;
  unsigned int difference ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  register unsigned int j ;
  int check_lastslash___0 ;
  char *tmp___15 ;
  register unsigned int i___0 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  int tmp___20 ;
  char const   *tmp___21 ;
  unsigned int tmp___22 ;
  size_t tmp___23 ;
  struct file *tmp___24 ;
  int tmp___25 ;
  unsigned int tmp___26 ;
  int tmp___27 ;
  void *tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;
  int tmp___31 ;
  register struct file *f ;
  size_t tmp___32 ;
  unsigned int tmp___33 ;
  register char *s ;
  struct file *imf ;
  register struct file *f___0 ;
  struct file *tmp___34 ;
  char *tmp___35 ;
  unsigned int tmp___36 ;
  char *tmp___37 ;
  struct dep *new ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;

  {
#line 90
  if (archive) {
    {
#line 90
    tmp = strchr((char const   *)file->name, '(');
#line 90
    tmp___0 = tmp;
    }
  } else {
#line 90
    tmp___0 = file->name;
  }
  {
#line 90
  filename = tmp___0;
#line 93
  tmp___1 = strlen((char const   *)filename);
#line 93
  namelen = (unsigned int )tmp___1;
#line 101
  intermediate_file = (struct file *)0;
#line 104
  tmp___2 = __builtin_alloca((unsigned long )max_pattern_deps * sizeof(struct file *));
#line 104
  intermediate_files = (struct file **)tmp___2;
#line 108
  tmp___3 = __builtin_alloca((unsigned long )max_pattern_deps * sizeof(char *));
#line 108
  intermediate_patterns = (char **)tmp___3;
#line 112
  tmp___4 = __builtin_alloca((unsigned long )max_pattern_deps * sizeof(char *));
#line 112
  found_files = (char **)tmp___4;
#line 117
  tmp___5 = __builtin_alloca((unsigned long )(namelen + max_pattern_dep_length));
#line 117
  depname = (char *)tmp___5;
#line 124
  tmp___6 = __builtin_alloca((unsigned long )(num_pattern_rules * max_pattern_targets) * sizeof(struct rule *));
#line 124
  tryrules = (struct rule **)tmp___6;
#line 133
  tmp___7 = __builtin_alloca((unsigned long )num_pattern_rules * sizeof(unsigned int ));
#line 133
  matches = (unsigned int *)tmp___7;
#line 138
  tmp___8 = __builtin_alloca((unsigned long )num_pattern_rules * sizeof(char ));
#line 138
  checked_lastslash = (char *)tmp___8;
#line 149
  specific_rule_matched = 0;
  }
#line 158
  if (archive) {
#line 159
    lastslash = (char *)0;
  } else {
    {
#line 158
    tmp___9 = ar_name(filename);
    }
#line 158
    if (tmp___9) {
#line 159
      lastslash = (char *)0;
    } else {
      {
#line 169
      lastslash = strrchr((char const   *)filename, '/');
      }
#line 182
      if ((unsigned long )lastslash != (unsigned long )((char *)0)) {
#line 182
        if ((int )*(lastslash + 1) == 0) {
#line 183
          lastslash = (char *)0;
        }
      }
    }
  }
#line 189
  nrules = 0U;
#line 190
  rule = pattern_rules;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! ((unsigned long )rule != (unsigned long )((struct rule *)0))) {
#line 190
      goto while_break;
    }
#line 194
    if ((unsigned long )rule->deps != (unsigned long )((struct dep *)0)) {
#line 194
      if ((unsigned long )rule->cmds == (unsigned long )((struct commands *)0)) {
#line 195
        goto __Cont;
      }
    }
#line 199
    if (rule->in_use) {
      {
#line 201
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 201
        if (debug_flag) {
          {
#line 201
          print_spaces(depth);
#line 201
          printf((char const   */* __restrict  */)"Avoiding implicit rule recursion.%s%s\n",
                 "", "");
#line 201
          fflush(stdout);
          }
        }
#line 201
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 202
      goto __Cont;
    }
#line 205
    i = 0U;
    {
#line 205
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 205
      if (! ((unsigned long )*(rule->targets + i) != (unsigned long )((char *)0))) {
#line 205
        goto while_break___1;
      }
#line 207
      target = *(rule->targets + i);
#line 208
      suffix = *(rule->suffixes + i);
#line 214
      if (recursions > 0U) {
#line 214
        if ((int )*(target + 1) == 0) {
#line 214
          if (! rule->terminal) {
#line 215
            goto __Cont___0;
          }
        }
      }
#line 217
      if (*(rule->lens + i) > namelen) {
#line 219
        goto __Cont___0;
      }
#line 223
      stem = filename + ((suffix - target) - 1L);
#line 224
      stemlen = (namelen - *(rule->lens + i)) + 1U;
#line 232
      if ((unsigned long )lastslash != (unsigned long )((char *)0)) {
        {
#line 232
        tmp___10 = strchr((char const   *)target, '/');
        }
#line 232
        if ((unsigned long )tmp___10 == (unsigned long )((char *)0)) {
#line 232
          tmp___11 = 1;
        } else {
#line 232
          tmp___11 = 0;
        }
      } else {
#line 232
        tmp___11 = 0;
      }
#line 232
      check_lastslash = tmp___11;
#line 234
      if (check_lastslash) {
#line 238
        difference = (unsigned int )((lastslash - filename) + 1L);
#line 239
        if (difference > stemlen) {
#line 240
          goto __Cont___0;
        }
#line 241
        stemlen -= difference;
#line 242
        stem += difference;
      }
#line 246
      if (check_lastslash) {
#line 248
        if ((unsigned long )stem > (unsigned long )(lastslash + 1)) {
          {
#line 248
          tmp___12 = strncmp((char const   *)target, (char const   *)(lastslash + 1),
                             (size_t )((stem - lastslash) - 1L));
          }
#line 248
          if (tmp___12) {
#line 250
            goto __Cont___0;
          }
        }
      } else
#line 252
      if ((unsigned long )stem > (unsigned long )filename) {
        {
#line 252
        tmp___13 = strncmp((char const   *)target, (char const   *)filename, (size_t )(stem - filename));
        }
#line 252
        if (tmp___13) {
#line 254
          goto __Cont___0;
        }
      }
#line 261
      if ((int )*suffix != (int )*(stem + stemlen)) {
#line 263
        goto __Cont___0;
      } else
#line 261
      if ((int )*suffix != 0) {
#line 261
        if (! ((unsigned long )(suffix + 1) == (unsigned long )(stem + (stemlen + 1U)))) {
#line 261
          if ((int )*(suffix + 1) == (int )*(stem + (stemlen + 1U))) {
#line 261
            if (! ((int )*(suffix + 1) == 0)) {
              {
#line 261
              tmp___14 = strcmp((char const   *)((suffix + 1) + 1), (char const   *)((stem + (stemlen + 1U)) + 1));
              }
#line 261
              if (tmp___14) {
#line 263
                goto __Cont___0;
              }
            }
          } else {
#line 263
            goto __Cont___0;
          }
        }
      }
#line 266
      if ((int )*(target + 1) != 0) {
#line 267
        specific_rule_matched = 1;
      }
#line 271
      if ((unsigned long )rule->deps == (unsigned long )((struct dep *)0)) {
#line 271
        if ((unsigned long )rule->cmds == (unsigned long )((struct commands *)0)) {
#line 272
          goto __Cont___0;
        }
      }
#line 277
      *(tryrules + nrules) = rule;
#line 278
      *(matches + nrules) = i;
#line 279
      *(checked_lastslash + nrules) = (char )check_lastslash;
#line 280
      nrules ++;
      __Cont___0: /* CIL Label */ 
#line 205
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 190
    rule = rule->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  if (specific_rule_matched) {
#line 287
    i = 0U;
    {
#line 287
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 287
      if (! (i < nrules)) {
#line 287
        goto while_break___2;
      }
#line 288
      if (! (*(tryrules + i))->terminal) {
#line 291
        j = 0U;
        {
#line 291
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 291
          if (! ((unsigned long )*((*(tryrules + i))->targets + j) != (unsigned long )((char *)0))) {
#line 291
            goto while_break___3;
          }
#line 292
          if ((int )*(*((*(tryrules + i))->targets + j) + 1) == 0) {
#line 293
            goto while_break___3;
          }
#line 291
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 294
        if ((unsigned long )*((*(tryrules + i))->targets + j) != (unsigned long )((char *)0)) {
#line 295
          *(tryrules + i) = (struct rule *)0;
        }
      }
#line 287
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 299
  intermed_ok = 0;
  {
#line 299
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 299
    if (! (intermed_ok == ! (! intermed_ok))) {
#line 299
      goto while_break___4;
    }
#line 305
    i = 0U;
    {
#line 305
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 305
      if (! (i < nrules)) {
#line 305
        goto while_break___5;
      }
#line 309
      rule = *(tryrules + i);
#line 313
      if ((unsigned long )rule == (unsigned long )((struct rule *)0)) {
#line 314
        goto __Cont___1;
      }
#line 318
      if (intermed_ok) {
#line 318
        if (rule->terminal) {
#line 319
          goto __Cont___1;
        }
      }
#line 323
      rule->in_use = (char)1;
#line 327
      stem = (filename + (*(rule->suffixes + *(matches + i)) - *(rule->targets + *(matches + i)))) - 1;
#line 329
      stemlen = (namelen - *(rule->lens + *(matches + i))) + 1U;
#line 330
      check_lastslash___0 = (int )*(checked_lastslash + i);
#line 331
      if (check_lastslash___0) {
#line 333
        stem += (lastslash - filename) + 1L;
#line 334
        stemlen = (unsigned int )((long )stemlen - ((lastslash - filename) + 1L));
      }
      {
#line 337
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 337
        if (debug_flag) {
          {
#line 337
          print_spaces(depth);
#line 337
          printf((char const   */* __restrict  */)"Trying pattern rule with stem `%.*s\'.\n",
                 (int )stemlen, stem);
#line 337
          fflush(stdout);
          }
        }
#line 337
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 342
      deps_found = 0U;
#line 343
      dep = rule->deps;
      {
#line 343
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 343
        if (! ((unsigned long )dep != (unsigned long )((struct dep *)0))) {
#line 343
          goto while_break___7;
        }
#line 346
        if ((unsigned long )dep->name == (unsigned long )((char *)0)) {
#line 346
          tmp___15 = (dep->file)->name;
        } else {
#line 346
          tmp___15 = dep->name;
        }
        {
#line 346
        p = strchr((char const   *)tmp___15, '%');
        }
#line 347
        if ((unsigned long )p != (unsigned long )((char *)0)) {
#line 350
          if (check_lastslash___0) {
            {
#line 353
            i___0 = (unsigned int )((lastslash - filename) + 1L);
#line 354
            memmove((void *)depname, (void const   *)filename, (size_t )i___0);
            }
          } else {
#line 357
            i___0 = 0U;
          }
#line 358
          if ((unsigned long )dep->name == (unsigned long )((char *)0)) {
#line 358
            tmp___16 = (dep->file)->name;
          } else {
#line 358
            tmp___16 = dep->name;
          }
#line 358
          if ((unsigned long )dep->name == (unsigned long )((char *)0)) {
#line 358
            tmp___17 = (dep->file)->name;
          } else {
#line 358
            tmp___17 = dep->name;
          }
          {
#line 358
          memmove((void *)(depname + i___0), (void const   *)tmp___17, (size_t )(p - tmp___16));
          }
#line 359
          if ((unsigned long )dep->name == (unsigned long )((char *)0)) {
#line 359
            tmp___18 = (dep->file)->name;
          } else {
#line 359
            tmp___18 = dep->name;
          }
          {
#line 359
          i___0 = (unsigned int )((long )i___0 + (p - tmp___18));
#line 360
          memmove((void *)(depname + i___0), (void const   *)stem, (size_t )stemlen);
#line 361
          i___0 += stemlen;
#line 362
          strcpy((char */* __restrict  */)(depname + i___0), (char const   */* __restrict  */)(p + 1));
#line 363
          p = depname;
          }
        } else
#line 366
        if ((unsigned long )dep->name == (unsigned long )((char *)0)) {
#line 366
          p = (dep->file)->name;
        } else {
#line 366
          p = dep->name;
        }
        {
#line 370
        tmp___20 = file_impossible_p(p);
        }
#line 370
        if (tmp___20) {
          {
#line 376
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 376
            if (debug_flag) {
              {
#line 376
              print_spaces(depth);
              }
#line 376
              if ((unsigned long )p == (unsigned long )depname) {
#line 376
                tmp___19 = "implicit";
              } else {
#line 376
                tmp___19 = "rule";
              }
              {
#line 376
              printf((char const   */* __restrict  */)"Rejecting impossible %s dependency `%s\'.\n",
                     tmp___19, p);
#line 376
              fflush(stdout);
              }
            }
#line 376
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 378
          *(tryrules + i) = (struct rule *)0;
#line 379
          goto while_break___7;
        }
#line 382
        *(intermediate_files + deps_found) = (struct file *)0;
        {
#line 384
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 384
          if (debug_flag) {
            {
#line 384
            print_spaces(depth);
            }
#line 384
            if ((unsigned long )p == (unsigned long )depname) {
#line 384
              tmp___21 = "implicit";
            } else {
#line 384
              tmp___21 = "rule";
            }
            {
#line 384
            printf((char const   */* __restrict  */)"Trying %s dependency `%s\'.\n",
                   tmp___21, p);
#line 384
            fflush(stdout);
            }
          }
#line 384
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 394
        if (! dep->changed) {
#line 394
          goto _L;
        } else
#line 394
        if (check_lastslash___0) {
          _L: /* CIL Label */ 
          {
#line 394
          tmp___24 = lookup_file(p);
          }
#line 394
          if ((unsigned long )tmp___24 != (unsigned long )((struct file *)0)) {
            {
#line 397
            tmp___22 = deps_found;
#line 397
            deps_found ++;
#line 397
            tmp___23 = strlen((char const   *)p);
#line 397
            *(found_files + tmp___22) = savestring(p, tmp___23);
            }
#line 398
            goto __Cont___2;
          } else {
            {
#line 394
            tmp___25 = file_exists_p(p);
            }
#line 394
            if (tmp___25) {
              {
#line 397
              tmp___22 = deps_found;
#line 397
              deps_found ++;
#line 397
              tmp___23 = strlen((char const   *)p);
#line 397
              *(found_files + tmp___22) = savestring(p, tmp___23);
              }
#line 398
              goto __Cont___2;
            }
          }
        }
        {
#line 402
        vp = p;
#line 403
        tmp___27 = vpath_search(& vp, (time_t *)0);
        }
#line 403
        if (tmp___27) {
          {
#line 405
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 405
            if (debug_flag) {
              {
#line 405
              print_spaces(depth);
#line 405
              printf((char const   */* __restrict  */)"Found dependency `%s\' as VPATH `%s\'\n",
                     p, vp);
#line 405
              fflush(stdout);
              }
            }
#line 405
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
          {
#line 406
          strcpy((char */* __restrict  */)vp, (char const   */* __restrict  */)p);
#line 407
          tmp___26 = deps_found;
#line 407
          deps_found ++;
#line 407
          *(found_files + tmp___26) = vp;
          }
#line 408
          goto __Cont___2;
        }
#line 415
        if (intermed_ok) {
#line 417
          if ((unsigned long )intermediate_file == (unsigned long )((struct file *)0)) {
            {
#line 418
            tmp___28 = __builtin_alloca(sizeof(struct file ));
#line 418
            intermediate_file = (struct file *)tmp___28;
            }
          }
          {
#line 421
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 421
            if (debug_flag) {
              {
#line 421
              print_spaces(depth);
#line 421
              printf((char const   */* __restrict  */)"Looking for a rule with %s file `%s\'.\n",
                     "intermediate", p);
#line 421
              fflush(stdout);
              }
            }
#line 421
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
          {
#line 424
          memset((void *)((char *)intermediate_file), 0, sizeof(struct file ));
#line 425
          intermediate_file->name = p;
#line 426
          tmp___31 = pattern_search(intermediate_file, 0, depth + 1U, recursions + 1U);
          }
#line 426
          if (tmp___31) {
            {
#line 429
            tmp___29 = strlen((char const   *)p);
#line 429
            p = savestring(p, tmp___29);
#line 430
            *(intermediate_patterns + deps_found) = intermediate_file->name;
#line 432
            intermediate_file->name = p;
#line 433
            *(intermediate_files + deps_found) = intermediate_file;
#line 434
            intermediate_file = (struct file *)0;
#line 438
            tmp___30 = strlen((char const   *)p);
#line 438
            *(found_files + deps_found) = savestring(p, tmp___30);
#line 439
            deps_found ++;
            }
#line 440
            goto __Cont___2;
          }
          {
#line 446
          file_impossible(p);
          }
        }
#line 451
        goto while_break___7;
        __Cont___2: /* CIL Label */ 
#line 343
        dep = dep->next;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 455
      rule->in_use = (char)0;
#line 457
      if ((unsigned long )dep != (unsigned long )((struct dep *)0)) {
        {
#line 462
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 462
          tmp___33 = deps_found;
#line 462
          deps_found --;
#line 462
          if (! (tmp___33 > 0U)) {
#line 462
            goto while_break___12;
          }
          {
#line 464
          f = *(intermediate_files + deps_found);
#line 465
          free((void *)*(found_files + deps_found));
          }
#line 466
          if ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 466
            if ((unsigned long )f->stem < (unsigned long )f->name) {
              {
#line 469
              free((void *)f->stem);
              }
            } else {
              {
#line 466
              tmp___32 = strlen((char const   *)f->name);
              }
#line 466
              if ((unsigned long )f->stem > (unsigned long )(f->name + tmp___32)) {
                {
#line 469
                free((void *)f->stem);
                }
              }
            }
          }
        }
        while_break___12: /* CIL Label */ ;
        }
      } else {
#line 474
        goto while_break___5;
      }
      __Cont___1: /* CIL Label */ 
#line 305
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 479
    if (i < nrules) {
#line 480
      goto while_break___4;
    }
#line 482
    rule = (struct rule *)0;
#line 299
    intermed_ok ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 487
  if ((unsigned long )rule == (unsigned long )((struct rule *)0)) {
#line 488
    return (0);
  }
#line 490
  foundrule = i;
#line 495
  if (recursions > 0U) {
#line 497
    file->name = *(rule->targets + *(matches + foundrule));
  }
  {
#line 503
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 503
    tmp___36 = deps_found;
#line 503
    deps_found --;
#line 503
    if (! (tmp___36 > 0U)) {
#line 503
      goto while_break___13;
    }
#line 507
    if ((unsigned long )*(intermediate_files + deps_found) != (unsigned long )((struct file *)0)) {
      {
#line 516
      imf = *(intermediate_files + deps_found);
#line 517
      tmp___34 = enter_file(imf->name);
#line 517
      f___0 = tmp___34;
#line 518
      f___0->deps = imf->deps;
#line 519
      f___0->cmds = imf->cmds;
#line 520
      f___0->stem = imf->stem;
#line 521
      imf = lookup_file(*(intermediate_patterns + deps_found));
      }
#line 522
      if ((unsigned long )imf != (unsigned long )((struct file *)0)) {
#line 522
        if (imf->precious) {
#line 523
          f___0->precious = 1U;
        }
      }
#line 524
      f___0->intermediate = 1U;
#line 525
      f___0->tried_implicit = 1U;
#line 526
      dep = f___0->deps;
      {
#line 526
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 526
        if (! ((unsigned long )dep != (unsigned long )((struct dep *)0))) {
#line 526
          goto while_break___14;
        }
        {
#line 528
        dep->file = enter_file(dep->name);
#line 529
        dep->name = (char *)0;
#line 530
        (dep->file)->tried_implicit |= (unsigned int )dep->changed;
#line 526
        dep = dep->next;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
#line 532
      num_intermediates ++;
    }
    {
#line 535
    tmp___35 = xmalloc(sizeof(struct dep ));
#line 535
    dep = (struct dep *)tmp___35;
#line 536
    s = *(found_files + deps_found);
    }
#line 537
    if (recursions == 0U) {
      {
#line 539
      dep->name = (char *)0;
#line 540
      dep->file = lookup_file(s);
      }
#line 541
      if ((unsigned long )dep->file == (unsigned long )((struct file *)0)) {
        {
#line 543
        dep->file = enter_file(s);
        }
      } else {
        {
#line 547
        free((void *)s);
        }
      }
    } else {
#line 551
      dep->name = s;
#line 552
      dep->file = (struct file *)0;
#line 553
      dep->changed = 0;
    }
#line 555
    if ((unsigned long )*(intermediate_files + deps_found) == (unsigned long )((struct file *)0)) {
#line 555
      if ((*(tryrules + foundrule))->terminal) {
#line 562
        if ((unsigned long )dep->file == (unsigned long )((struct file *)0)) {
#line 563
          dep->changed = 1;
        } else {
#line 565
          (dep->file)->tried_implicit = 1U;
        }
      }
    }
#line 567
    dep->next = file->deps;
#line 568
    file->deps = dep;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 571
  if (! *(checked_lastslash + foundrule)) {
    {
#line 574
    file->stem = savestring(stem, stemlen);
    }
  } else {
    {
#line 579
    tmp___37 = xmalloc((((lastslash + 1) - filename) + (long )stemlen) + 1L);
#line 579
    file->stem = tmp___37;
#line 581
    memmove((void *)file->stem, (void const   *)filename, (size_t )((lastslash + 1) - filename));
#line 582
    memmove((void *)(file->stem + ((lastslash + 1) - filename)), (void const   *)stem,
            (size_t )stemlen);
#line 583
    *(file->stem + (((lastslash + 1) - filename) + (long )stemlen)) = (char )'\000';
    }
  }
#line 586
  file->cmds = rule->cmds;
#line 592
  if ((unsigned long )*(rule->targets + 1) != (unsigned long )((char *)0)) {
#line 593
    i = 0U;
    {
#line 593
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 593
      if (! ((unsigned long )*(rule->targets + i) != (unsigned long )((char *)0))) {
#line 593
        goto while_break___15;
      }
#line 594
      if (i != *(matches + foundrule)) {
        {
#line 596
        tmp___38 = xmalloc(sizeof(struct dep ));
#line 596
        new = (struct dep *)tmp___38;
#line 597
        tmp___39 = xmalloc((*(rule->lens + i) + stemlen) + 1U);
#line 597
        p = tmp___39;
#line 597
        new->name = p;
#line 598
        memmove((void *)p, (void const   *)*(rule->targets + i), (size_t )((*(rule->suffixes + i) - *(rule->targets + i)) - 1L));
#line 600
        p += (*(rule->suffixes + i) - *(rule->targets + i)) - 1L;
#line 601
        memmove((void *)p, (void const   *)stem, (size_t )stemlen);
#line 602
        p += stemlen;
#line 603
        memmove((void *)p, (void const   *)*(rule->suffixes + i), (size_t )(((long )*(rule->lens + i) - (*(rule->suffixes + i) - *(rule->targets + i))) + 1L));
#line 605
        new->file = enter_file(new->name);
#line 606
        new->next = file->also_make;
#line 607
        file->also_make = new;
        }
      }
#line 593
      i ++;
    }
    while_break___15: /* CIL Label */ ;
    }
  }
#line 611
  return (1);
}
}
#line 359 "/home/khheo/testset/make-3.76.1/make.h"
void count_implicit_rule_limits(void) ;
#line 360
void convert_to_pattern(void) ;
#line 361
void create_pattern_rule(char **targets , char **target_percents , int terminal ,
                         struct dep *deps , struct commands *commands , int override ) ;
#line 89 "/home/khheo/testset/make-3.76.1/filedef.h"
struct file *suffix_file  ;
#line 40 "/home/khheo/testset/make-3.76.1/commands.h"
void print_commands(struct commands *cmds ) ;
#line 40 "/home/khheo/testset/make-3.76.1/rule.h"
struct rule *pattern_rules  ;
#line 41 "/home/khheo/testset/make-3.76.1/rule.h"
struct rule *last_pattern_rule  ;
#line 42 "/home/khheo/testset/make-3.76.1/rule.h"
unsigned int num_pattern_rules  ;
#line 44 "/home/khheo/testset/make-3.76.1/rule.h"
unsigned int max_pattern_deps  ;
#line 45 "/home/khheo/testset/make-3.76.1/rule.h"
unsigned int max_pattern_targets  ;
#line 46 "/home/khheo/testset/make-3.76.1/rule.h"
unsigned int max_pattern_dep_length  ;
#line 49 "/home/khheo/testset/make-3.76.1/rule.h"
unsigned int maxsuffix  ;
#line 53
int new_pattern_rule(struct rule *rule , int override ) ;
#line 27 "/home/khheo/testset/make-3.76.1/rule.c"
static void freerule(struct rule *rule , struct rule *lastrule ) ;
#line 67 "/home/khheo/testset/make-3.76.1/rule.c"
void count_implicit_rule_limits(void) 
{ 
  char *name___0 ;
  unsigned int namelen ;
  register struct rule *rule ;
  register struct rule *lastrule ;
  unsigned int ndeps ;
  register struct dep *dep ;
  struct rule *next ;
  unsigned int ntargets ;
  unsigned int len ;
  size_t tmp ;
  char *p ;
  char *tmp___0 ;
  char *p2 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp19 ;

  {
#line 74
  max_pattern_deps = 0U;
#line 74
  max_pattern_targets = max_pattern_deps;
#line 74
  num_pattern_rules = max_pattern_targets;
#line 75
  max_pattern_dep_length = 0U;
#line 77
  name___0 = (char *)0;
#line 78
  namelen = 0U;
#line 79
  rule = pattern_rules;
#line 80
  lastrule = (struct rule *)0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! ((unsigned long )rule != (unsigned long )((struct rule *)0))) {
#line 81
      goto while_break;
    }
#line 83
    ndeps = 0U;
#line 85
    next = rule->next;
#line 88
    num_pattern_rules ++;
#line 90
    ntargets = 0U;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (! ((unsigned long )*(rule->targets + ntargets) != (unsigned long )((char *)0))) {
#line 91
        goto while_break___0;
      }
#line 92
      ntargets ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (ntargets > max_pattern_targets) {
#line 95
      max_pattern_targets = ntargets;
    }
#line 97
    dep = rule->deps;
    {
#line 97
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 97
      if (! ((unsigned long )dep != (unsigned long )((struct dep *)0))) {
#line 97
        goto while_break___1;
      }
      {
#line 99
      tmp = strlen((char const   *)dep->name);
#line 99
      len = (unsigned int )tmp;
#line 104
      tmp___0 = strrchr((char const   *)dep->name, '/');
#line 104
      p = tmp___0;
      }
#line 106
      if ((unsigned long )p != (unsigned long )((char *)0)) {
        {
#line 106
        tmp___1 = strchr((char const   *)dep->name, '%');
#line 106
        tmp___2 = tmp___1;
        }
      } else {
#line 106
        tmp___2 = (char *)0;
      }
#line 106
      p2 = tmp___2;
#line 107
      ndeps ++;
#line 109
      if (len > max_pattern_dep_length) {
#line 110
        max_pattern_dep_length = len;
      }
#line 112
      if ((unsigned long )p != (unsigned long )((char *)0)) {
#line 112
        if ((unsigned long )p2 > (unsigned long )p) {
#line 116
          if ((unsigned long )p == (unsigned long )dep->name) {
#line 117
            p ++;
          }
#line 118
          if (p - dep->name > (long )namelen) {
#line 120
            if ((unsigned long )name___0 != (unsigned long )((char *)0)) {
              {
#line 121
              free((void *)name___0);
              }
            }
            {
#line 122
            namelen = (unsigned int )(p - dep->name);
#line 123
            tmp___3 = xmalloc(namelen + 1U);
#line 123
            name___0 = tmp___3;
            }
          }
          {
#line 125
          memmove((void *)name___0, (void const   *)dep->name, (size_t )(p - dep->name));
#line 126
          *(name___0 + (p - dep->name)) = (char )'\000';
#line 132
          tmp___4 = dir_file_exists_p(name___0, "");
          }
#line 132
          if (tmp___4) {
#line 132
            tmp___5 = 0;
          } else {
#line 132
            tmp___5 = 1;
          }
#line 132
          dep->changed = tmp___5;
#line 136
          if (dep->changed) {
#line 136
            if ((int )*name___0 == 47) {
              {
#line 143
              freerule(rule, lastrule);
#line 144
              num_pattern_rules --;
              }
#line 145
              goto end_main_loop;
            }
          }
        } else {
#line 150
          dep->changed = 0;
        }
      } else {
#line 150
        dep->changed = 0;
      }
#line 97
      dep = dep->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 153
    if (ndeps > max_pattern_deps) {
#line 154
      max_pattern_deps = ndeps;
    }
#line 156
    lastrule = rule;
    end_main_loop: 
#line 158
    rule = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  if ((unsigned long )name___0 != (unsigned long )((char *)0)) {
    {
#line 162
    free((void *)name___0);
    }
  }
#line 163
  return;
}
}
#line 171 "/home/khheo/testset/make-3.76.1/rule.c"
static void convert_suffix_rule(char *target , char *source , struct commands *cmds ) 
{ 
  char *targname ;
  char *targpercent ;
  char *depname ;
  char **names ;
  char **percents ;
  struct dep *deps ;
  unsigned int len ;
  size_t tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp17 ;

  {
#line 181
  if ((unsigned long )target == (unsigned long )((char *)0)) {
    {
#line 188
    targname = savestring("(%.o)", 5);
#line 190
    targpercent = targname + 1;
    }
  } else {
    {
#line 195
    tmp = strlen((char const   *)target);
#line 195
    len = (unsigned int )tmp;
#line 196
    targname = xmalloc((1U + len) + 1U);
#line 197
    *(targname + 0) = (char )'%';
#line 198
    memmove((void *)(targname + 1), (void const   *)target, (size_t )(len + 1U));
#line 199
    targpercent = targname;
    }
  }
  {
#line 202
  tmp___0 = xmalloc(2UL * sizeof(char *));
#line 202
  names = (char **)tmp___0;
#line 203
  tmp___1 = __builtin_alloca(2UL * sizeof(char *));
#line 203
  percents = (char **)tmp___1;
#line 204
  *(names + 0) = targname;
#line 205
  *(percents + 0) = targpercent;
#line 206
  tmp___2 = (char *)0;
#line 206
  *(percents + 1) = tmp___2;
#line 206
  *(names + 1) = tmp___2;
  }
#line 208
  if ((unsigned long )source == (unsigned long )((char *)0)) {
#line 209
    deps = (struct dep *)0;
  } else {
    {
#line 213
    tmp___3 = strlen((char const   *)source);
#line 213
    len = (unsigned int )tmp___3;
#line 214
    depname = xmalloc((1U + len) + 1U);
#line 215
    *(depname + 0) = (char )'%';
#line 216
    memmove((void *)(depname + 1), (void const   *)source, (size_t )(len + 1U));
#line 217
    tmp___4 = xmalloc(sizeof(struct dep ));
#line 217
    deps = (struct dep *)tmp___4;
#line 218
    deps->next = (struct dep *)0;
#line 219
    deps->name = depname;
    }
  }
  {
#line 222
  create_pattern_rule(names, percents, 0, deps, cmds, 0);
  }
#line 223
  return;
}
}
#line 229 "/home/khheo/testset/make-3.76.1/rule.c"
void convert_to_pattern(void) 
{ 
  register struct dep *d ;
  register struct dep *d2 ;
  register struct file *f ;
  register char *rulename ;
  register unsigned int slen ;
  register unsigned int s2len ;
  register unsigned int namelen ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *__cil_tmp30 ;

  {
#line 239
  maxsuffix = 0U;
#line 240
  d = suffix_file->deps;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 240
      goto while_break;
    }
#line 242
    if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 242
      tmp = (d->file)->name;
    } else {
#line 242
      tmp = d->name;
    }
    {
#line 242
    tmp___0 = strlen((char const   *)tmp);
#line 242
    namelen = (unsigned int )tmp___0;
    }
#line 243
    if (namelen > maxsuffix) {
#line 244
      maxsuffix = namelen;
    }
#line 240
    d = d->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 247
  tmp___1 = __builtin_alloca((unsigned long )(maxsuffix * 2U + 1U));
#line 247
  rulename = (char *)tmp___1;
#line 249
  d = suffix_file->deps;
  }
  {
#line 249
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 249
    if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 249
      goto while_break___0;
    }
#line 253
    if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 253
      tmp___2 = (d->file)->name;
    } else {
#line 253
      tmp___2 = d->name;
    }
    {
#line 253
    convert_suffix_rule(tmp___2, (char *)0, (struct commands *)0);
#line 255
    f = d->file;
    }
#line 256
    if ((unsigned long )f->cmds != (unsigned long )((struct commands *)0)) {
#line 258
      if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 258
        tmp___3 = (d->file)->name;
      } else {
#line 258
        tmp___3 = d->name;
      }
      {
#line 258
      convert_suffix_rule((char *)"", tmp___3, f->cmds);
      }
    }
#line 261
    if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 261
      tmp___4 = (d->file)->name;
    } else {
#line 261
      tmp___4 = d->name;
    }
    {
#line 261
    tmp___5 = strlen((char const   *)tmp___4);
#line 261
    slen = (unsigned int )tmp___5;
    }
#line 262
    if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 262
      tmp___6 = (d->file)->name;
    } else {
#line 262
      tmp___6 = d->name;
    }
    {
#line 262
    memmove((void *)rulename, (void const   *)tmp___6, (size_t )slen);
#line 263
    d2 = suffix_file->deps;
    }
    {
#line 263
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 263
      if (! ((unsigned long )d2 != (unsigned long )((struct dep *)0))) {
#line 263
        goto while_break___1;
      }
#line 265
      if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
#line 265
        tmp___7 = (d2->file)->name;
      } else {
#line 265
        tmp___7 = d2->name;
      }
      {
#line 265
      tmp___8 = strlen((char const   *)tmp___7);
#line 265
      s2len = (unsigned int )tmp___8;
      }
#line 267
      if (slen == s2len) {
#line 267
        if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 267
          tmp___9 = (d->file)->name;
        } else {
#line 267
          tmp___9 = d->name;
        }
#line 267
        if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
#line 267
          tmp___10 = (d2->file)->name;
        } else {
#line 267
          tmp___10 = d2->name;
        }
#line 267
        if ((unsigned long )tmp___9 == (unsigned long )tmp___10) {
#line 268
          goto __Cont;
        } else {
#line 267
          if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 267
            tmp___11 = (d->file)->name;
          } else {
#line 267
            tmp___11 = d->name;
          }
#line 267
          if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
#line 267
            tmp___12 = (d2->file)->name;
          } else {
#line 267
            tmp___12 = d2->name;
          }
#line 267
          if ((int )*tmp___11 == (int )*tmp___12) {
#line 267
            if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 267
              tmp___13 = (d->file)->name;
            } else {
#line 267
              tmp___13 = d->name;
            }
#line 267
            if ((int )*tmp___13 == 0) {
#line 268
              goto __Cont;
            } else {
#line 267
              if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
#line 267
                tmp___14 = (d2->file)->name;
              } else {
#line 267
                tmp___14 = d2->name;
              }
#line 267
              if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 267
                tmp___15 = (d->file)->name;
              } else {
#line 267
                tmp___15 = d->name;
              }
              {
#line 267
              tmp___16 = strcmp((char const   *)(tmp___15 + 1), (char const   *)(tmp___14 + 1));
              }
#line 267
              if (! tmp___16) {
#line 268
                goto __Cont;
              }
            }
          }
        }
      }
#line 270
      if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
#line 270
        tmp___17 = (d2->file)->name;
      } else {
#line 270
        tmp___17 = d2->name;
      }
      {
#line 270
      memmove((void *)(rulename + slen), (void const   *)tmp___17, (size_t )(s2len + 1U));
#line 271
      f = lookup_file(rulename);
      }
#line 272
      if ((unsigned long )f == (unsigned long )((struct file *)0)) {
#line 273
        goto __Cont;
      } else
#line 272
      if ((unsigned long )f->cmds == (unsigned long )((struct commands *)0)) {
#line 273
        goto __Cont;
      }
#line 275
      if (s2len == 2U) {
#line 275
        if ((int )*(rulename + slen) == 46) {
#line 275
          if ((int )*(rulename + (slen + 1U)) == 97) {
#line 278
            if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 278
              tmp___18 = (d->file)->name;
            } else {
#line 278
              tmp___18 = d->name;
            }
            {
#line 278
            convert_suffix_rule((char *)0, tmp___18, f->cmds);
            }
          }
        }
      }
#line 284
      if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 284
        tmp___19 = (d->file)->name;
      } else {
#line 284
        tmp___19 = d->name;
      }
#line 284
      if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
#line 284
        tmp___20 = (d2->file)->name;
      } else {
#line 284
        tmp___20 = d2->name;
      }
      {
#line 284
      convert_suffix_rule(tmp___20, tmp___19, f->cmds);
      }
      __Cont: /* CIL Label */ 
#line 263
      d2 = d2->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 249
    d = d->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 287
  return;
}
}
#line 298 "/home/khheo/testset/make-3.76.1/rule.c"
int new_pattern_rule(struct rule *rule , int override ) 
{ 
  register struct rule *r ;
  register struct rule *lastrule ;
  register unsigned int i ;
  register unsigned int j ;
  int tmp ;
  register struct dep *d ;
  register struct dep *d2 ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 306
  rule->in_use = (char)0;
#line 307
  rule->terminal = (char)0;
#line 309
  rule->next = (struct rule *)0;
#line 312
  lastrule = (struct rule *)0;
#line 313
  r = pattern_rules;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! ((unsigned long )r != (unsigned long )((struct rule *)0))) {
#line 313
      goto while_break;
    }
#line 314
    i = 0U;
    {
#line 314
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 314
      if (! ((unsigned long )*(rule->targets + i) != (unsigned long )((char *)0))) {
#line 314
        goto while_break___0;
      }
#line 316
      j = 0U;
      {
#line 316
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 316
        if (! ((unsigned long )*(r->targets + j) != (unsigned long )((char *)0))) {
#line 316
          goto while_break___1;
        }
#line 317
        if (! ((unsigned long )*(rule->targets + i) == (unsigned long )*(r->targets + j))) {
#line 317
          if ((int )*(*(rule->targets + i)) == (int )*(*(r->targets + j))) {
#line 317
            if (! ((int )*(*(rule->targets + i)) == 0)) {
              {
#line 317
              tmp = strcmp((char const   *)(*(rule->targets + i) + 1), (char const   *)(*(r->targets + j) + 1));
              }
#line 317
              if (tmp) {
#line 318
                goto while_break___1;
              }
            }
          } else {
#line 318
            goto while_break___1;
          }
        }
#line 316
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 319
      if ((unsigned long )*(r->targets + j) == (unsigned long )((char *)0)) {
#line 323
        d = rule->deps;
#line 323
        d2 = r->deps;
        {
#line 323
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 323
          if ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 323
            if (! ((unsigned long )d2 != (unsigned long )((struct dep *)0))) {
#line 323
              goto while_break___2;
            }
          } else {
#line 323
            goto while_break___2;
          }
#line 325
          if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 325
            tmp___0 = (d->file)->name;
          } else {
#line 325
            tmp___0 = d->name;
          }
#line 325
          if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
#line 325
            tmp___1 = (d2->file)->name;
          } else {
#line 325
            tmp___1 = d2->name;
          }
#line 325
          if (! ((unsigned long )tmp___0 == (unsigned long )tmp___1)) {
#line 325
            if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 325
              tmp___2 = (d->file)->name;
            } else {
#line 325
              tmp___2 = d->name;
            }
#line 325
            if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
#line 325
              tmp___3 = (d2->file)->name;
            } else {
#line 325
              tmp___3 = d2->name;
            }
#line 325
            if ((int )*tmp___2 == (int )*tmp___3) {
#line 325
              if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 325
                tmp___4 = (d->file)->name;
              } else {
#line 325
                tmp___4 = d->name;
              }
#line 325
              if (! ((int )*tmp___4 == 0)) {
#line 325
                if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
#line 325
                  tmp___5 = (d2->file)->name;
                } else {
#line 325
                  tmp___5 = d2->name;
                }
#line 325
                if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 325
                  tmp___6 = (d->file)->name;
                } else {
#line 325
                  tmp___6 = d->name;
                }
                {
#line 325
                tmp___7 = strcmp((char const   *)(tmp___6 + 1), (char const   *)(tmp___5 + 1));
                }
#line 325
                if (tmp___7) {
#line 326
                  goto while_break___2;
                }
              }
            } else {
#line 326
              goto while_break___2;
            }
          }
#line 323
          d = d->next;
#line 323
          d2 = d2->next;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 327
        if ((unsigned long )d == (unsigned long )((struct dep *)0)) {
#line 327
          if ((unsigned long )d2 == (unsigned long )((struct dep *)0)) {
#line 329
            if (override) {
              {
#line 332
              freerule(r, lastrule);
              }
#line 334
              if ((unsigned long )pattern_rules == (unsigned long )((struct rule *)0)) {
#line 335
                pattern_rules = rule;
              } else {
#line 337
                last_pattern_rule->next = rule;
              }
#line 338
              last_pattern_rule = rule;
#line 341
              goto matched;
            } else {
              {
#line 346
              freerule(rule, (struct rule *)0);
              }
#line 347
              return (0);
            }
          }
        }
      }
#line 314
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 313
    lastrule = r;
#line 313
    r = r->next;
  }
  while_break: /* CIL Label */ ;
  }
  matched: ;
#line 354
  if ((unsigned long )r == (unsigned long )((struct rule *)0)) {
#line 357
    if ((unsigned long )pattern_rules == (unsigned long )((struct rule *)0)) {
#line 358
      pattern_rules = rule;
    } else {
#line 360
      last_pattern_rule->next = rule;
    }
#line 361
    last_pattern_rule = rule;
  }
#line 364
  return (1);
}
}
#line 373 "/home/khheo/testset/make-3.76.1/rule.c"
void install_pattern_rule(struct pspec *p , int terminal ) 
{ 
  register struct rule *r ;
  char *ptr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  struct nameseq *tmp___4 ;
  struct nameseq *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
  {
#line 381
  tmp = xmalloc(sizeof(struct rule ));
#line 381
  r = (struct rule *)tmp;
#line 383
  tmp___0 = xmalloc(2UL * sizeof(char *));
#line 383
  r->targets = (char **)tmp___0;
#line 384
  tmp___1 = xmalloc(2UL * sizeof(char *));
#line 384
  r->suffixes = (char **)tmp___1;
#line 385
  tmp___2 = xmalloc(2UL * sizeof(unsigned int ));
#line 385
  r->lens = (unsigned int *)tmp___2;
#line 387
  *(r->targets + 1) = (char *)0;
#line 388
  *(r->suffixes + 1) = (char *)0;
#line 389
  *(r->lens + 1) = 0U;
#line 391
  tmp___3 = strlen((char const   *)p->target);
#line 391
  *(r->lens + 0) = (unsigned int )tmp___3;
#line 394
  *(r->targets + 0) = savestring(p->target, *(r->lens + 0));
#line 395
  *(r->suffixes + 0) = find_percent(*(r->targets + 0));
  }
#line 396
  if ((unsigned long )*(r->suffixes + 0) == (unsigned long )((char *)0)) {
    {
#line 398
    abort();
    }
  } else {
#line 400
    (*(r->suffixes + 0)) ++;
  }
  {
#line 402
  ptr = p->dep;
#line 403
  tmp___4 = parse_file_seq(& ptr, '\000', (unsigned int )sizeof(struct dep ), 1);
#line 403
  tmp___5 = multi_glob(tmp___4, (unsigned int )sizeof(struct dep ));
#line 403
  r->deps = (struct dep *)tmp___5;
#line 407
  tmp___8 = new_pattern_rule(r, 0);
  }
#line 407
  if (tmp___8) {
    {
#line 409
    r->terminal = (char )terminal;
#line 410
    tmp___6 = xmalloc(sizeof(struct commands ));
#line 410
    r->cmds = (struct commands *)tmp___6;
#line 411
    (r->cmds)->filename = (char *)0;
#line 412
    (r->cmds)->lineno = 0U;
#line 415
    tmp___7 = strlen((char const   *)p->commands);
#line 415
    (r->cmds)->commands = savestring(p->commands, tmp___7);
#line 416
    (r->cmds)->command_lines = (char **)0;
    }
  }
#line 418
  return;
}
}
#line 425 "/home/khheo/testset/make-3.76.1/rule.c"
static void freerule(struct rule *rule , struct rule *lastrule ) 
{ 
  struct rule *next ;
  register unsigned int i ;

  {
#line 429
  next = rule->next;
#line 432
  i = 0U;
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 432
    if (! ((unsigned long )*(rule->targets + i) != (unsigned long )((char *)0))) {
#line 432
      goto while_break;
    }
    {
#line 433
    free((void *)*(rule->targets + i));
#line 432
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 435
  free((void *)((char *)rule->targets));
#line 436
  free((void *)((char *)rule->suffixes));
#line 437
  free((void *)((char *)rule->lens));
#line 450
  free((void *)((char *)rule));
  }
#line 452
  if ((unsigned long )pattern_rules == (unsigned long )rule) {
#line 453
    if ((unsigned long )lastrule != (unsigned long )((struct rule *)0)) {
      {
#line 454
      abort();
      }
    } else {
#line 456
      pattern_rules = next;
    }
  } else
#line 457
  if ((unsigned long )lastrule != (unsigned long )((struct rule *)0)) {
#line 458
    lastrule->next = next;
  }
#line 459
  if ((unsigned long )last_pattern_rule == (unsigned long )rule) {
#line 460
    last_pattern_rule = lastrule;
  }
#line 461
  return;
}
}
#line 474 "/home/khheo/testset/make-3.76.1/rule.c"
void create_pattern_rule(char **targets , char **target_percents , int terminal ,
                         struct dep *deps , struct commands *commands , int override ) 
{ 
  register struct rule *r ;
  char *tmp ;
  register unsigned int max_targets ;
  register unsigned int i ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 483
  tmp = xmalloc(sizeof(struct rule ));
#line 483
  r = (struct rule *)tmp;
#line 486
  r->cmds = commands;
#line 487
  r->deps = deps;
#line 488
  r->targets = targets;
#line 490
  max_targets = 2U;
#line 491
  tmp___0 = xmalloc(2UL * sizeof(unsigned int ));
#line 491
  r->lens = (unsigned int *)tmp___0;
#line 492
  tmp___1 = xmalloc(2UL * sizeof(char *));
#line 492
  r->suffixes = (char **)tmp___1;
#line 493
  i = 0U;
  }
  {
#line 493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 493
    if (! ((unsigned long )*(targets + i) != (unsigned long )((char *)0))) {
#line 493
      goto while_break;
    }
#line 495
    if (i == max_targets - 1U) {
      {
#line 497
      max_targets += 5U;
#line 498
      tmp___2 = xrealloc((char *)r->lens, (unsigned long )max_targets * sizeof(unsigned int ));
#line 498
      r->lens = (unsigned int *)tmp___2;
#line 500
      tmp___3 = xrealloc((char *)r->suffixes, (unsigned long )max_targets * sizeof(char *));
#line 500
      r->suffixes = (char **)tmp___3;
      }
    }
    {
#line 503
    tmp___4 = strlen((char const   *)*(targets + i));
#line 503
    *(r->lens + i) = (unsigned int )tmp___4;
    }
#line 504
    if ((unsigned long )target_percents == (unsigned long )((char **)0)) {
      {
#line 504
      tmp___5 = find_percent(*(targets + i));
#line 504
      tmp___6 = tmp___5;
      }
    } else {
#line 504
      tmp___6 = *(target_percents + i);
    }
#line 504
    *(r->suffixes + i) = tmp___6 + 1;
#line 506
    if ((unsigned long )*(r->suffixes + i) == (unsigned long )((char *)0)) {
      {
#line 507
      abort();
      }
    }
#line 493
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 510
  if (i < max_targets - 1U) {
    {
#line 512
    tmp___7 = xrealloc((char *)r->lens, (unsigned long )(i + 1U) * sizeof(unsigned int ));
#line 512
    r->lens = (unsigned int *)tmp___7;
#line 514
    tmp___8 = xrealloc((char *)r->suffixes, (unsigned long )(i + 1U) * sizeof(char *));
#line 514
    r->suffixes = (char **)tmp___8;
    }
  }
  {
#line 518
  tmp___9 = new_pattern_rule(r, override);
  }
#line 518
  if (tmp___9) {
#line 519
    r->terminal = (char )terminal;
  }
#line 520
  return;
}
}
#line 524 "/home/khheo/testset/make-3.76.1/rule.c"
static void print_rule(struct rule *r ) 
{ 
  register unsigned int i ;
  register struct dep *d ;
  char *tmp ;
  char *__cil_tmp5 ;

  {
#line 531
  i = 0U;
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (! ((unsigned long )*(r->targets + i) != (unsigned long )((char *)0))) {
#line 531
      goto while_break;
    }
    {
#line 533
    fputs((char const   */* __restrict  */)*(r->targets + i), (FILE */* __restrict  */)stdout);
    }
#line 534
    if ((unsigned long )*(r->targets + (i + 1U)) != (unsigned long )((char *)0)) {
      {
#line 535
      putchar(' ');
      }
    } else {
      {
#line 537
      putchar(':');
      }
    }
#line 531
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 539
  if (r->terminal) {
    {
#line 540
    putchar(':');
    }
  }
#line 542
  d = r->deps;
  {
#line 542
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 542
    if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 542
      goto while_break___0;
    }
#line 543
    if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 543
      tmp = (d->file)->name;
    } else {
#line 543
      tmp = d->name;
    }
    {
#line 543
    printf((char const   */* __restrict  */)" %s", tmp);
#line 542
    d = d->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 544
  putchar('\n');
  }
#line 546
  if ((unsigned long )r->cmds != (unsigned long )((struct commands *)0)) {
    {
#line 547
    print_commands(r->cmds);
    }
  }
#line 548
  return;
}
}
#line 550 "/home/khheo/testset/make-3.76.1/rule.c"
void print_rule_data_base(void) 
{ 
  register unsigned int rules ;
  register unsigned int terminal ;
  register struct rule *r ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 556
  puts("\n# Implicit Rules");
#line 558
  terminal = 0U;
#line 558
  rules = terminal;
#line 559
  r = pattern_rules;
  }
  {
#line 559
  while (1) {
    while_continue: /* CIL Label */ ;
#line 559
    if (! ((unsigned long )r != (unsigned long )((struct rule *)0))) {
#line 559
      goto while_break;
    }
    {
#line 561
    rules ++;
#line 563
    putchar('\n');
#line 564
    print_rule(r);
    }
#line 566
    if (r->terminal) {
#line 567
      terminal ++;
    }
#line 559
    r = r->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  if (rules == 0U) {
    {
#line 571
    puts("\n# No implicit rules.");
    }
  } else {
    {
#line 574
    printf((char const   */* __restrict  */)"\n# %u implicit rules, %u", rules, terminal);
#line 576
    printf((char const   */* __restrict  */)" (%.1f%%)", ((double )terminal / (double )rules) * 100.0);
#line 583
    puts(" terminal.");
    }
  }
#line 586
  if (num_pattern_rules != rules) {
    {
#line 587
    fatal("BUG: num_pattern_rules wrong!  %u != %u", num_pattern_rules, rules);
    }
  }
#line 589
  return;
}
}
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 316 "/home/khheo/testset/make-3.76.1/make.h"
void message(int prefix , char *s1 , char *s2 , char *s3 , char *s4 , char *s5 , char *s6 ) ;
#line 337
struct dep *copy_dep_chain(struct dep *d ) ;
#line 371
int update_goal_chain(struct dep *goals___0 , int makefiles___0 ) ;
#line 372
void notice_finished_file(struct file *file ) ;
#line 409
int just_print_flag ;
#line 409
int silent_flag ;
#line 409
int keep_going_flag ;
#line 410
int question_flag ;
#line 410
int touch_flag ;
#line 414
int clock_skew_detected ;
#line 416
unsigned int job_slots ;
#line 428
unsigned int commands_started ;
#line 89 "/home/khheo/testset/make-3.76.1/filedef.h"
struct file *default_file ;
#line 94
void rename_file(struct file *file , char *name___0 ) ;
#line 94
void rehash_file(struct file *file , char *name___0 ) ;
#line 95
void set_command_state(struct file *file , int state ) ;
#line 53 "/home/khheo/testset/make-3.76.1/job.h"
void start_waiting_jobs(void) ;
#line 39 "/home/khheo/testset/make-3.76.1/commands.h"
void execute_file_commands(struct file *file ) ;
#line 42
void chop_commands(struct commands *cmds ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 47 "/home/khheo/testset/make-3.76.1/remake.c"
unsigned int commands_started  =    0U;
#line 49
static int update_file(struct file *file , unsigned int depth ) ;
#line 50
static int update_file_1(struct file *file , unsigned int depth ) ;
#line 51
static int check_dep(struct file *file , unsigned int depth , time_t this_mtime ,
                     int *must_make_ptr ) ;
#line 52
static int touch_file(struct file *file ) ;
#line 53
static void remake_file(struct file *file ) ;
#line 54
static time_t name_mtime(char *name___0 ) ;
#line 55
static int library_search(char **lib , time_t *mtime_ptr ) ;
#line 67 "/home/khheo/testset/make-3.76.1/remake.c"
int update_goal_chain(struct dep *goals___0 , int makefiles___0 ) 
{ 
  int t ;
  int q ;
  int n ;
  unsigned int j ;
  int status ;
  struct dep *g ;
  register struct dep *g___0 ;
  register struct dep *lastgoal___0 ;
  struct file *file ;
  int stop ;
  int any_not_updated ;
  unsigned int ocommands_started ;
  int x ;
  time_t mtime ;
  time_t tmp ;
  time_t tmp___0 ;
  time_t tmp___1 ;
  time_t tmp___2 ;
  time_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  time_t tmp___6 ;
  time_t tmp___7 ;
  time_t tmp___8 ;
  time_t tmp___9 ;
  time_t tmp___10 ;
  char const   *tmp___11 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 72
  t = touch_flag;
#line 72
  q = question_flag;
#line 72
  n = just_print_flag;
#line 73
  j = job_slots;
#line 74
  status = -1;
#line 81
  goals___0 = copy_dep_chain(goals___0);
#line 90
  g = goals___0;
  }
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! ((unsigned long )g != (unsigned long )((struct dep *)0))) {
#line 90
      goto while_break;
    }
#line 91
    g->changed = 0;
#line 90
    g = g->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  if (makefiles___0) {
#line 96
    job_slots = 1U;
  }
  {
#line 100
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 100
    if (! ((unsigned long )goals___0 != (unsigned long )((struct dep *)0))) {
#line 100
      goto while_break___0;
    }
    {
#line 106
    start_waiting_jobs();
#line 110
    reap_children(1, 0);
#line 112
    lastgoal___0 = (struct dep *)0;
#line 113
    g___0 = goals___0;
    }
    {
#line 114
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 114
      if (! ((unsigned long )g___0 != (unsigned long )((struct dep *)0))) {
#line 114
        goto while_break___1;
      }
#line 117
      file = g___0->file;
#line 118
      any_not_updated = 0;
#line 120
      if ((g___0->file)->double_colon) {
#line 120
        file = (g___0->file)->double_colon;
      } else {
#line 120
        file = g___0->file;
      }
      {
#line 120
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 120
        if (! ((unsigned long )file != (unsigned long )((void *)0))) {
#line 120
          goto while_break___2;
        }
#line 126
        if (makefiles___0) {
#line 126
          if (file->last_mtime != 0L) {
#line 126
            tmp___0 = file->last_mtime;
          } else {
            {
#line 126
            tmp = f_mtime(file, 0);
#line 126
            tmp___0 = tmp;
            }
          }
#line 126
          tmp___3 = tmp___0;
        } else {
#line 126
          if (file->last_mtime != 0L) {
#line 126
            tmp___2 = file->last_mtime;
          } else {
            {
#line 126
            tmp___1 = f_mtime(file, 1);
#line 126
            tmp___2 = tmp___1;
            }
          }
#line 126
          tmp___3 = tmp___2;
        }
#line 126
        mtime = tmp___3;
        {
#line 127
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 127
          if (! ((unsigned long )file->renamed != (unsigned long )((struct file *)0))) {
#line 127
            goto while_break___3;
          }
#line 127
          file = file->renamed;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 128
        if (makefiles___0) {
#line 130
          if (file->cmd_target) {
#line 132
            touch_flag = t;
#line 133
            question_flag = q;
#line 134
            just_print_flag = n;
          } else {
#line 137
            just_print_flag = 0;
#line 137
            question_flag = just_print_flag;
#line 137
            touch_flag = question_flag;
          }
        }
#line 143
        ocommands_started = commands_started;
#line 145
        if (makefiles___0) {
#line 145
          tmp___4 = 1;
        } else {
#line 145
          tmp___4 = 0;
        }
        {
#line 145
        x = update_file(file, (unsigned int )tmp___4);
        }
        {
#line 146
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 146
          if (! ((unsigned long )file->renamed != (unsigned long )((struct file *)0))) {
#line 146
            goto while_break___4;
          }
#line 146
          file = file->renamed;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 151
        g___0->changed = (int )((unsigned int )g___0->changed + (commands_started - ocommands_started));
#line 153
        stop = 0;
#line 154
        if (x != 0) {
#line 154
          goto _L;
        } else
#line 154
        if (file->updated) {
          _L: /* CIL Label */ 
#line 160
          if (status < 1) {
#line 162
            if ((int )file->update_status != 0) {
#line 166
              status = (int )file->update_status;
#line 170
              if (! keep_going_flag) {
#line 170
                if (! question_flag) {
#line 170
                  if (! makefiles___0) {
#line 170
                    tmp___5 = 1;
                  } else {
#line 170
                    tmp___5 = 0;
                  }
                } else {
#line 170
                  tmp___5 = 0;
                }
              } else {
#line 170
                tmp___5 = 0;
              }
#line 170
              stop = tmp___5;
            } else {
#line 173
              if (makefiles___0) {
#line 173
                if (file->last_mtime != 0L) {
#line 173
                  tmp___7 = file->last_mtime;
                } else {
                  {
#line 173
                  tmp___6 = f_mtime(file, 0);
#line 173
                  tmp___7 = tmp___6;
                  }
                }
#line 173
                tmp___10 = tmp___7;
              } else {
#line 173
                if (file->last_mtime != 0L) {
#line 173
                  tmp___9 = file->last_mtime;
                } else {
                  {
#line 173
                  tmp___8 = f_mtime(file, 1);
#line 173
                  tmp___9 = tmp___8;
                  }
                }
#line 173
                tmp___10 = tmp___9;
              }
#line 173
              if (tmp___10 != mtime) {
#line 181
                if (! makefiles___0) {
#line 183
                  status = 0;
                } else
#line 181
                if (! just_print_flag) {
#line 181
                  if (! question_flag) {
#line 183
                    status = 0;
                  }
                }
#line 184
                if (makefiles___0) {
#line 184
                  if (file->dontcare) {
#line 186
                    stop = 1;
                  }
                }
              }
            }
          }
        }
#line 193
        any_not_updated |= ! file->updated;
#line 195
        if (stop) {
#line 196
          goto while_break___2;
        }
#line 120
        file = file->prev;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 200
      file = g___0->file;
#line 202
      if (stop) {
#line 202
        goto _L___0;
      } else
#line 202
      if (! any_not_updated) {
        _L___0: /* CIL Label */ 
#line 207
        if (! makefiles___0) {
#line 207
          if ((int )file->update_status == 0) {
#line 207
            if (! g___0->changed) {
#line 207
              if (! silent_flag) {
#line 207
                if (! question_flag) {
#line 214
                  if (file->phony) {
#line 214
                    tmp___11 = "Nothing to be done for `%s\'.";
                  } else
#line 214
                  if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
#line 214
                    tmp___11 = "Nothing to be done for `%s\'.";
                  } else {
#line 214
                    tmp___11 = "`%s\' is up to date.";
                  }
                  {
#line 214
                  message(1, tmp___11, file->name);
                  }
                }
              }
            }
          }
        }
#line 220
        if ((unsigned long )lastgoal___0 == (unsigned long )((struct dep *)0)) {
#line 221
          goals___0 = g___0->next;
        } else {
#line 223
          lastgoal___0->next = g___0->next;
        }
        {
#line 226
        free((void *)((char *)g___0));
        }
#line 228
        if ((unsigned long )lastgoal___0 == (unsigned long )((struct dep *)0)) {
#line 228
          g___0 = goals___0;
        } else {
#line 228
          g___0 = lastgoal___0->next;
        }
#line 230
        if (stop) {
#line 231
          goto while_break___1;
        }
      } else {
#line 235
        lastgoal___0 = g___0;
#line 236
        g___0 = g___0->next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 241
  if (makefiles___0) {
#line 243
    touch_flag = t;
#line 244
    question_flag = q;
#line 245
    just_print_flag = n;
#line 246
    job_slots = j;
  }
#line 248
  return (status);
}
}
#line 263 "/home/khheo/testset/make-3.76.1/remake.c"
static int update_file(struct file *file , unsigned int depth ) 
{ 
  register int status ;
  register struct file *f ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 268
  status = 0;
#line 271
  if (file->double_colon) {
#line 271
    f = file->double_colon;
  } else {
#line 271
    f = file;
  }
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! ((unsigned long )f != (unsigned long )((struct file *)0))) {
#line 271
      goto while_break;
    }
    {
#line 273
    tmp = update_file_1(f, depth);
#line 273
    status |= tmp;
    }
    {
#line 274
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 274
      if (! ((unsigned long )f->renamed != (unsigned long )((struct file *)0))) {
#line 274
        goto while_break___0;
      }
#line 274
      f = f->renamed;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 276
    if (status != 0) {
#line 276
      if (! keep_going_flag) {
#line 277
        return (status);
      }
    }
    {
#line 281
    if ((unsigned int )f->command_state == 3U) {
#line 281
      goto case_3;
    }
#line 286
    if ((unsigned int )f->command_state == 1U) {
#line 286
      goto case_1;
    }
#line 286
    if ((unsigned int )f->command_state == 2U) {
#line 286
      goto case_1;
    }
#line 291
    goto switch_default;
    case_3: /* CIL Label */ 
#line 283
    goto switch_break;
    case_1: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 289
    return (0);
    switch_default: /* CIL Label */ 
#line 292
    if (! ((unsigned int )f->command_state == 2U)) {
      {
#line 292
      __assert_fail("f->command_state == cs_running", "/home/khheo/testset/make-3.76.1/remake.c",
                    292U, "update_file");
      }
    }
#line 293
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 271
    f = f->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  return (status);
}
}
#line 302 "/home/khheo/testset/make-3.76.1/remake.c"
static int update_file_1(struct file *file , unsigned int depth ) 
{ 
  register time_t this_mtime ;
  int noexist ;
  int must_make ;
  int deps_changed ;
  int dep_status ;
  register struct dep *d ;
  register struct dep *lastd ;
  int running ;
  time_t tmp ;
  int tmp___0 ;
  time_t mtime ;
  time_t tmp___1 ;
  int tmp___2 ;
  register struct file *f ;
  int tmp___3 ;
  time_t tmp___4 ;
  time_t tmp___5 ;
  time_t mtime___0 ;
  time_t tmp___6 ;
  time_t tmp___7 ;
  int tmp___8 ;
  register struct file *f___0 ;
  int tmp___9 ;
  time_t tmp___10 ;
  time_t tmp___11 ;
  int tmp___12 ;
  time_t d_mtime ;
  time_t tmp___13 ;
  time_t tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;

  {
#line 309
  dep_status = 0;
#line 311
  running = 0;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (debug_flag) {
      {
#line 313
      print_spaces(depth);
#line 313
      printf((char const   */* __restrict  */)"Considering target file `%s\'.\n",
             file->name);
#line 313
      fflush(stdout);
      }
    }
#line 313
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 315
  if (file->updated) {
#line 317
    if ((int )file->update_status > 0) {
      {
#line 319
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 319
        if (debug_flag) {
          {
#line 319
          print_spaces(depth);
#line 319
          printf((char const   */* __restrict  */)"Recently tried and failed to update file `%s\'.\n",
                 file->name);
#line 319
          fflush(stdout);
          }
        }
#line 319
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 320
      return ((int )file->update_status);
    }
    {
#line 323
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 323
      if (debug_flag) {
        {
#line 323
        print_spaces(depth);
#line 323
        printf((char const   */* __restrict  */)"File `%s\' was considered already.\n",
               file->name);
#line 323
        fflush(stdout);
        }
      }
#line 323
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 324
    return (0);
  }
  {
#line 330
  if ((unsigned int )file->command_state == 1U) {
#line 330
    goto case_1;
  }
#line 330
  if ((unsigned int )file->command_state == 0U) {
#line 330
    goto case_1;
  }
#line 332
  if ((unsigned int )file->command_state == 2U) {
#line 332
    goto case_2;
  }
#line 335
  if ((unsigned int )file->command_state == 3U) {
#line 335
    goto case_3;
  }
#line 338
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 331
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 333
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 333
    if (debug_flag) {
      {
#line 333
      print_spaces(depth);
#line 333
      printf((char const   */* __restrict  */)"Still updating file `%s\'.\n", file->name);
#line 333
      fflush(stdout);
      }
    }
#line 333
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 334
  return (0);
  case_3: /* CIL Label */ 
  {
#line 336
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 336
    if (debug_flag) {
      {
#line 336
      print_spaces(depth);
#line 336
      printf((char const   */* __restrict  */)"Finished updating file `%s\'.\n", file->name);
#line 336
      fflush(stdout);
      }
    }
#line 336
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 337
  return ((int )file->update_status);
  switch_default: /* CIL Label */ 
  {
#line 339
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 342
  depth ++;
#line 345
  file->updating = 1U;
#line 353
  if (file->last_mtime != 0L) {
#line 353
    this_mtime = file->last_mtime;
  } else {
    {
#line 353
    tmp = f_mtime(file, 1);
#line 353
    this_mtime = tmp;
    }
  }
  {
#line 354
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 354
    if (! ((unsigned long )file->renamed != (unsigned long )((struct file *)0))) {
#line 354
      goto while_break___4;
    }
#line 354
    file = file->renamed;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 355
  noexist = this_mtime == -1L;
#line 356
  if (noexist) {
    {
#line 357
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 357
      if (debug_flag) {
        {
#line 357
        print_spaces(depth);
#line 357
        printf((char const   */* __restrict  */)"File `%s\' does not exist.\n", file->name);
#line 357
        fflush(stdout);
        }
      }
#line 357
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 359
  must_make = noexist;
#line 364
  if (! file->phony) {
#line 364
    if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
#line 364
      if (! file->tried_implicit) {
        {
#line 366
        tmp___0 = try_implicit_rule(file, depth);
        }
#line 366
        if (tmp___0) {
          {
#line 367
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 367
            if (debug_flag) {
              {
#line 367
              print_spaces(depth);
#line 367
              printf((char const   */* __restrict  */)"Found an implicit rule for `%s\'.\n",
                     file->name);
#line 367
              fflush(stdout);
              }
            }
#line 367
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
        } else {
          {
#line 369
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 369
            if (debug_flag) {
              {
#line 369
              print_spaces(depth);
#line 369
              printf((char const   */* __restrict  */)"No implicit rule found for `%s\'.\n",
                     file->name);
#line 369
              fflush(stdout);
              }
            }
#line 369
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
        }
#line 370
        file->tried_implicit = 1U;
      }
    }
  }
#line 372
  if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
#line 372
    if (! file->is_target) {
#line 372
      if ((unsigned long )default_file != (unsigned long )((struct file *)0)) {
#line 372
        if ((unsigned long )default_file->cmds != (unsigned long )((struct commands *)0)) {
          {
#line 375
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 375
            if (debug_flag) {
              {
#line 375
              print_spaces(depth);
#line 375
              printf((char const   */* __restrict  */)"Using default commands for `%s\'.\n",
                     file->name);
#line 375
              fflush(stdout);
              }
            }
#line 375
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 376
          file->cmds = default_file->cmds;
        }
      }
    }
  }
#line 382
  lastd = (struct dep *)0;
#line 383
  d = file->deps;
  {
#line 384
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 384
    if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 384
      goto while_break___9;
    }
    {
#line 388
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 388
      if (! ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0))) {
#line 388
        goto while_break___10;
      }
#line 388
      d->file = (d->file)->renamed;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 390
    if ((d->file)->last_mtime != 0L) {
#line 390
      mtime = (d->file)->last_mtime;
    } else {
      {
#line 390
      tmp___1 = f_mtime(d->file, 1);
#line 390
      mtime = tmp___1;
      }
    }
    {
#line 391
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 391
      if (! ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0))) {
#line 391
        goto while_break___11;
      }
#line 391
      d->file = (d->file)->renamed;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 393
    if ((d->file)->updating) {
      {
#line 395
      error("Circular %s <- %s dependency dropped.", file->name, (d->file)->name);
      }
#line 397
      if ((unsigned long )lastd == (unsigned long )((struct dep *)0)) {
        {
#line 399
        file->deps = d->next;
#line 400
        free((void *)((char *)d));
#line 401
        d = file->deps;
        }
      } else {
        {
#line 405
        lastd->next = d->next;
#line 406
        free((void *)((char *)d));
#line 407
        d = lastd->next;
        }
      }
#line 409
      goto while_continue___9;
    }
    {
#line 412
    (d->file)->parent = file;
#line 413
    tmp___2 = check_dep(d->file, depth, this_mtime, & must_make);
#line 413
    dep_status |= tmp___2;
    }
    {
#line 414
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 414
      if (! ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0))) {
#line 414
        goto while_break___12;
      }
#line 414
      d->file = (d->file)->renamed;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 417
    f = d->file;
#line 418
    if (f->double_colon) {
#line 419
      f = f->double_colon;
    }
    {
#line 420
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 422
      if ((unsigned int )f->command_state == 2U) {
#line 422
        tmp___3 = 1;
      } else
#line 422
      if ((unsigned int )f->command_state == 1U) {
#line 422
        tmp___3 = 1;
      } else {
#line 422
        tmp___3 = 0;
      }
#line 422
      running |= tmp___3;
#line 424
      f = f->prev;
#line 420
      if (! ((unsigned long )f != (unsigned long )((struct file *)0))) {
#line 420
        goto while_break___13;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
#line 429
    if (dep_status != 0) {
#line 429
      if (! keep_going_flag) {
#line 430
        goto while_break___9;
      }
    }
#line 432
    if (! running) {
#line 433
      if ((d->file)->last_mtime != 0L) {
#line 433
        tmp___5 = (d->file)->last_mtime;
      } else {
        {
#line 433
        tmp___4 = f_mtime(d->file, 1);
#line 433
        tmp___5 = tmp___4;
        }
      }
#line 433
      d->changed = tmp___5 != mtime;
    }
#line 435
    lastd = d;
#line 436
    d = d->next;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 442
  if (must_make) {
#line 444
    d = file->deps;
    {
#line 444
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 444
      if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 444
        goto while_break___14;
      }
#line 445
      if ((d->file)->intermediate) {
#line 447
        if ((d->file)->last_mtime != 0L) {
#line 447
          tmp___7 = (d->file)->last_mtime;
        } else {
          {
#line 447
          tmp___6 = f_mtime(d->file, 1);
#line 447
          tmp___7 = tmp___6;
          }
        }
#line 447
        mtime___0 = tmp___7;
        {
#line 448
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 448
          if (! ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0))) {
#line 448
            goto while_break___15;
          }
#line 448
          d->file = (d->file)->renamed;
        }
        while_break___15: /* CIL Label */ ;
        }
        {
#line 449
        (d->file)->parent = file;
#line 450
        tmp___8 = update_file(d->file, depth);
#line 450
        dep_status |= tmp___8;
        }
        {
#line 451
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 451
          if (! ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0))) {
#line 451
            goto while_break___16;
          }
#line 451
          d->file = (d->file)->renamed;
        }
        while_break___16: /* CIL Label */ ;
        }
#line 454
        f___0 = d->file;
#line 455
        if (f___0->double_colon) {
#line 456
          f___0 = f___0->double_colon;
        }
        {
#line 457
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 459
          if ((unsigned int )f___0->command_state == 2U) {
#line 459
            tmp___9 = 1;
          } else
#line 459
          if ((unsigned int )f___0->command_state == 1U) {
#line 459
            tmp___9 = 1;
          } else {
#line 459
            tmp___9 = 0;
          }
#line 459
          running |= tmp___9;
#line 461
          f___0 = f___0->prev;
#line 457
          if (! ((unsigned long )f___0 != (unsigned long )((struct file *)0))) {
#line 457
            goto while_break___17;
          }
        }
        while_break___17: /* CIL Label */ ;
        }
#line 466
        if (dep_status != 0) {
#line 466
          if (! keep_going_flag) {
#line 467
            goto while_break___14;
          }
        }
#line 469
        if (! running) {
#line 470
          if (file->phony) {
#line 470
            if ((unsigned long )file->cmds != (unsigned long )((struct commands *)0)) {
#line 470
              tmp___12 = 1;
            } else {
#line 470
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 470
            if ((d->file)->last_mtime != 0L) {
#line 470
              tmp___11 = (d->file)->last_mtime;
            } else {
              {
#line 470
              tmp___10 = f_mtime(d->file, 1);
#line 470
              tmp___11 = tmp___10;
              }
            }
#line 470
            if (tmp___11 != mtime___0) {
#line 470
              tmp___12 = 1;
            } else {
#line 470
              tmp___12 = 0;
            }
          }
#line 470
          d->changed = tmp___12;
        }
      }
#line 444
      d = d->next;
    }
    while_break___14: /* CIL Label */ ;
    }
  }
#line 475
  file->updating = 0U;
  {
#line 477
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 477
    if (debug_flag) {
      {
#line 477
      print_spaces(depth);
#line 477
      printf((char const   */* __restrict  */)"Finished dependencies of target file `%s\'.\n",
             file->name);
#line 477
      fflush(stdout);
      }
    }
#line 477
    goto while_break___18;
  }
  while_break___18: /* CIL Label */ ;
  }
#line 479
  if (running) {
    {
#line 481
    set_command_state(file, 1);
#line 482
    depth --;
    }
    {
#line 483
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 483
      if (debug_flag) {
        {
#line 483
        print_spaces(depth);
#line 483
        printf((char const   */* __restrict  */)"The dependencies of `%s\' are being made.\n",
               file->name);
#line 483
        fflush(stdout);
        }
      }
#line 483
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 484
    return (0);
  }
#line 489
  if (dep_status != 0) {
    {
#line 491
    file->update_status = (short )dep_status;
#line 492
    notice_finished_file(file);
#line 494
    depth --;
    }
    {
#line 496
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 496
      if (debug_flag) {
        {
#line 496
        print_spaces(depth);
#line 496
        printf((char const   */* __restrict  */)"Giving up on target file `%s\'.\n",
               file->name);
#line 496
        fflush(stdout);
        }
      }
#line 496
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
#line 498
    if (depth == 0U) {
#line 498
      if (keep_going_flag) {
#line 498
        if (! just_print_flag) {
#line 498
          if (! question_flag) {
            {
#line 500
            error("Target `%s\' not remade because of errors.", file->name);
            }
          }
        }
      }
    }
#line 502
    return (dep_status);
  }
#line 505
  if ((unsigned int )file->command_state == 1U) {
    {
#line 514
    set_command_state(file, 0);
    }
  }
#line 519
  deps_changed = 0;
#line 520
  d = file->deps;
  {
#line 520
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 520
    if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 520
      goto while_break___21;
    }
#line 522
    if ((d->file)->last_mtime != 0L) {
#line 522
      tmp___14 = (d->file)->last_mtime;
    } else {
      {
#line 522
      tmp___13 = f_mtime(d->file, 1);
#line 522
      tmp___14 = tmp___13;
      }
    }
#line 522
    d_mtime = tmp___14;
    {
#line 523
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 523
      if (! ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0))) {
#line 523
        goto while_break___22;
      }
#line 523
      d->file = (d->file)->renamed;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 528
    if (d_mtime == -1L) {
#line 528
      if (! (d->file)->intermediate) {
#line 531
        must_make = 1;
      }
    }
#line 535
    deps_changed |= d->changed;
#line 539
    if (noexist) {
#line 539
      tmp___15 = 1;
    } else
#line 539
    if (d_mtime > this_mtime) {
#line 539
      tmp___15 = 1;
    } else {
#line 539
      tmp___15 = 0;
    }
#line 539
    d->changed |= tmp___15;
#line 541
    if (debug_flag) {
#line 541
      if (! noexist) {
        {
#line 543
        print_spaces(depth);
        }
#line 544
        if (d_mtime == -1L) {
#line 545
          if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 545
            tmp___16 = (d->file)->name;
          } else {
#line 545
            tmp___16 = d->name;
          }
          {
#line 545
          printf((char const   */* __restrict  */)"Dependency `%s\' does not exist.\n",
                 tmp___16);
          }
        } else {
#line 547
          if (d->changed) {
#line 547
            tmp___17 = "newer";
          } else {
#line 547
            tmp___17 = "older";
          }
#line 547
          if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 547
            tmp___18 = (d->file)->name;
          } else {
#line 547
            tmp___18 = d->name;
          }
          {
#line 547
          printf((char const   */* __restrict  */)"Dependency `%s\' is %s than dependent `%s\'.\n",
                 tmp___18, tmp___17, file->name);
          }
        }
        {
#line 549
        fflush(stdout);
        }
      }
    }
#line 520
    d = d->next;
  }
  while_break___21: /* CIL Label */ ;
  }
#line 554
  depth --;
#line 556
  if (file->double_colon) {
#line 556
    if ((unsigned long )file->deps == (unsigned long )((struct dep *)0)) {
#line 558
      must_make = 1;
      {
#line 559
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 559
        if (debug_flag) {
          {
#line 559
          print_spaces(depth);
#line 559
          printf((char const   */* __restrict  */)"Target `%s\' is double-colon and has no dependencies.\n",
                 file->name);
#line 559
          fflush(stdout);
          }
        }
#line 559
        goto while_break___23;
      }
      while_break___23: /* CIL Label */ ;
      }
    } else {
#line 556
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 561
  if (! noexist) {
#line 561
    if (file->is_target) {
#line 561
      if (! deps_changed) {
#line 561
        if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
#line 563
          must_make = 0;
          {
#line 564
          while (1) {
            while_continue___24: /* CIL Label */ ;
#line 564
            if (debug_flag) {
              {
#line 564
              print_spaces(depth);
#line 564
              printf((char const   */* __restrict  */)"No commands for `%s\' and no dependencies actually changed.\n",
                     file->name);
#line 564
              fflush(stdout);
              }
            }
#line 564
            goto while_break___24;
          }
          while_break___24: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 567
  if (! must_make) {
#line 569
    if (debug_flag) {
      {
#line 571
      print_spaces(depth);
#line 572
      printf((char const   */* __restrict  */)"No need to remake target `%s\'", file->name);
      }
#line 573
      if (! ((unsigned long )file->name == (unsigned long )file->hname)) {
#line 573
        if ((int )*(file->name) == (int )*(file->hname)) {
#line 573
          if (! ((int )*(file->name) == 0)) {
            {
#line 573
            tmp___19 = strcmp((char const   *)(file->name + 1), (char const   *)(file->hname + 1));
            }
#line 573
            if (tmp___19) {
              {
#line 574
              printf((char const   */* __restrict  */)"; using VPATH name `%s\'",
                     file->hname);
              }
            }
          }
        } else {
          {
#line 574
          printf((char const   */* __restrict  */)"; using VPATH name `%s\'", file->hname);
          }
        }
      }
      {
#line 575
      printf((char const   */* __restrict  */)".\n");
#line 576
      fflush(stdout);
      }
    }
    {
#line 579
    notice_finished_file(file);
    }
    {
#line 585
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 585
      if (! file) {
#line 585
        goto while_break___25;
      }
#line 587
      file->name = file->hname;
#line 588
      file = file->prev;
    }
    while_break___25: /* CIL Label */ ;
    }
#line 591
    return (0);
  }
  {
#line 594
  while (1) {
    while_continue___26: /* CIL Label */ ;
#line 594
    if (debug_flag) {
      {
#line 594
      print_spaces(depth);
#line 594
      printf((char const   */* __restrict  */)"Must remake target `%s\'.\n", file->name);
#line 594
      fflush(stdout);
      }
    }
#line 594
    goto while_break___26;
  }
  while_break___26: /* CIL Label */ ;
  }
#line 598
  if (! ((unsigned long )file->name == (unsigned long )file->hname)) {
#line 598
    if ((int )*(file->name) == (int )*(file->hname)) {
#line 598
      if (! ((int )*(file->name) == 0)) {
        {
#line 598
        tmp___20 = strcmp((char const   *)(file->name + 1), (char const   *)(file->hname + 1));
        }
#line 598
        if (tmp___20) {
#line 598
          goto _L___1;
        }
      }
    } else {
      _L___1: /* CIL Label */ 
#line 600
      if (debug_flag) {
        {
#line 602
        print_spaces(depth);
#line 603
        printf((char const   */* __restrict  */)"  Ignoring VPATH name `%s\'.\n",
               file->hname);
#line 604
        fflush(stdout);
        }
      }
#line 606
      file->ignore_vpath = 1U;
    }
  }
  {
#line 610
  remake_file(file);
  }
#line 612
  if ((unsigned int )file->command_state != 3U) {
    {
#line 614
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 614
      if (debug_flag) {
        {
#line 614
        print_spaces(depth);
#line 614
        printf((char const   */* __restrict  */)"Commands of `%s\' are being run.\n",
               file->name);
#line 614
        fflush(stdout);
        }
      }
#line 614
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
#line 615
    return (0);
  }
  {
#line 620
  if ((int )file->update_status == 2) {
#line 620
    goto case_2___0;
  }
#line 623
  if ((int )file->update_status == 0) {
#line 623
    goto case_0___0;
  }
#line 626
  if ((int )file->update_status == 1) {
#line 626
    goto case_1___0;
  }
#line 629
  goto switch_default___0;
  case_2___0: /* CIL Label */ 
  {
#line 621
  while (1) {
    while_continue___28: /* CIL Label */ ;
#line 621
    if (debug_flag) {
      {
#line 621
      print_spaces(depth);
#line 621
      printf((char const   */* __restrict  */)"Failed to remake target file `%s\'.\n",
             file->name);
#line 621
      fflush(stdout);
      }
    }
#line 621
    goto while_break___28;
  }
  while_break___28: /* CIL Label */ ;
  }
#line 622
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
  {
#line 624
  while (1) {
    while_continue___29: /* CIL Label */ ;
#line 624
    if (debug_flag) {
      {
#line 624
      print_spaces(depth);
#line 624
      printf((char const   */* __restrict  */)"Successfully remade target file `%s\'.\n",
             file->name);
#line 624
      fflush(stdout);
      }
    }
#line 624
    goto while_break___29;
  }
  while_break___29: /* CIL Label */ ;
  }
#line 625
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 627
  while (1) {
    while_continue___30: /* CIL Label */ ;
#line 627
    if (debug_flag) {
      {
#line 627
      print_spaces(depth);
#line 627
      printf((char const   */* __restrict  */)"Target file `%s\' needs remade under -q.\n",
             file->name);
#line 627
      fflush(stdout);
      }
    }
#line 627
    goto while_break___30;
  }
  while_break___30: /* CIL Label */ ;
  }
#line 628
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 630
  if ((int )file->update_status >= 0) {
#line 630
    if (! ((int )file->update_status <= 2)) {
      {
#line 630
      __assert_fail("file->update_status >= 0 && file->update_status <= 2", "/home/khheo/testset/make-3.76.1/remake.c",
                    630U, "update_file_1");
      }
    }
  } else {
    {
#line 630
    __assert_fail("file->update_status >= 0 && file->update_status <= 2", "/home/khheo/testset/make-3.76.1/remake.c",
                  630U, "update_file_1");
    }
  }
#line 631
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 634
  file->updated = 1U;
#line 635
  return ((int )file->update_status);
}
}
#line 644 "/home/khheo/testset/make-3.76.1/remake.c"
void notice_finished_file(struct file *file ) 
{ 
  struct dep *d ;
  int ran ;
  unsigned int i ;
  int tmp ;
  struct file *f ;

  {
#line 649
  ran = (unsigned int )file->command_state == 2U;
#line 651
  file->command_state = (enum __anonenum_command_state_55 )3;
#line 652
  file->updated = 1U;
#line 654
  if (touch_flag) {
#line 654
    if ((int )file->update_status == 0) {
#line 663
      if ((unsigned long )file->cmds != (unsigned long )((struct commands *)0)) {
#line 663
        if ((file->cmds)->any_recurse) {
#line 668
          i = 0U;
          {
#line 668
          while (1) {
            while_continue: /* CIL Label */ ;
#line 668
            if (! (i < (file->cmds)->ncommand_lines)) {
#line 668
              goto while_break;
            }
#line 669
            if (! ((int )*((file->cmds)->lines_flags + i) & 1)) {
#line 670
              goto have_nonrecursing;
            }
#line 668
            i ++;
          }
          while_break: /* CIL Label */ ;
          }
        } else {
#line 663
          goto have_nonrecursing;
        }
      } else
      have_nonrecursing: 
#line 675
      if (file->phony) {
#line 676
        file->update_status = (short)0;
      } else {
        {
#line 679
        tmp = touch_file(file);
#line 679
        file->update_status = (short )tmp;
        }
      }
    }
  }
#line 683
  if (ran) {
#line 683
    if (! file->phony) {
#line 687
      if (just_print_flag) {
#line 689
        file->last_mtime = -1L - (-1L << (sizeof(time_t ) * 8UL - 1UL));
      } else
#line 687
      if (question_flag) {
#line 689
        file->last_mtime = -1L - (-1L << (sizeof(time_t ) * 8UL - 1UL));
      } else
#line 687
      if (file->is_target) {
#line 687
        if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
#line 689
          file->last_mtime = -1L - (-1L << (sizeof(time_t ) * 8UL - 1UL));
        } else {
#line 691
          file->last_mtime = (time_t )0;
        }
      } else {
#line 691
        file->last_mtime = (time_t )0;
      }
#line 695
      f = file->double_colon;
      {
#line 695
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 695
        if (! ((unsigned long )f != (unsigned long )((struct file *)0))) {
#line 695
          goto while_break___0;
        }
#line 696
        f->last_mtime = file->last_mtime;
#line 695
        f = f->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 699
  if (ran) {
#line 699
    if ((int )file->update_status != -1) {
#line 704
      d = file->also_make;
      {
#line 704
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 704
        if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 704
          goto while_break___1;
        }
#line 706
        (d->file)->command_state = (enum __anonenum_command_state_55 )3;
#line 707
        (d->file)->updated = 1U;
#line 708
        (d->file)->update_status = file->update_status;
#line 710
        if (ran) {
#line 710
          if (! (d->file)->phony) {
            {
#line 715
            f_mtime(d->file, 0);
            }
          }
        }
#line 704
        d = d->next;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 699
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 717
  if ((int )file->update_status == -1) {
#line 720
    file->update_status = (short)0;
  }
#line 721
  return;
}
}
#line 730 "/home/khheo/testset/make-3.76.1/remake.c"
static int check_dep(struct file *file , unsigned int depth , time_t this_mtime ,
                     int *must_make_ptr ) 
{ 
  register struct dep *d ;
  int dep_status ;
  time_t mtime ;
  time_t tmp ;
  time_t mtime___0 ;
  int tmp___0 ;
  time_t tmp___1 ;
  register struct dep *lastd ;
  int tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 738
  dep_status = 0;
#line 740
  depth ++;
#line 741
  file->updating = 1U;
#line 743
  if (! file->intermediate) {
    {
#line 748
    dep_status = update_file(file, depth);
    }
    {
#line 749
    while (1) {
      while_continue: /* CIL Label */ ;
#line 749
      if (! ((unsigned long )file->renamed != (unsigned long )((struct file *)0))) {
#line 749
        goto while_break;
      }
#line 749
      file = file->renamed;
    }
    while_break: /* CIL Label */ ;
    }
#line 750
    if (file->last_mtime != 0L) {
#line 750
      mtime = file->last_mtime;
    } else {
      {
#line 750
      tmp = f_mtime(file, 1);
#line 750
      mtime = tmp;
      }
    }
    {
#line 751
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 751
      if (! ((unsigned long )file->renamed != (unsigned long )((struct file *)0))) {
#line 751
        goto while_break___0;
      }
#line 751
      file = file->renamed;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 752
    if (mtime == -1L) {
#line 753
      *must_make_ptr = 1;
    } else
#line 752
    if (mtime > this_mtime) {
#line 753
      *must_make_ptr = 1;
    }
  } else {
#line 760
    if (! file->phony) {
#line 760
      if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
#line 760
        if (! file->tried_implicit) {
#line 760
          if (file->secondary) {
            {
#line 763
            tmp___0 = try_implicit_rule(file, depth);
            }
#line 763
            if (tmp___0) {
              {
#line 764
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 764
                if (debug_flag) {
                  {
#line 764
                  print_spaces(depth);
#line 764
                  printf((char const   */* __restrict  */)"Found an implicit rule for `%s\'.\n",
                         file->name);
#line 764
                  fflush(stdout);
                  }
                }
#line 764
                goto while_break___1;
              }
              while_break___1: /* CIL Label */ ;
              }
            } else {
              {
#line 766
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 766
                if (debug_flag) {
                  {
#line 766
                  print_spaces(depth);
#line 766
                  printf((char const   */* __restrict  */)"No implicit rule found for `%s\'.\n",
                         file->name);
#line 766
                  fflush(stdout);
                  }
                }
#line 766
                goto while_break___2;
              }
              while_break___2: /* CIL Label */ ;
              }
            }
#line 767
            file->tried_implicit = 1U;
          }
        }
      }
    }
#line 769
    if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
#line 769
      if (! file->is_target) {
#line 769
        if (file->secondary) {
#line 769
          if ((unsigned long )default_file != (unsigned long )((struct file *)0)) {
#line 769
            if ((unsigned long )default_file->cmds != (unsigned long )((struct commands *)0)) {
              {
#line 772
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 772
                if (debug_flag) {
                  {
#line 772
                  print_spaces(depth);
#line 772
                  printf((char const   */* __restrict  */)"Using default commands for `%s\'.\n",
                         file->name);
#line 772
                  fflush(stdout);
                  }
                }
#line 772
                goto while_break___3;
              }
              while_break___3: /* CIL Label */ ;
              }
#line 773
              file->cmds = default_file->cmds;
            }
          }
        }
      }
    }
    {
#line 778
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 778
      if (! ((unsigned long )file->renamed != (unsigned long )((struct file *)0))) {
#line 778
        goto while_break___4;
      }
#line 778
      file = file->renamed;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 779
    if (file->last_mtime != 0L) {
#line 779
      mtime___0 = file->last_mtime;
    } else {
      {
#line 779
      tmp___1 = f_mtime(file, 1);
#line 779
      mtime___0 = tmp___1;
      }
    }
    {
#line 780
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 780
      if (! ((unsigned long )file->renamed != (unsigned long )((struct file *)0))) {
#line 780
        goto while_break___5;
      }
#line 780
      file = file->renamed;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 781
    if (mtime___0 != -1L) {
#line 781
      if (mtime___0 > this_mtime) {
#line 782
        *must_make_ptr = 1;
      } else {
#line 781
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 790
      lastd = (struct dep *)0;
#line 791
      d = file->deps;
      {
#line 792
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 792
        if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 792
          goto while_break___6;
        }
#line 794
        if ((d->file)->updating) {
          {
#line 796
          error("Circular %s <- %s dependency dropped.", file->name, (d->file)->name);
          }
#line 798
          if ((unsigned long )lastd == (unsigned long )((struct dep *)0)) {
            {
#line 800
            file->deps = d->next;
#line 801
            free((void *)((char *)d));
#line 802
            d = file->deps;
            }
          } else {
            {
#line 806
            lastd->next = d->next;
#line 807
            free((void *)((char *)d));
#line 808
            d = lastd->next;
            }
          }
#line 810
          goto while_continue___6;
        }
        {
#line 813
        (d->file)->parent = file;
#line 814
        tmp___2 = check_dep(d->file, depth, this_mtime, must_make_ptr);
#line 814
        dep_status |= tmp___2;
        }
        {
#line 815
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 815
          if (! ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0))) {
#line 815
            goto while_break___7;
          }
#line 815
          d->file = (d->file)->renamed;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 816
        if (dep_status != 0) {
#line 816
          if (! keep_going_flag) {
#line 817
            goto while_break___6;
          }
        }
#line 819
        if ((unsigned int )(d->file)->command_state == 2U) {
          {
#line 824
          set_command_state(file, 1);
          }
        } else
#line 819
        if ((unsigned int )(d->file)->command_state == 1U) {
          {
#line 824
          set_command_state(file, 1);
          }
        }
#line 826
        lastd = d;
#line 827
        d = d->next;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
  }
#line 832
  file->updating = 0U;
#line 833
  return (dep_status);
}
}
#line 840 "/home/khheo/testset/make-3.76.1/remake.c"
static int touch_file(struct file *file ) 
{ 
  int tmp ;
  int fd ;
  int tmp___0 ;
  struct stat statbuf ;
  char buf___0 ;
  int status ;
  int *tmp___1 ;
  ssize_t tmp___2 ;
  __off_t tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 844
  if (! silent_flag) {
    {
#line 845
    message(0, "touch %s", file->name);
    }
  }
  {
#line 848
  tmp___5 = ar_name(file->name);
  }
#line 848
  if (tmp___5) {
    {
#line 849
    tmp = ar_touch(file->name);
    }
#line 849
    return (tmp);
  } else {
    {
#line 853
    tmp___0 = open((char const   *)file->name, 66, 438);
#line 853
    fd = tmp___0;
    }
#line 855
    if (fd < 0) {
      {
#line 856
      perror_with_name("touch: open: ", file->name);
      }
#line 856
      return (1);
    } else {
      {
#line 864
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 866
        status = fstat(fd, & statbuf);
        }
#line 864
        if (status < 0) {
          {
#line 864
          tmp___1 = __errno_location();
          }
#line 864
          if (! (*tmp___1 == 4)) {
#line 864
            goto while_break;
          }
        } else {
#line 864
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 870
      if (status < 0) {
        {
#line 871
        perror_with_name("touch: fstat: ", file->name);
        }
#line 871
        return (1);
      }
      {
#line 873
      tmp___2 = read(fd, (void *)(& buf___0), (size_t )1);
      }
#line 873
      if (tmp___2 < 0L) {
        {
#line 874
        perror_with_name("touch: read: ", file->name);
        }
#line 874
        return (1);
      }
      {
#line 875
      tmp___3 = lseek(fd, 0L, 0);
      }
#line 875
      if (tmp___3 < 0L) {
        {
#line 876
        perror_with_name("touch: lseek: ", file->name);
        }
#line 876
        return (1);
      }
      {
#line 877
      tmp___4 = write(fd, (void const   *)(& buf___0), (size_t )1);
      }
#line 877
      if (tmp___4 < 0L) {
        {
#line 878
        perror_with_name("touch: write: ", file->name);
        }
#line 878
        return (1);
      }
#line 881
      if (statbuf.st_size == 0L) {
        {
#line 883
        close(fd);
#line 884
        fd = open((char const   *)file->name, 514, 438);
        }
#line 885
        if (fd < 0) {
          {
#line 886
          perror_with_name("touch: open: ", file->name);
          }
#line 886
          return (1);
        }
      }
      {
#line 888
      close(fd);
      }
    }
  }
#line 892
  return (0);
}
}
#line 915 "/home/khheo/testset/make-3.76.1/remake.c"
static char const   msg_noparent[32]  = 
#line 915
  {      (char const   )'%',      (char const   )'s',      (char const   )'N',      (char const   )'o', 
        (char const   )' ',      (char const   )'r',      (char const   )'u',      (char const   )'l', 
        (char const   )'e',      (char const   )' ',      (char const   )'t',      (char const   )'o', 
        (char const   )' ',      (char const   )'m',      (char const   )'a',      (char const   )'k', 
        (char const   )'e',      (char const   )' ',      (char const   )'t',      (char const   )'a', 
        (char const   )'r',      (char const   )'g',      (char const   )'e',      (char const   )'t', 
        (char const   )' ',      (char const   )'`',      (char const   )'%',      (char const   )'s', 
        (char const   )'\'',      (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 917 "/home/khheo/testset/make-3.76.1/remake.c"
static char const   msg_parent[48]  = 
#line 917
  {      (char const   )'%',      (char const   )'s',      (char const   )'N',      (char const   )'o', 
        (char const   )' ',      (char const   )'r',      (char const   )'u',      (char const   )'l', 
        (char const   )'e',      (char const   )' ',      (char const   )'t',      (char const   )'o', 
        (char const   )' ',      (char const   )'m',      (char const   )'a',      (char const   )'k', 
        (char const   )'e',      (char const   )' ',      (char const   )'t',      (char const   )'a', 
        (char const   )'r',      (char const   )'g',      (char const   )'e',      (char const   )'t', 
        (char const   )' ',      (char const   )'`',      (char const   )'%',      (char const   )'s', 
        (char const   )'\'',      (char const   )',',      (char const   )' ',      (char const   )'n', 
        (char const   )'e',      (char const   )'e',      (char const   )'d',      (char const   )'e', 
        (char const   )'d',      (char const   )' ',      (char const   )'b',      (char const   )'y', 
        (char const   )' ',      (char const   )'`',      (char const   )'%',      (char const   )'s', 
        (char const   )'\'',      (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 899 "/home/khheo/testset/make-3.76.1/remake.c"
static void remake_file(struct file *file ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 903
  if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
#line 905
    if (file->phony) {
#line 907
      file->update_status = (short)0;
    } else
#line 908
    if (file->is_target) {
#line 911
      file->update_status = (short)0;
    } else
#line 919
    if (keep_going_flag) {
#line 919
      goto _L;
    } else
#line 919
    if (file->dontcare) {
      _L: /* CIL Label */ 
#line 921
      if (! file->dontcare) {
#line 923
        if ((unsigned long )file->parent == (unsigned long )((struct file *)0)) {
          {
#line 924
          error(msg_noparent, "*** ", file->name, ".");
          }
        } else {
          {
#line 926
          error(msg_parent, "*** ", file->name, (file->parent)->name, ".");
          }
        }
      }
#line 929
      file->update_status = (short)2;
    } else
#line 933
    if ((unsigned long )file->parent == (unsigned long )((struct file *)0)) {
      {
#line 934
      fatal(msg_noparent, "", file->name, "");
      }
    } else {
      {
#line 936
      fatal(msg_parent, "", file->name, (file->parent)->name, "");
      }
    }
  } else {
    {
#line 942
    chop_commands(file->cmds);
    }
#line 944
    if (! touch_flag) {
      {
#line 946
      execute_file_commands(file);
      }
#line 947
      return;
    } else
#line 944
    if ((file->cmds)->any_recurse) {
      {
#line 946
      execute_file_commands(file);
      }
#line 947
      return;
    } else {
#line 951
      file->update_status = (short)0;
    }
  }
  {
#line 955
  notice_finished_file(file);
  }
#line 956
  return;
}
}
#line 1077 "/home/khheo/testset/make-3.76.1/remake.c"
static time_t now  =    (time_t )0;
#line 966 "/home/khheo/testset/make-3.76.1/remake.c"
time_t f_mtime(struct file *file , int search ) 
{ 
  time_t mtime ;
  char *arname ;
  char *memname ;
  struct file *arfile ;
  int arname_used ;
  unsigned int arlen ;
  unsigned int memlen ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *name___0 ;
  time_t tmp___3 ;
  time_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp23 ;

  {
  {
#line 976
  tmp___10 = ar_name(file->name);
  }
#line 976
  if (tmp___10) {
    {
#line 982
    arname_used = 0;
#line 985
    ar_parse_name(file->name, & arname, & memname);
#line 989
    arfile = lookup_file(arname);
    }
#line 990
    if ((unsigned long )arfile == (unsigned long )((struct file *)0)) {
      {
#line 992
      arfile = enter_file(arname);
#line 993
      arname_used = 1;
      }
    }
    {
#line 995
    mtime = f_mtime(arfile, search);
    }
    {
#line 996
    while (1) {
      while_continue: /* CIL Label */ ;
#line 996
      if (! ((unsigned long )arfile->renamed != (unsigned long )((struct file *)0))) {
#line 996
        goto while_break;
      }
#line 996
      arfile = arfile->renamed;
    }
    while_break: /* CIL Label */ ;
    }
#line 997
    if (search) {
      {
#line 997
      tmp___2 = strcmp((char const   *)arfile->name, (char const   *)arname);
      }
#line 997
      if (tmp___2) {
#line 1004
        if (! arname_used) {
          {
#line 1006
          free((void *)arname);
#line 1007
          arname_used = 1;
          }
        }
        {
#line 1010
        arname = arfile->name;
#line 1011
        tmp = strlen((char const   *)arname);
#line 1011
        arlen = (unsigned int )tmp;
#line 1012
        tmp___0 = strlen((char const   *)memname);
#line 1012
        memlen = (unsigned int )tmp___0;
#line 1014
        free((void *)file->name);
#line 1016
        tmp___1 = xmalloc(((arlen + 1U) + memlen) + 2U);
#line 1016
        file->name = tmp___1;
#line 1017
        memmove((void *)file->name, (void const   *)arname, (size_t )arlen);
#line 1018
        *(file->name + arlen) = (char )'(';
#line 1019
        memmove((void *)((file->name + arlen) + 1), (void const   *)memname, (size_t )memlen);
#line 1020
        *(file->name + ((arlen + 1U) + memlen)) = (char )')';
#line 1021
        *(file->name + (((arlen + 1U) + memlen) + 1U)) = (char )'\000';
        }
      }
    }
#line 1024
    if (! arname_used) {
      {
#line 1025
      free((void *)arname);
      }
    }
    {
#line 1026
    free((void *)memname);
    }
#line 1028
    if (mtime == -1L) {
#line 1030
      return ((time_t )-1);
    }
    {
#line 1032
    mtime = ar_member_date(file->name);
    }
  } else {
    {
#line 1037
    mtime = name_mtime(file->name);
    }
#line 1039
    if (mtime == -1L) {
#line 1039
      if (search) {
#line 1039
        if (! file->ignore_vpath) {
          {
#line 1042
          name___0 = file->name;
#line 1043
          tmp___8 = vpath_search(& name___0, & mtime);
          }
#line 1043
          if (tmp___8) {
#line 1043
            goto _L;
          } else
#line 1043
          if ((int )*(name___0 + 0) == 45) {
#line 1043
            if ((int )*(name___0 + 1) == 108) {
              {
#line 1043
              tmp___9 = library_search(& name___0, & mtime);
              }
#line 1043
              if (tmp___9) {
                _L: /* CIL Label */ 
#line 1048
                if (mtime != 0L) {
#line 1051
                  file->last_mtime = mtime;
                }
                {
#line 1056
                tmp___5 = strlen((char const   *)name___0);
#line 1056
                tmp___6 = strlen((char const   *)file->name);
#line 1056
                tmp___7 = gpath_search(name___0, (tmp___5 - tmp___6) - 1UL);
                }
#line 1056
                if (tmp___7) {
                  {
#line 1058
                  rename_file(file, name___0);
                  }
                  {
#line 1059
                  while (1) {
                    while_continue___0: /* CIL Label */ ;
#line 1059
                    if (! ((unsigned long )file->renamed != (unsigned long )((struct file *)0))) {
#line 1059
                      goto while_break___0;
                    }
#line 1059
                    file = file->renamed;
                  }
                  while_break___0: /* CIL Label */ ;
                  }
#line 1060
                  if (file->last_mtime != 0L) {
#line 1060
                    tmp___4 = file->last_mtime;
                  } else {
                    {
#line 1060
                    tmp___3 = f_mtime(file, 1);
#line 1060
                    tmp___4 = tmp___3;
                    }
                  }
#line 1060
                  return (tmp___4);
                }
                {
#line 1063
                rehash_file(file, name___0);
                }
                {
#line 1064
                while (1) {
                  while_continue___1: /* CIL Label */ ;
#line 1064
                  if (! ((unsigned long )file->renamed != (unsigned long )((struct file *)0))) {
#line 1064
                    goto while_break___1;
                  }
#line 1064
                  file = file->renamed;
                }
                while_break___1: /* CIL Label */ ;
                }
                {
#line 1065
                mtime = name_mtime(name___0);
                }
              }
            }
          }
        }
      }
    }
  }
#line 1078
  if (! clock_skew_detected) {
#line 1078
    if (mtime != -1L) {
#line 1078
      if (mtime > now) {
#line 1078
        if (! file->updated) {
          {
#line 1086
          time(& now);
          }
#line 1099
          if (mtime > now) {
            {
#line 1102
            error("*** Warning: File `%s\' has modification time in the future", file->name);
#line 1104
            clock_skew_detected = 1;
            }
          }
        }
      }
    }
  }
#line 1110
  if (file->double_colon) {
#line 1111
    file = file->double_colon;
  }
  {
#line 1112
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1114
    file->last_mtime = mtime;
#line 1115
    file = file->prev;
#line 1112
    if (! ((unsigned long )file != (unsigned long )((struct file *)0))) {
#line 1112
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1118
  return (mtime);
}
}
#line 1124 "/home/khheo/testset/make-3.76.1/remake.c"
static time_t name_mtime(char *name___0 ) 
{ 
  struct stat st ;
  int tmp ;

  {
  {
#line 1130
  tmp = stat((char const   */* __restrict  */)name___0, (struct stat */* __restrict  */)(& st));
  }
#line 1130
  if (tmp < 0) {
#line 1131
    return ((time_t )-1);
  }
#line 1133
  return (st.st_mtim.tv_sec);
}
}
#line 1146 "/home/khheo/testset/make-3.76.1/remake.c"
static char *dirs[4]  = {      (char *)"/lib",      (char *)"/usr/lib",      (char *)"/usr/local/lib",      (char *)0};
#line 1141 "/home/khheo/testset/make-3.76.1/remake.c"
static int library_search(char **lib , time_t *mtime_ptr ) 
{ 
  char *libname ;
  time_t mtime ;
  char *buf___0 ;
  size_t tmp ;
  char *tmp___0 ;
  char *file ;
  char **dp ;
  int tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 1163
  libname = *lib + 2;
#line 1167
  tmp = strlen((char const   *)libname);
#line 1167
  tmp___0 = xmalloc(((((sizeof("/usr/local/lib") + 8UL) + tmp) + 4UL) + 2UL) + 1UL);
#line 1167
  buf___0 = tmp___0;
#line 1173
  sprintf((char */* __restrict  */)buf___0, (char const   */* __restrict  */)"lib%s.a",
          libname);
#line 1177
  mtime = name_mtime(buf___0);
  }
#line 1178
  if (mtime != -1L) {
#line 1180
    *lib = buf___0;
#line 1181
    if ((unsigned long )mtime_ptr != (unsigned long )((time_t *)0)) {
#line 1182
      *mtime_ptr = mtime;
    }
#line 1183
    return (1);
  }
  {
#line 1188
  file = buf___0;
#line 1189
  tmp___1 = vpath_search(& file, mtime_ptr);
  }
#line 1189
  if (tmp___1) {
    {
#line 1191
    free((void *)buf___0);
#line 1192
    *lib = file;
    }
#line 1193
    return (1);
  }
#line 1222
  dp = dirs;
  {
#line 1222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1222
    if (! ((unsigned long )*dp != (unsigned long )((char *)0))) {
#line 1222
      goto while_break;
    }
    {
#line 1225
    sprintf((char */* __restrict  */)buf___0, (char const   */* __restrict  */)"%s/lib%s.a",
            *dp, libname);
#line 1229
    mtime = name_mtime(buf___0);
    }
#line 1230
    if (mtime != -1L) {
#line 1232
      *lib = buf___0;
#line 1233
      if ((unsigned long )mtime_ptr != (unsigned long )((time_t *)0)) {
#line 1234
        *mtime_ptr = mtime;
      }
#line 1235
      return (1);
    }
#line 1222
    dp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1239
  free((void *)buf___0);
  }
#line 1240
  return (0);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 849 "/usr/include/unistd.h"
extern char *getlogin(void) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int errnum ) ;
#line 322 "/home/khheo/testset/make-3.76.1/make.h"
void pfatal_with_name(char *name___0 ) ;
#line 331
void collapse_continuations(char *line ) ;
#line 332
void remove_comments(char *line ) ;
#line 338
char *find_char_unquote(char *string , char *stopchars , int blank ) ;
#line 368
void construct_include_path(char **arg_dirs ) ;
#line 369
void uniquize_deps(struct dep *chain ) ;
#line 406 "/home/khheo/testset/make-3.76.1/make.h"
char *reading_filename  ;
#line 407 "/home/khheo/testset/make-3.76.1/make.h"
unsigned int *reading_lineno_ptr  ;
#line 49 "/home/khheo/testset/make-3.76.1/dep.h"
char *tilde_expand(char *name___0 ) ;
#line 62
struct dep *read_all_makefiles(char **makefiles___0 ) ;
#line 89 "/home/khheo/testset/make-3.76.1/filedef.h"
struct file *default_goal_file ;
#line 110 "/home/khheo/testset/make-3.76.1/glob/glob.h"
extern int glob(char const   *__pattern , int __flags , int (*__errfunc)(char const   * ,
                                                                         int  ) ,
                glob_t *__pglob ) ;
#line 115
extern void globfree(glob_t *__pglob ) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 76 "/home/khheo/testset/make-3.76.1/read.c"
static struct conditionals toplevel_conditionals  ;
#line 77 "/home/khheo/testset/make-3.76.1/read.c"
static struct conditionals *conditionals  =    & toplevel_conditionals;
#line 82 "/home/khheo/testset/make-3.76.1/read.c"
static char *default_include_directories[5]  = {      (char *)"/usr/local/include",      (char *)"/usr/gnu/include",      (char *)"/usr/local/include",      (char *)"/usr/include", 
        (char *)0};
#line 102 "/home/khheo/testset/make-3.76.1/read.c"
static char **include_directories  ;
#line 106 "/home/khheo/testset/make-3.76.1/read.c"
static unsigned int max_incl_len  ;
#line 116 "/home/khheo/testset/make-3.76.1/read.c"
static struct dep *read_makefiles  =    (struct dep *)0;
#line 118
static int read_makefile(char *filename , int flags ) ;
#line 119
static unsigned int readline(struct linebuffer *linebuffer , FILE *stream , char *filename ,
                             unsigned int lineno ) ;
#line 121
static unsigned int do_define(char *name___0 , unsigned int namelen , enum variable_origin origin ,
                              unsigned int lineno , FILE *infile , char *filename ) ;
#line 123
static int conditional_line(char *line , char *filename , unsigned int lineno ) ;
#line 124
static void record_files(struct nameseq *filenames , char *pattern , char *pattern_percent ,
                         struct dep *deps , unsigned int commands_started___0 , char *commands ,
                         unsigned int commands_idx , int two_colon , char *filename ,
                         unsigned int lineno , int set_default ) ;
#line 200 "/home/khheo/testset/make-3.76.1/read.c"
static char *default_makefiles[4]  = {      (char *)"GNUmakefile",      (char *)"makefile",      (char *)"Makefile",      (char *)0};
#line 131 "/home/khheo/testset/make-3.76.1/read.c"
struct dep *read_all_makefiles(char **makefiles___0 ) 
{ 
  unsigned int num_makefiles ;
  char *value ;
  char *name___0 ;
  char *p ;
  unsigned int length___0 ;
  int save ;
  char *tmp ;
  struct dep *tail ;
  register struct dep *d ;
  int tmp___0 ;
  register char **p___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct dep *tail___0 ;
  struct dep *d___0 ;
  char *tmp___3 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 135
  num_makefiles = 0U;
#line 137
  if (debug_flag) {
    {
#line 138
    puts("Reading makefiles...");
    }
  }
  {
#line 151
  save = warn_undefined_variables_flag;
#line 152
  warn_undefined_variables_flag = 0;
#line 154
  value = allocated_variable_expand_for_file((char *)"$(MAKEFILES)", (struct file *)0);
#line 156
  warn_undefined_variables_flag = save;
#line 161
  p = value;
  }
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 163
    name___0 = find_next_token(& p, & length___0);
    }
#line 163
    if (! ((unsigned long )name___0 != (unsigned long )((char *)0))) {
#line 163
      goto while_break;
    }
#line 165
    if ((int )*p != 0) {
#line 166
      tmp = p;
#line 166
      p ++;
#line 166
      *tmp = (char )'\000';
    }
    {
#line 167
    read_makefile(name___0, (1 | (1 << 1)) | (1 << 2));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 171
  free((void *)value);
  }
#line 176
  if ((unsigned long )makefiles___0 != (unsigned long )((char **)0)) {
    {
#line 177
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 177
      if (! ((unsigned long )*makefiles___0 != (unsigned long )((char *)0))) {
#line 177
        goto while_break___0;
      }
      {
#line 179
      tail = read_makefiles;
#line 182
      tmp___0 = read_makefile(*makefiles___0, 0);
      }
#line 182
      if (! tmp___0) {
        {
#line 183
        perror_with_name("", *makefiles___0);
        }
      }
#line 186
      d = read_makefiles;
      {
#line 187
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 187
        if (! ((unsigned long )d->next != (unsigned long )tail)) {
#line 187
          goto while_break___1;
        }
#line 188
        d = d->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 191
      if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 191
        *makefiles___0 = (d->file)->name;
      } else {
#line 191
        *makefiles___0 = d->name;
      }
#line 192
      num_makefiles ++;
#line 193
      makefiles___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 198
  if (num_makefiles == 0U) {
#line 211
    p___0 = default_makefiles;
    {
#line 212
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 212
      if ((unsigned long )*p___0 != (unsigned long )((char *)0)) {
        {
#line 212
        tmp___1 = file_exists_p(*p___0);
        }
#line 212
        if (tmp___1) {
#line 212
          goto while_break___2;
        }
      } else {
#line 212
        goto while_break___2;
      }
#line 213
      p___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 215
    if ((unsigned long )*p___0 != (unsigned long )((char *)0)) {
      {
#line 217
      tmp___2 = read_makefile(*p___0, 0);
      }
#line 217
      if (! tmp___2) {
        {
#line 218
        perror_with_name("", *p___0);
        }
      }
    } else {
#line 224
      tail___0 = read_makefiles;
      {
#line 226
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 226
        if ((unsigned long )tail___0 != (unsigned long )((struct dep *)0)) {
#line 226
          if (! ((unsigned long )tail___0->next != (unsigned long )((struct dep *)0))) {
#line 226
            goto while_break___3;
          }
        } else {
#line 226
          goto while_break___3;
        }
#line 227
        tail___0 = tail___0->next;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 228
      p___0 = default_makefiles;
      {
#line 228
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 228
        if (! ((unsigned long )*p___0 != (unsigned long )((char *)0))) {
#line 228
          goto while_break___4;
        }
        {
#line 230
        tmp___3 = xmalloc(sizeof(struct dep ));
#line 230
        d___0 = (struct dep *)tmp___3;
#line 231
        d___0->name = (char *)0;
#line 232
        d___0->file = enter_file(*p___0);
#line 233
        (d___0->file)->dontcare = 1U;
#line 236
        d___0->changed = 1 << 2;
        }
#line 237
        if ((unsigned long )tail___0 == (unsigned long )((struct dep *)0)) {
#line 238
          read_makefiles = d___0;
        } else {
#line 240
          tail___0->next = d___0;
        }
#line 241
        tail___0 = d___0;
#line 228
        p___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 243
      if ((unsigned long )tail___0 != (unsigned long )((struct dep *)0)) {
#line 244
        tail___0->next = (struct dep *)0;
      }
    }
  }
#line 248
  return (read_makefiles);
}
}
#line 264 "/home/khheo/testset/make-3.76.1/read.c"
static char *collapsed  =    (char *)0;
#line 265 "/home/khheo/testset/make-3.76.1/read.c"
static unsigned int collapsed_length  =    0U;
#line 259 "/home/khheo/testset/make-3.76.1/read.c"
static int read_makefile(char *filename , int flags ) 
{ 
  register FILE *infile ;
  struct linebuffer lb ;
  unsigned int commands_len ;
  char *commands ;
  char *tmp ;
  unsigned int commands_idx ;
  unsigned int commands_started___0 ;
  register char *p ;
  char *p2 ;
  int len ;
  int ignoring ;
  int in_ignored_define ;
  int no_targets ;
  char *passed_filename ;
  struct nameseq *filenames ;
  struct dep *deps ;
  unsigned int lineno ;
  unsigned int nlines ;
  int two_colon ;
  char *pattern ;
  char *pattern_percent ;
  int makefile_errno ;
  char *expanded ;
  char *tmp___0 ;
  int *tmp___1 ;
  register unsigned int i ;
  char *name___0 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  unsigned int len___0 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  unsigned int tmp___10 ;
  char *tmp___11 ;
  unsigned short const   **tmp___12 ;
  unsigned short const   **tmp___13 ;
  unsigned short const   **tmp___14 ;
  int i___0 ;
  int tmp___15 ;
  unsigned short const   **tmp___16 ;
  unsigned short const   **tmp___17 ;
  struct variable *tmp___18 ;
  int tmp___19 ;
  unsigned short const   **tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  struct variable *v ;
  unsigned int len___1 ;
  unsigned int len___2 ;
  struct variable *v___0 ;
  char *pattern___0 ;
  unsigned int len___3 ;
  struct conditionals *save ;
  struct conditionals new_conditionals ;
  struct nameseq *files___0 ;
  int noerror ;
  int tmp___30 ;
  char *tmp___31 ;
  char const   *tmp___32 ;
  struct nameseq *tmp___33 ;
  struct nameseq *next ;
  char *name___1 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  unsigned short const   **tmp___38 ;
  char *cmdleft ;
  struct nameseq *tmp___39 ;
  char *tmp___40 ;
  register char *q ;
  register int backslash ;
  char *tmp___41 ;
  struct nameseq *target ;
  struct nameseq *tmp___42 ;
  struct nameseq *tmp___43 ;
  unsigned int len___4 ;
  size_t tmp___44 ;
  char *tmp___45 ;
  unsigned int tmp___46 ;
  struct variable *tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;

  {
  {
#line 268
  commands_len = 200U;
#line 269
  tmp = xmalloc(200);
#line 269
  commands = tmp;
#line 270
  commands_idx = 0U;
#line 275
  ignoring = 0;
#line 275
  in_ignored_define = 0;
#line 276
  no_targets = 0;
#line 277
  passed_filename = filename;
#line 279
  filenames = (struct nameseq *)0;
#line 281
  lineno = 1U;
#line 282
  nlines = 0U;
#line 284
  pattern = (char *)0;
#line 307
  pattern_percent = (char *)0;
#line 308
  commands_started___0 = lineno;
  }
#line 310
  if (debug_flag) {
    {
#line 312
    printf((char const   */* __restrict  */)"Reading makefile `%s\'", filename);
    }
#line 313
    if (flags & 1) {
      {
#line 314
      printf((char const   */* __restrict  */)" (no default goal)");
      }
    }
#line 315
    if (flags & (1 << 1)) {
      {
#line 316
      printf((char const   */* __restrict  */)" (search path)");
      }
    }
#line 317
    if (flags & (1 << 2)) {
      {
#line 318
      printf((char const   */* __restrict  */)" (don\'t care)");
      }
    }
#line 319
    if (flags & (1 << 3)) {
      {
#line 320
      printf((char const   */* __restrict  */)" (no ~ expansion)");
      }
    }
    {
#line 321
    puts("...");
    }
  }
#line 328
  if (! (flags & (1 << 3))) {
#line 328
    if ((int )*(filename + 0) == 126) {
      {
#line 330
      tmp___0 = tilde_expand(filename);
#line 330
      expanded = tmp___0;
      }
#line 331
      if ((unsigned long )expanded != (unsigned long )((char *)0)) {
#line 332
        filename = expanded;
      }
    }
  }
  {
#line 335
  infile = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
#line 337
  tmp___1 = __errno_location();
#line 337
  makefile_errno = *tmp___1;
  }
#line 342
  if ((unsigned long )infile == (unsigned long )((FILE *)0)) {
#line 342
    if (flags & (1 << 1)) {
#line 342
      if ((int )*filename != 47) {
#line 345
        i = 0U;
        {
#line 345
        while (1) {
          while_continue: /* CIL Label */ ;
#line 345
          if (! ((unsigned long )*(include_directories + i) != (unsigned long )((char *)0))) {
#line 345
            goto while_break;
          }
          {
#line 347
          tmp___2 = concat(*(include_directories + i), "/", filename);
#line 347
          name___0 = tmp___2;
#line 348
          infile = fopen((char const   */* __restrict  */)name___0, (char const   */* __restrict  */)"r");
          }
#line 349
          if ((unsigned long )infile == (unsigned long )((FILE *)0)) {
            {
#line 350
            free((void *)name___0);
            }
          } else {
#line 353
            filename = name___0;
#line 354
            goto while_break;
          }
#line 345
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 360
  tmp___3 = xmalloc(sizeof(struct dep ));
#line 360
  deps = (struct dep *)tmp___3;
#line 361
  deps->next = read_makefiles;
#line 362
  read_makefiles = deps;
#line 363
  deps->name = (char *)0;
#line 364
  deps->file = lookup_file(filename);
  }
#line 365
  if ((unsigned long )deps->file == (unsigned long )((struct file *)0)) {
    {
#line 367
    tmp___4 = strlen((char const   *)filename);
#line 367
    tmp___5 = savestring(filename, tmp___4);
#line 367
    deps->file = enter_file(tmp___5);
    }
#line 368
    if (flags & (1 << 2)) {
#line 369
      (deps->file)->dontcare = 1U;
    }
  }
#line 371
  if ((unsigned long )filename != (unsigned long )passed_filename) {
    {
#line 372
    free((void *)filename);
    }
  }
#line 373
  filename = (deps->file)->name;
#line 374
  deps->changed = flags;
#line 375
  deps = (struct dep *)0;
#line 379
  if ((unsigned long )infile == (unsigned long )((FILE *)0)) {
    {
#line 384
    tmp___6 = __errno_location();
#line 384
    *tmp___6 = makefile_errno;
    }
#line 385
    return (0);
  }
  {
#line 388
  reading_filename = filename;
#line 389
  reading_lineno_ptr = & lineno;
#line 396
  lb.size = 200U;
#line 396
  tmp___7 = xmalloc(lb.size);
#line 396
  lb.buffer = tmp___7;
  }
  {
#line 398
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 398
    tmp___54 = feof(infile);
    }
#line 398
    if (tmp___54) {
#line 398
      goto while_break___0;
    }
    {
#line 400
    lineno += nlines;
#line 401
    nlines = readline(& lb, infile, filename, lineno);
    }
#line 405
    if ((int )*(lb.buffer + 0) == 9) {
#line 410
      if (no_targets) {
#line 412
        goto while_continue___0;
      }
#line 418
      if ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
#line 420
        if (ignoring) {
#line 422
          goto while_continue___0;
        }
#line 425
        p = lb.buffer;
#line 426
        if (commands_idx == 0U) {
#line 427
          commands_started___0 = lineno;
        }
        {
#line 428
        tmp___8 = strlen((char const   *)p);
#line 428
        len___0 = (unsigned int )tmp___8;
        }
#line 429
        if ((len___0 + 1U) + commands_idx > commands_len) {
          {
#line 431
          commands_len = ((len___0 + 1U) + commands_idx) * 2U;
#line 432
          tmp___9 = xrealloc(commands, commands_len);
#line 432
          commands = tmp___9;
          }
        }
        {
#line 434
        memmove((void *)(commands + commands_idx), (void const   *)p, (size_t )len___0);
#line 435
        commands_idx += len___0;
#line 436
        tmp___10 = commands_idx;
#line 436
        commands_idx ++;
#line 436
        *(commands + tmp___10) = (char )'\n';
        }
#line 438
        goto while_continue___0;
      }
    }
#line 444
    if (collapsed_length < lb.size) {
#line 446
      collapsed_length = lb.size;
#line 447
      if ((unsigned long )collapsed != (unsigned long )((char *)0)) {
        {
#line 448
        free((void *)collapsed);
        }
      }
      {
#line 449
      tmp___11 = xmalloc(collapsed_length);
#line 449
      collapsed = tmp___11;
      }
    }
    {
#line 451
    strcpy((char */* __restrict  */)collapsed, (char const   */* __restrict  */)lb.buffer);
#line 453
    collapse_continuations(collapsed);
#line 454
    remove_comments(collapsed);
#line 458
    p = collapsed;
    }
    {
#line 459
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 459
      tmp___12 = __ctype_b_loc();
      }
#line 459
      if (! ((int const   )*(*tmp___12 + (int )*p) & 8192)) {
#line 459
        goto while_break___1;
      }
#line 460
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 461
    if ((int )*p == 0) {
#line 463
      goto while_continue___0;
    }
#line 466
    p2 = p + 1;
    {
#line 466
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 466
      if ((int )*p2 != 0) {
        {
#line 466
        tmp___13 = __ctype_b_loc();
        }
#line 466
        if ((int const   )*(*tmp___13 + (int )*p2) & 8192) {
#line 466
          goto while_break___2;
        }
      } else {
#line 466
        goto while_break___2;
      }
#line 466
      p2 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 468
    len = (int )(p2 - p);
    {
#line 473
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 473
      tmp___14 = __ctype_b_loc();
      }
#line 473
      if (! ((int const   )*(*tmp___14 + (int )*p2) & 8192)) {
#line 473
        goto while_break___3;
      }
#line 474
      p2 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 475
    if ((int )*p2 == 0) {
#line 476
      p2 = (char *)((void *)0);
    } else
#line 477
    if ((int )*(p2 + 0) == 58) {
#line 477
      if ((int )*(p2 + 1) == 0) {
#line 478
        goto check_var;
      }
    }
#line 484
    if (! in_ignored_define) {
#line 484
      if (len == 5) {
        {
#line 484
        tmp___24 = strncmp("ifdef", (char const   *)p, (size_t )5);
        }
#line 484
        if (tmp___24) {
#line 484
          goto _L___9;
        } else {
#line 484
          goto _L___4;
        }
      } else
      _L___9: /* CIL Label */ 
#line 484
      if (len == 6) {
        {
#line 484
        tmp___25 = strncmp("ifndef", (char const   *)p, (size_t )6);
        }
#line 484
        if (tmp___25) {
#line 484
          goto _L___8;
        } else {
#line 484
          goto _L___4;
        }
      } else
      _L___8: /* CIL Label */ 
#line 484
      if (len == 4) {
        {
#line 484
        tmp___26 = strncmp("ifeq", (char const   *)p, (size_t )4);
        }
#line 484
        if (tmp___26) {
#line 484
          goto _L___7;
        } else {
#line 484
          goto _L___4;
        }
      } else
      _L___7: /* CIL Label */ 
#line 484
      if (len == 5) {
        {
#line 484
        tmp___27 = strncmp("ifneq", (char const   *)p, (size_t )5);
        }
#line 484
        if (tmp___27) {
#line 484
          goto _L___6;
        } else {
#line 484
          goto _L___4;
        }
      } else
      _L___6: /* CIL Label */ 
#line 484
      if (len == 4) {
        {
#line 484
        tmp___28 = strncmp("else", (char const   *)p, (size_t )4);
        }
#line 484
        if (tmp___28) {
#line 484
          goto _L___5;
        } else {
#line 484
          goto _L___4;
        }
      } else
      _L___5: /* CIL Label */ 
#line 484
      if (len == 5) {
        {
#line 484
        tmp___29 = strncmp("endif", (char const   *)p, (size_t )5);
        }
#line 484
        if (tmp___29) {
#line 484
          goto _L___3;
        } else {
          _L___4: /* CIL Label */ 
          {
#line 489
          tmp___15 = conditional_line(p, filename, lineno);
#line 489
          i___0 = tmp___15;
          }
#line 490
          if (i___0 >= 0) {
#line 491
            ignoring = i___0;
          } else {
            {
#line 493
            makefile_fatal(filename, lineno, "invalid syntax in conditional");
            }
          }
#line 495
          goto while_continue___0;
        }
      } else {
#line 484
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 497
    if (len == 5) {
      {
#line 497
      tmp___23 = strncmp("endef", (char const   *)p, (size_t )5);
      }
#line 497
      if (tmp___23) {
#line 497
        goto _L___2;
      } else {
#line 499
        if (in_ignored_define) {
#line 500
          in_ignored_define = 0;
        } else {
          {
#line 502
          makefile_fatal(filename, lineno, "extraneous `endef\'");
          }
        }
#line 503
        goto while_continue___0;
      }
    } else
    _L___2: /* CIL Label */ 
#line 505
    if (len == 6) {
      {
#line 505
      tmp___22 = strncmp("define", (char const   *)p, (size_t )6);
      }
#line 505
      if (tmp___22) {
#line 505
        goto _L___1;
      } else {
#line 507
        if (ignoring) {
#line 508
          in_ignored_define = 1;
        } else {
          {
#line 511
          p2 = next_token(p + 6);
#line 516
          p = strchr((char const   *)p2, '\000');
          }
          {
#line 517
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 517
            tmp___16 = __ctype_b_loc();
            }
#line 517
            if (! ((int const   )*(*tmp___16 + (int )*(p + -1)) & 1)) {
#line 517
              goto while_break___4;
            }
#line 518
            p --;
          }
          while_break___4: /* CIL Label */ ;
          }
          {
#line 519
          lineno = do_define(p2, (unsigned int )(p - p2), (enum variable_origin )2,
                             lineno, infile, filename);
          }
        }
#line 522
        goto while_continue___0;
      }
    } else
    _L___1: /* CIL Label */ 
#line 524
    if (len == 8) {
      {
#line 524
      tmp___21 = strncmp("override", (char const   *)p, (size_t )8);
      }
#line 524
      if (! tmp___21) {
        {
#line 526
        p2 = next_token(p + 8);
        }
#line 527
        if ((unsigned long )p2 == (unsigned long )((char *)0)) {
          {
#line 528
          makefile_error(filename, lineno, "empty `override\' directive");
          }
        }
        {
#line 529
        tmp___19 = strncmp((char const   *)p2, "define", (size_t )6);
        }
#line 529
        if (tmp___19) {
          _L: /* CIL Label */ 
#line 547
          if (! ignoring) {
            {
#line 547
            tmp___18 = try_variable_definition(filename, lineno, p2, (enum variable_origin )5);
            }
#line 547
            if (! tmp___18) {
              {
#line 550
              makefile_error(filename, lineno, "empty `override\' directive");
              }
            }
          }
        } else {
          {
#line 529
          tmp___20 = __ctype_b_loc();
          }
#line 529
          if ((int const   )*(*tmp___20 + (int )*(p2 + 6)) & 1) {
#line 529
            goto _L___0;
          } else
#line 529
          if ((int )*(p2 + 6) == 0) {
            _L___0: /* CIL Label */ 
#line 531
            if (ignoring) {
#line 532
              in_ignored_define = 1;
            } else {
              {
#line 535
              p2 = next_token(p2 + 6);
#line 540
              p = strchr((char const   *)p2, '\000');
              }
              {
#line 541
              while (1) {
                while_continue___5: /* CIL Label */ ;
                {
#line 541
                tmp___17 = __ctype_b_loc();
                }
#line 541
                if (! ((int const   )*(*tmp___17 + (int )*(p + -1)) & 1)) {
#line 541
                  goto while_break___5;
                }
#line 542
                p --;
              }
              while_break___5: /* CIL Label */ ;
              }
              {
#line 543
              lineno = do_define(p2, (unsigned int )(p - p2), (enum variable_origin )5,
                                 lineno, infile, filename);
              }
            }
          } else {
#line 529
            goto _L;
          }
        }
#line 552
        goto while_continue___0;
      }
    }
#line 555
    if (ignoring) {
#line 558
      goto while_continue___0;
    } else
#line 559
    if (len == 6) {
      {
#line 559
      tmp___53 = strncmp("export", (char const   *)p, (size_t )6);
      }
#line 559
      if (tmp___53) {
#line 559
        goto _L___17;
      } else {
        {
#line 562
        p2 = next_token(p + 6);
        }
#line 563
        if ((int )*p2 == 0) {
#line 564
          export_all_variables = 1;
        }
        {
#line 565
        v = try_variable_definition(filename, lineno, p2, (enum variable_origin )2);
        }
#line 566
        if ((unsigned long )v != (unsigned long )((struct variable *)0)) {
#line 567
          v->export = (enum __anonenum_export_56 )0;
        } else {
          {
#line 571
          p = find_next_token(& p2, & len___1);
          }
          {
#line 571
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 571
            if (! ((unsigned long )p != (unsigned long )((char *)0))) {
#line 571
              goto while_break___6;
            }
            {
#line 574
            v = lookup_variable(p, len___1);
            }
#line 575
            if ((unsigned long )v == (unsigned long )((struct variable *)0)) {
              {
#line 576
              v = define_variable(p, len___1, (char *)"", (enum variable_origin )2,
                                  0);
              }
            }
            {
#line 577
            v->export = (enum __anonenum_export_56 )0;
#line 571
            p = find_next_token(& p2, & len___1);
            }
          }
          while_break___6: /* CIL Label */ ;
          }
        }
      }
    } else
    _L___17: /* CIL Label */ 
#line 581
    if (len == 8) {
      {
#line 581
      tmp___52 = strncmp("unexport", (char const   *)p, (size_t )8);
      }
#line 581
      if (tmp___52) {
#line 581
        goto _L___16;
      } else {
        {
#line 585
        p2 = next_token(p + 8);
        }
#line 586
        if ((int )*p2 == 0) {
#line 587
          export_all_variables = 0;
        }
        {
#line 588
        p = find_next_token(& p2, & len___2);
        }
        {
#line 588
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 588
          if (! ((unsigned long )p != (unsigned long )((char *)0))) {
#line 588
            goto while_break___7;
          }
          {
#line 591
          v___0 = lookup_variable(p, len___2);
          }
#line 592
          if ((unsigned long )v___0 == (unsigned long )((struct variable *)0)) {
            {
#line 593
            v___0 = define_variable(p, len___2, (char *)"", (enum variable_origin )2,
                                    0);
            }
          }
          {
#line 594
          v___0->export = (enum __anonenum_export_56 )1;
#line 588
          p = find_next_token(& p2, & len___2);
          }
        }
        while_break___7: /* CIL Label */ ;
        }
      }
    } else
    _L___16: /* CIL Label */ 
#line 597
    if (len == 5) {
      {
#line 597
      tmp___51 = strncmp("vpath", (char const   *)p, (size_t )5);
      }
#line 597
      if (tmp___51) {
#line 597
        goto check_var;
      } else {
        {
#line 601
        p2 = variable_expand(p + 5);
#line 602
        p = find_next_token(& p2, & len___3);
        }
#line 603
        if ((unsigned long )p != (unsigned long )((char *)0)) {
          {
#line 605
          pattern___0 = savestring(p, len___3);
#line 606
          p = find_next_token(& p2, & len___3);
          }
        } else {
#line 612
          pattern___0 = (char *)0;
        }
        {
#line 613
        construct_vpath_list(pattern___0, p);
        }
#line 614
        if ((unsigned long )pattern___0 != (unsigned long )((char *)0)) {
          {
#line 615
          free((void *)pattern___0);
          }
        }
      }
    } else
    check_var: 
#line 619
    if (len == 7) {
      {
#line 619
      tmp___48 = strncmp("include", (char const   *)p, (size_t )7);
      }
#line 619
      if (tmp___48) {
#line 619
        goto _L___14;
      } else {
#line 619
        goto _L___11;
      }
    } else
    _L___14: /* CIL Label */ 
#line 619
    if (len == 8) {
      {
#line 619
      tmp___49 = strncmp("-include", (char const   *)p, (size_t )8);
      }
#line 619
      if (tmp___49) {
#line 619
        goto _L___13;
      } else {
#line 619
        goto _L___11;
      }
    } else
    _L___13: /* CIL Label */ 
#line 619
    if (len == 8) {
      {
#line 619
      tmp___50 = strncmp("sinclude", (char const   *)p, (size_t )8);
      }
#line 619
      if (tmp___50) {
#line 619
        goto _L___12;
      } else {
        _L___11: /* CIL Label */ 
#line 628
        noerror = (int )*(p + 0) != 105;
#line 630
        if (noerror) {
#line 630
          tmp___30 = 9;
        } else {
#line 630
          tmp___30 = 8;
        }
        {
#line 630
        tmp___31 = next_token(p + tmp___30);
#line 630
        p = allocated_variable_expand_for_file(tmp___31, (struct file *)0);
        }
#line 631
        if ((int )*p == 0) {
#line 633
          if (noerror) {
#line 633
            tmp___32 = "-";
          } else {
#line 633
            tmp___32 = "";
          }
          {
#line 633
          makefile_error(filename, lineno, "no file name for `%sinclude\'", tmp___32);
          }
#line 636
          goto while_continue___0;
        }
        {
#line 640
        p2 = p;
#line 641
        tmp___33 = parse_file_seq(& p2, '\000', (unsigned int )sizeof(struct nameseq ),
                                  1);
#line 641
        files___0 = multi_glob(tmp___33, (unsigned int )sizeof(struct nameseq ));
#line 645
        free((void *)p);
#line 649
        save = conditionals;
#line 650
        memset((void *)((char *)(& new_conditionals)), 0, sizeof(new_conditionals));
#line 651
        conditionals = & new_conditionals;
        }
        {
#line 655
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 655
          if ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
            {
#line 655
            record_files(filenames, pattern, pattern_percent, deps, commands_started___0,
                         commands, commands_idx, two_colon, filename, lineno, ! (flags & 1));
            }
          }
#line 655
          filenames = (struct nameseq *)0;
#line 655
          commands_idx = 0U;
#line 655
          pattern = (char *)0;
#line 655
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
        {
#line 658
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 658
          if (! ((unsigned long )files___0 != (unsigned long )((struct nameseq *)0))) {
#line 658
            goto while_break___9;
          }
          {
#line 660
          next = files___0->next;
#line 661
          name___1 = files___0->name;
#line 662
          free((void *)((char *)files___0));
#line 663
          files___0 = next;
          }
#line 665
          if (noerror) {
#line 665
            tmp___36 = 1 << 2;
          } else {
#line 665
            tmp___36 = 0;
          }
          {
#line 665
          tmp___37 = read_makefile(name___1, ((1 << 1) | (1 << 3)) | tmp___36);
          }
#line 665
          if (! tmp___37) {
#line 665
            if (! noerror) {
              {
#line 668
              tmp___34 = __errno_location();
#line 668
              tmp___35 = strerror(*tmp___34);
#line 668
              makefile_error(filename, lineno, "%s: %s", name___1, tmp___35);
              }
            }
          }
        }
        while_break___9: /* CIL Label */ ;
        }
#line 673
        if (conditionals->ignoring) {
          {
#line 674
          free((void *)conditionals->ignoring);
          }
        }
#line 675
        if (conditionals->seen_else) {
          {
#line 676
          free((void *)conditionals->seen_else);
          }
        }
#line 679
        conditionals = save;
#line 680
        reading_filename = filename;
#line 681
        reading_lineno_ptr = & lineno;
      }
    } else {
      _L___12: /* CIL Label */ 
      {
#line 684
      tmp___47 = try_variable_definition(filename, lineno, p, (enum variable_origin )2);
      }
#line 684
      if (! tmp___47) {
#line 687
        if ((int )*(lb.buffer + 0) == 9) {
#line 689
          p = collapsed;
          {
#line 690
          while (1) {
            while_continue___10: /* CIL Label */ ;
            {
#line 690
            tmp___38 = __ctype_b_loc();
            }
#line 690
            if (! ((int const   )*(*tmp___38 + (int )*p) & 1)) {
#line 690
              goto while_break___10;
            }
#line 691
            p ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 692
          if ((int )*p == 0) {
#line 694
            goto while_continue___0;
          }
          {
#line 699
          makefile_fatal(filename, lineno, "commands commence before first target");
          }
        } else {
          {
#line 710
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 710
            if ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
              {
#line 710
              record_files(filenames, pattern, pattern_percent, deps, commands_started___0,
                           commands, commands_idx, two_colon, filename, lineno, ! (flags & 1));
              }
            }
#line 710
            filenames = (struct nameseq *)0;
#line 710
            commands_idx = 0U;
#line 710
            pattern = (char *)0;
#line 710
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
          {
#line 714
          cmdleft = find_char_unquote(lb.buffer, ";#", 0);
          }
#line 715
          if ((unsigned long )cmdleft != (unsigned long )((char *)0)) {
#line 715
            if ((int )*cmdleft == 35) {
#line 718
              *cmdleft = (char )'\000';
#line 719
              cmdleft = (char *)0;
            } else {
#line 715
              goto _L___10;
            }
          } else
          _L___10: /* CIL Label */ 
#line 721
          if ((unsigned long )cmdleft != (unsigned long )((char *)0)) {
#line 723
            *cmdleft = (char )'\000';
          }
          {
#line 725
          collapse_continuations(lb.buffer);
#line 729
          p = variable_expand(lb.buffer);
          }
#line 731
          if ((unsigned long )cmdleft == (unsigned long )((char *)0)) {
            {
#line 733
            cmdleft = find_char_unquote(p, ";", 0);
            }
          }
#line 735
          if ((unsigned long )cmdleft != (unsigned long )((char *)0)) {
#line 737
            *cmdleft = (char )'\000';
          }
          {
#line 739
          p2 = next_token(p);
          }
#line 740
          if ((int )*p2 == 0) {
#line 742
            if ((unsigned long )cmdleft != (unsigned long )((char *)0)) {
              {
#line 743
              makefile_fatal(filename, lineno, "missing rule before commands");
              }
            } else {
#line 748
              goto while_continue___0;
            }
          } else
#line 750
          if ((int )*p2 == 58) {
#line 754
            no_targets = 1;
#line 755
            goto while_continue___0;
          }
          {
#line 758
          tmp___39 = parse_file_seq(& p2, ':', (unsigned int )sizeof(struct nameseq ),
                                    1);
#line 758
          filenames = multi_glob(tmp___39, (unsigned int )sizeof(struct nameseq ));
#line 762
          tmp___40 = p2;
#line 762
          p2 ++;
          }
#line 762
          if ((int )*tmp___40 == 0) {
            {
#line 763
            makefile_fatal(filename, lineno, "missing separator");
            }
          }
#line 765
          two_colon = (int )*p2 == 58;
#line 766
          if (two_colon) {
#line 767
            p2 ++;
          }
          {
#line 770
          no_targets = 0;
#line 773
          p = strchr((char const   *)p2, ':');
          }
          {
#line 774
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 774
            if ((unsigned long )p != (unsigned long )((char *)0)) {
#line 774
              if (! ((int )*(p + -1) == 92)) {
#line 774
                goto while_break___12;
              }
            } else {
#line 774
              goto while_break___12;
            }
#line 776
            q = p + -1;
#line 777
            backslash = 0;
            {
#line 778
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 778
              tmp___41 = q;
#line 778
              q --;
#line 778
              if (! ((int )*tmp___41 == 92)) {
#line 778
                goto while_break___13;
              }
#line 779
              backslash = ! backslash;
            }
            while_break___13: /* CIL Label */ ;
            }
#line 780
            if (backslash) {
              {
#line 781
              p = strchr((char const   *)(p + 1), ':');
              }
            } else {
#line 783
              goto while_break___12;
            }
          }
          while_break___12: /* CIL Label */ ;
          }
#line 811
          if ((unsigned long )p != (unsigned long )((char *)0)) {
            {
#line 814
            target = parse_file_seq(& p2, ':', (unsigned int )sizeof(struct nameseq ),
                                    1);
#line 815
            p2 ++;
            }
#line 816
            if ((unsigned long )target == (unsigned long )((struct nameseq *)0)) {
              {
#line 817
              makefile_fatal(filename, lineno, "missing target pattern");
              }
            } else
#line 818
            if ((unsigned long )target->next != (unsigned long )((struct nameseq *)0)) {
              {
#line 819
              makefile_fatal(filename, lineno, "multiple target patterns");
              }
            }
            {
#line 820
            pattern = target->name;
#line 821
            pattern_percent = find_percent(pattern);
            }
#line 822
            if ((unsigned long )pattern_percent == (unsigned long )((char *)0)) {
              {
#line 823
              makefile_fatal(filename, lineno, "target pattern contains no `%%\'");
              }
            }
          } else {
#line 827
            pattern = (char *)0;
          }
          {
#line 830
          tmp___42 = parse_file_seq(& p2, '\000', (unsigned int )sizeof(struct dep ),
                                    1);
#line 830
          tmp___43 = multi_glob(tmp___42, (unsigned int )sizeof(struct dep ));
#line 830
          deps = (struct dep *)tmp___43;
#line 834
          commands_idx = 0U;
          }
#line 835
          if ((unsigned long )cmdleft != (unsigned long )((char *)0)) {
            {
#line 838
            tmp___44 = strlen((char const   *)(cmdleft + 1));
#line 838
            len___4 = (unsigned int )tmp___44;
#line 840
            commands_started___0 = lineno;
            }
#line 843
            if (len___4 + 2U > commands_len) {
              {
#line 845
              commands_len = (len___4 + 2U) * 2U;
#line 846
              tmp___45 = xrealloc(commands, commands_len);
#line 846
              commands = tmp___45;
              }
            }
            {
#line 848
            memmove((void *)commands, (void const   *)(cmdleft + 1), (size_t )len___4);
#line 849
            commands_idx += len___4;
#line 850
            tmp___46 = commands_idx;
#line 850
            commands_idx ++;
#line 850
            *(commands + tmp___46) = (char )'\n';
            }
          }
#line 853
          goto while_continue___0;
        }
      }
    }
    {
#line 859
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 859
      if ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
        {
#line 859
        record_files(filenames, pattern, pattern_percent, deps, commands_started___0,
                     commands, commands_idx, two_colon, filename, lineno, ! (flags & 1));
        }
      }
#line 859
      filenames = (struct nameseq *)0;
#line 859
      commands_idx = 0U;
#line 859
      pattern = (char *)0;
#line 859
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 860
    no_targets = 0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 863
  if (conditionals->if_cmds) {
    {
#line 864
    makefile_fatal(filename, lineno, "missing `endif\'");
    }
  }
  {
#line 867
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 867
    if ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
      {
#line 867
      record_files(filenames, pattern, pattern_percent, deps, commands_started___0,
                   commands, commands_idx, two_colon, filename, lineno, ! (flags & 1));
      }
    }
#line 867
    filenames = (struct nameseq *)0;
#line 867
    commands_idx = 0U;
#line 867
    pattern = (char *)0;
#line 867
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 869
  free((void *)lb.buffer);
#line 870
  free((void *)commands);
#line 871
  fclose(infile);
#line 873
  reading_filename = (char *)0;
#line 874
  reading_lineno_ptr = (unsigned int *)0;
  }
#line 876
  return (1);
}
}
#line 885 "/home/khheo/testset/make-3.76.1/read.c"
static unsigned int do_define(char *name___0 , unsigned int namelen , enum variable_origin origin ,
                              unsigned int lineno , FILE *infile , char *filename ) 
{ 
  struct linebuffer lb ;
  unsigned int nlines ;
  unsigned int length___0 ;
  char *definition ;
  char *tmp ;
  register unsigned int idx ;
  register char *p ;
  char *var ;
  void *tmp___0 ;
  char *tmp___1 ;
  unsigned int len ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  unsigned int tmp___7 ;
  unsigned short const   **tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 895
  nlines = 0U;
#line 896
  length___0 = 100U;
#line 897
  tmp = xmalloc(100);
#line 897
  definition = tmp;
#line 898
  idx = 0U;
#line 902
  tmp___0 = __builtin_alloca((unsigned long )(namelen + 1U));
#line 902
  var = (char *)tmp___0;
#line 903
  memmove((void *)var, (void const   *)name___0, (size_t )namelen);
#line 904
  *(var + namelen) = (char )'\000';
#line 905
  var = variable_expand(var);
#line 907
  lb.size = 200U;
#line 907
  tmp___1 = xmalloc(lb.size);
#line 907
  lb.buffer = tmp___1;
  }
  {
#line 908
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 908
    tmp___10 = feof(infile);
    }
#line 908
    if (tmp___10) {
#line 908
      goto while_break;
    }
    {
#line 912
    lineno += nlines;
#line 913
    nlines = readline(& lb, infile, filename, lineno);
#line 915
    collapse_continuations(lb.buffer);
#line 917
    p = next_token(lb.buffer);
#line 918
    tmp___2 = strlen((char const   *)p);
#line 918
    len = (unsigned int )tmp___2;
    }
#line 919
    if (len == 5U) {
#line 919
      goto _L___0;
    } else
#line 919
    if (len > 5U) {
      {
#line 919
      tmp___8 = __ctype_b_loc();
      }
#line 919
      if ((int const   )*(*tmp___8 + (int )*(p + 5)) & 1) {
        _L___0: /* CIL Label */ 
        {
#line 919
        tmp___9 = strncmp((char const   *)p, "endef", (size_t )5);
        }
#line 919
        if (tmp___9) {
#line 919
          goto _L___1;
        } else {
          {
#line 922
          p += 5;
#line 923
          remove_comments(p);
#line 924
          tmp___3 = next_token(p);
          }
#line 924
          if ((int )*tmp___3 != 0) {
            {
#line 925
            makefile_error(filename, lineno, "Extraneous text after `endef\' directive");
            }
          }
#line 928
          if (idx == 0U) {
#line 929
            *(definition + 0) = (char )'\000';
          } else {
#line 931
            *(definition + (idx - 1U)) = (char )'\000';
          }
          {
#line 932
          tmp___4 = strlen((char const   *)var);
#line 932
          define_variable(var, (unsigned int )tmp___4, definition, origin, 1);
#line 933
          free((void *)definition);
#line 934
          free((void *)lb.buffer);
          }
#line 935
          return (lineno + nlines);
        }
      } else {
#line 919
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 939
      tmp___5 = strlen((char const   *)lb.buffer);
#line 939
      len = (unsigned int )tmp___5;
      }
#line 941
      if ((idx + len) + 1U > length___0) {
        {
#line 943
        length___0 = (idx + len) * 2U;
#line 944
        tmp___6 = xrealloc(definition, length___0 + 1U);
#line 944
        definition = tmp___6;
        }
      }
      {
#line 947
      memmove((void *)(definition + idx), (void const   *)lb.buffer, (size_t )len);
#line 948
      idx += len;
#line 950
      tmp___7 = idx;
#line 950
      idx ++;
#line 950
      *(definition + tmp___7) = (char )'\n';
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 955
  makefile_fatal(filename, lineno, "missing `endef\', unterminated `define\'");
  }
#line 958
  return (0U);
}
}
#line 972 "/home/khheo/testset/make-3.76.1/read.c"
static int conditional_line(char *line , char *filename , unsigned int lineno ) 
{ 
  int notdef ;
  char *cmdname ;
  register unsigned int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  struct variable *v ;
  register char *p ;
  char *tmp___6 ;
  int tmp___7 ;
  char *s1 ;
  char *s2 ;
  unsigned int len ;
  char termin ;
  int tmp___8 ;
  register int count ;
  char *p___0 ;
  char *tmp___9 ;
  unsigned short const   **tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  register int count___0 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
#line 982
  if ((int )*line == 105) {
#line 985
    notdef = (int )*(line + 2) == 110;
#line 986
    if (notdef) {
#line 988
      if ((int )*(line + 3) == 100) {
#line 988
        cmdname = (char *)"ifndef";
      } else {
#line 988
        cmdname = (char *)"ifneq";
      }
#line 989
      if ((int )*(cmdname + 3) == 100) {
#line 989
        tmp = 7;
      } else {
#line 989
        tmp = 6;
      }
#line 989
      line += tmp;
    } else {
#line 993
      if ((int )*(line + 2) == 100) {
#line 993
        cmdname = (char *)"ifdef";
      } else {
#line 993
        cmdname = (char *)"ifeq";
      }
#line 994
      if ((int )*(cmdname + 2) == 100) {
#line 994
        tmp___0 = 6;
      } else {
#line 994
        tmp___0 = 5;
      }
#line 994
      line += tmp___0;
    }
  } else {
#line 1000
    notdef = (int )*(line + 1) == 110;
#line 1001
    if (notdef) {
#line 1001
      cmdname = (char *)"endif";
    } else {
#line 1001
      cmdname = (char *)"else";
    }
#line 1002
    if (notdef) {
#line 1002
      tmp___1 = 5;
    } else {
#line 1002
      tmp___1 = 4;
    }
#line 1002
    line += tmp___1;
  }
  {
#line 1005
  line = next_token(line);
  }
#line 1007
  if ((int )*cmdname == 101) {
#line 1009
    if ((int )*line != 0) {
      {
#line 1010
      makefile_error(filename, lineno, "Extraneous text after `%s\' directive", cmdname);
      }
    }
#line 1014
    if (conditionals->if_cmds == 0U) {
      {
#line 1015
      makefile_fatal(filename, lineno, "extraneous `%s\'", cmdname);
      }
    }
#line 1017
    if (notdef) {
#line 1018
      (conditionals->if_cmds) --;
    } else
#line 1019
    if (*(conditionals->seen_else + (conditionals->if_cmds - 1U))) {
      {
#line 1020
      makefile_fatal(filename, lineno, "only one `else\' per conditional");
      }
    } else {
#line 1024
      *(conditionals->ignoring + (conditionals->if_cmds - 1U)) = (char )(! *(conditionals->ignoring + (conditionals->if_cmds - 1U)));
#line 1028
      *(conditionals->seen_else + (conditionals->if_cmds - 1U)) = (char)1;
    }
#line 1030
    i = 0U;
    {
#line 1030
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1030
      if (! (i < conditionals->if_cmds)) {
#line 1030
        goto while_break;
      }
#line 1031
      if (*(conditionals->ignoring + i)) {
#line 1032
        return (1);
      }
#line 1030
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1033
    return (0);
  }
#line 1036
  if (conditionals->allocated == 0U) {
    {
#line 1038
    conditionals->allocated = 5U;
#line 1039
    tmp___2 = xmalloc(conditionals->allocated);
#line 1039
    conditionals->ignoring = tmp___2;
#line 1040
    tmp___3 = xmalloc(conditionals->allocated);
#line 1040
    conditionals->seen_else = tmp___3;
    }
  }
#line 1043
  (conditionals->if_cmds) ++;
#line 1044
  if (conditionals->if_cmds > conditionals->allocated) {
    {
#line 1046
    conditionals->allocated += 5U;
#line 1047
    tmp___4 = xrealloc(conditionals->ignoring, conditionals->allocated);
#line 1047
    conditionals->ignoring = tmp___4;
#line 1049
    tmp___5 = xrealloc(conditionals->seen_else, conditionals->allocated);
#line 1049
    conditionals->seen_else = tmp___5;
    }
  }
#line 1054
  *(conditionals->seen_else + (conditionals->if_cmds - 1U)) = (char)0;
#line 1057
  i = 0U;
  {
#line 1057
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1057
    if (! (i < conditionals->if_cmds - 1U)) {
#line 1057
      goto while_break___0;
    }
#line 1058
    if (*(conditionals->ignoring + i)) {
#line 1063
      *(conditionals->ignoring + (conditionals->if_cmds - 1U)) = (char)1;
#line 1064
      return (1);
    }
#line 1057
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1067
  if (notdef) {
#line 1067
    tmp___16 = 3;
  } else {
#line 1067
    tmp___16 = 2;
  }
#line 1067
  if ((int )*(cmdname + tmp___16) == 100) {
    {
#line 1071
    tmp___6 = end_of_token(line);
#line 1071
    p = tmp___6;
#line 1072
    i = (unsigned int )(p - line);
#line 1073
    p = next_token(p);
    }
#line 1074
    if ((int )*p != 0) {
#line 1075
      return (-1);
    }
    {
#line 1076
    v = lookup_variable(line, i);
    }
#line 1077
    if ((unsigned long )v != (unsigned long )((struct variable *)0)) {
#line 1077
      if ((int )*(v->value) != 0) {
#line 1077
        tmp___7 = 1;
      } else {
#line 1077
        tmp___7 = 0;
      }
    } else {
#line 1077
      tmp___7 = 0;
    }
#line 1077
    *(conditionals->ignoring + (conditionals->if_cmds - 1U)) = (char )(tmp___7 == notdef);
  } else {
#line 1085
    if ((int )*line == 40) {
#line 1085
      tmp___8 = ',';
    } else {
#line 1085
      tmp___8 = (int )*line;
    }
#line 1085
    termin = (char )tmp___8;
#line 1087
    if ((int )termin != 44) {
#line 1087
      if ((int )termin != 34) {
#line 1087
        if ((int )termin != 39) {
#line 1088
          return (-1);
        }
      }
    }
#line 1090
    line ++;
#line 1090
    s1 = line;
#line 1092
    if ((int )termin == 44) {
#line 1094
      count = 0;
      {
#line 1095
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1095
        if (! ((int )*line != 0)) {
#line 1095
          goto while_break___1;
        }
#line 1096
        if ((int )*line == 40) {
#line 1097
          count ++;
        } else
#line 1098
        if ((int )*line == 41) {
#line 1099
          count --;
        } else
#line 1100
        if ((int )*line == 44) {
#line 1100
          if (count <= 0) {
#line 1101
            goto while_break___1;
          }
        }
#line 1095
        line ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 1104
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1104
        if ((int )*line != 0) {
#line 1104
          if (! ((int )*line != (int )termin)) {
#line 1104
            goto while_break___2;
          }
        } else {
#line 1104
          goto while_break___2;
        }
#line 1105
        line ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1107
    if ((int )*line == 0) {
#line 1108
      return (-1);
    }
#line 1110
    if ((int )termin == 44) {
#line 1113
      tmp___9 = line;
#line 1113
      line ++;
#line 1113
      p___0 = tmp___9;
      {
#line 1114
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 1114
        tmp___10 = __ctype_b_loc();
        }
#line 1114
        if (! ((int const   )*(*tmp___10 + (int )*(p___0 + -1)) & 1)) {
#line 1114
          goto while_break___3;
        }
#line 1115
        p___0 --;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1116
      *p___0 = (char )'\000';
    } else {
#line 1119
      tmp___11 = line;
#line 1119
      line ++;
#line 1119
      *tmp___11 = (char )'\000';
    }
    {
#line 1121
    s2 = variable_expand(s1);
#line 1124
    tmp___12 = strlen((char const   *)s2);
#line 1124
    len = (unsigned int )tmp___12;
#line 1125
    tmp___13 = __builtin_alloca((unsigned long )(len + 1U));
#line 1125
    s1 = (char *)tmp___13;
#line 1126
    memmove((void *)s1, (void const   *)s2, (size_t )(len + 1U));
    }
#line 1128
    if ((int )termin != 44) {
      {
#line 1130
      line = next_token(line);
      }
    }
#line 1132
    if ((int )termin == 44) {
#line 1132
      termin = (char )')';
    } else {
#line 1132
      termin = *line;
    }
#line 1133
    if ((int )termin != 41) {
#line 1133
      if ((int )termin != 34) {
#line 1133
        if ((int )termin != 39) {
#line 1134
          return (-1);
        }
      }
    }
#line 1137
    if ((int )termin == 41) {
      {
#line 1139
      count___0 = 0;
#line 1140
      s2 = next_token(line);
#line 1141
      line = s2;
      }
      {
#line 1141
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1141
        if (! ((int )*line != 0)) {
#line 1141
          goto while_break___4;
        }
#line 1143
        if ((int )*line == 40) {
#line 1144
          count___0 ++;
        } else
#line 1145
        if ((int )*line == 41) {
#line 1146
          if (count___0 <= 0) {
#line 1147
            goto while_break___4;
          } else {
#line 1149
            count___0 --;
          }
        }
#line 1141
        line ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
#line 1154
      line ++;
#line 1155
      s2 = line;
      {
#line 1156
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1156
        if ((int )*line != 0) {
#line 1156
          if (! ((int )*line != (int )termin)) {
#line 1156
            goto while_break___5;
          }
        } else {
#line 1156
          goto while_break___5;
        }
#line 1157
        line ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 1160
    if ((int )*line == 0) {
#line 1161
      return (-1);
    }
    {
#line 1163
    *line = (char )'\000';
#line 1164
    line ++;
#line 1164
    line = next_token(line);
    }
#line 1165
    if ((int )*line != 0) {
      {
#line 1166
      makefile_error(filename, lineno, "Extraneous text after `%s\' directive", cmdname);
      }
    }
    {
#line 1170
    s2 = variable_expand(s2);
    }
#line 1171
    if ((unsigned long )s1 == (unsigned long )s2) {
#line 1171
      tmp___15 = 1;
    } else
#line 1171
    if ((int )*s1 == (int )*s2) {
#line 1171
      if ((int )*s1 == 0) {
#line 1171
        tmp___15 = 1;
      } else {
        {
#line 1171
        tmp___14 = strcmp((char const   *)(s1 + 1), (char const   *)(s2 + 1));
        }
#line 1171
        if (tmp___14) {
#line 1171
          tmp___15 = 0;
        } else {
#line 1171
          tmp___15 = 1;
        }
      }
    } else {
#line 1171
      tmp___15 = 0;
    }
#line 1171
    *(conditionals->ignoring + (conditionals->if_cmds - 1U)) = (char )(tmp___15 == notdef);
  }
#line 1176
  i = 0U;
  {
#line 1176
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1176
    if (! (i < conditionals->if_cmds)) {
#line 1176
      goto while_break___6;
    }
#line 1177
    if (*(conditionals->ignoring + i)) {
#line 1178
      return (1);
    }
#line 1176
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1179
  return (0);
}
}
#line 1184 "/home/khheo/testset/make-3.76.1/read.c"
void uniquize_deps(struct dep *chain ) 
{ 
  register struct dep *d ;
  struct dep *last ;
  struct dep *next ;
  struct dep *n ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 1194
  d = chain;
  {
#line 1194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1194
    if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 1194
      goto while_break;
    }
#line 1198
    last = d;
#line 1199
    next = d->next;
    {
#line 1200
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1200
      if (! ((unsigned long )next != (unsigned long )((struct dep *)0))) {
#line 1200
        goto while_break___0;
      }
#line 1201
      if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 1201
        tmp = (d->file)->name;
      } else {
#line 1201
        tmp = d->name;
      }
#line 1201
      if ((unsigned long )next->name == (unsigned long )((char *)0)) {
#line 1201
        tmp___0 = (next->file)->name;
      } else {
#line 1201
        tmp___0 = next->name;
      }
#line 1201
      if ((unsigned long )tmp == (unsigned long )tmp___0) {
#line 1201
        goto _L___0;
      } else {
#line 1201
        if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 1201
          tmp___1 = (d->file)->name;
        } else {
#line 1201
          tmp___1 = d->name;
        }
#line 1201
        if ((unsigned long )next->name == (unsigned long )((char *)0)) {
#line 1201
          tmp___2 = (next->file)->name;
        } else {
#line 1201
          tmp___2 = next->name;
        }
#line 1201
        if ((int )*tmp___1 == (int )*tmp___2) {
#line 1201
          if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 1201
            tmp___3 = (d->file)->name;
          } else {
#line 1201
            tmp___3 = d->name;
          }
#line 1201
          if ((int )*tmp___3 == 0) {
#line 1201
            goto _L___0;
          } else {
#line 1201
            if ((unsigned long )next->name == (unsigned long )((char *)0)) {
#line 1201
              tmp___4 = (next->file)->name;
            } else {
#line 1201
              tmp___4 = next->name;
            }
#line 1201
            if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 1201
              tmp___5 = (d->file)->name;
            } else {
#line 1201
              tmp___5 = d->name;
            }
            {
#line 1201
            tmp___6 = strcmp((char const   *)(tmp___5 + 1), (char const   *)(tmp___4 + 1));
            }
#line 1201
            if (tmp___6) {
#line 1213
              last = next;
#line 1214
              next = next->next;
            } else {
              _L___0: /* CIL Label */ 
#line 1203
              n = next->next;
#line 1204
              last->next = n;
#line 1205
              if ((unsigned long )next->name != (unsigned long )((char *)0)) {
#line 1205
                if ((unsigned long )next->name != (unsigned long )d->name) {
                  {
#line 1206
                  free((void *)next->name);
                  }
                }
              }
#line 1207
              if ((unsigned long )next != (unsigned long )d) {
                {
#line 1208
                free((void *)((char *)next));
                }
              }
#line 1209
              next = n;
            }
          }
        } else {
#line 1213
          last = next;
#line 1214
          next = next->next;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1194
    d = d->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1217
  return;
}
}
#line 1438 "/home/khheo/testset/make-3.76.1/read.c"
static char *percent___0  =    (char *)"%";
#line 1230 "/home/khheo/testset/make-3.76.1/read.c"
static void record_files(struct nameseq *filenames , char *pattern , char *pattern_percent ,
                         struct dep *deps , unsigned int commands_started___0 , char *commands ,
                         unsigned int commands_idx , int two_colon , char *filename ,
                         unsigned int lineno , int set_default ) 
{ 
  struct nameseq *nextf ;
  int implicit ;
  unsigned int max_targets ;
  unsigned int target_idx ;
  char **targets ;
  char **target_percents ;
  struct commands *cmds ;
  char *tmp ;
  register char *name___0 ;
  register struct file *f ;
  register struct dep *d ;
  struct dep *this ;
  char *implicit_percent ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  struct dep *tmp___4 ;
  char *buffer ;
  char *tmp___5 ;
  char *o ;
  char *percent ;
  char *tmp___6 ;
  int tmp___7 ;
  struct dep *nextd ;
  struct dep *firstdeps ;
  struct dep *moredeps ;
  char *buffer___0 ;
  char *tmp___8 ;
  char *o___0 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  int reject ;
  register struct dep *d2 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  register unsigned int len ;
  char *tmp___16 ;
  size_t tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;

  {
#line 1245
  implicit = 0;
#line 1247
  targets = (char **)0;
#line 1247
  target_percents = (char **)0;
#line 1250
  if (commands_idx > 0U) {
    {
#line 1252
    tmp = xmalloc(sizeof(struct commands ));
#line 1252
    cmds = (struct commands *)tmp;
#line 1253
    cmds->filename = filename;
#line 1254
    cmds->lineno = commands_started___0;
#line 1255
    cmds->commands = savestring(commands, commands_idx);
#line 1256
    cmds->command_lines = (char **)0;
    }
  } else {
#line 1259
    cmds = (struct commands *)0;
  }
  {
#line 1261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1261
    if (! ((unsigned long )filenames != (unsigned long )((struct nameseq *)0))) {
#line 1261
      goto while_break;
    }
    {
#line 1263
    name___0 = filenames->name;
#line 1269
    nextf = filenames->next;
#line 1270
    free((void *)((char *)filenames));
#line 1272
    implicit_percent = find_percent(name___0);
#line 1273
    implicit |= (unsigned long )implicit_percent != (unsigned long )((char *)0);
    }
#line 1275
    if (implicit) {
#line 1275
      if ((unsigned long )pattern != (unsigned long )((char *)0)) {
        {
#line 1276
        makefile_fatal(filename, lineno, "mixed implicit and static pattern rules");
        }
      }
    }
#line 1279
    if (implicit) {
#line 1279
      if ((unsigned long )implicit_percent == (unsigned long )((char *)0)) {
        {
#line 1280
        makefile_fatal(filename, lineno, "mixed implicit and normal rules");
        }
      }
    }
#line 1282
    if (implicit) {
#line 1284
      if ((unsigned long )targets == (unsigned long )((char **)0)) {
        {
#line 1286
        max_targets = 5U;
#line 1287
        tmp___0 = xmalloc(5UL * sizeof(char *));
#line 1287
        targets = (char **)tmp___0;
#line 1288
        tmp___1 = xmalloc(5UL * sizeof(char *));
#line 1288
        target_percents = (char **)tmp___1;
#line 1289
        target_idx = 0U;
        }
      } else
#line 1291
      if (target_idx == max_targets - 1U) {
        {
#line 1293
        max_targets += 5U;
#line 1294
        tmp___2 = xrealloc((char *)targets, (unsigned long )max_targets * sizeof(char *));
#line 1294
        targets = (char **)tmp___2;
#line 1296
        tmp___3 = xrealloc((char *)target_percents, (unsigned long )max_targets * sizeof(char *));
#line 1296
        target_percents = (char **)tmp___3;
        }
      }
#line 1300
      *(targets + target_idx) = name___0;
#line 1301
      *(target_percents + target_idx) = implicit_percent;
#line 1302
      target_idx ++;
#line 1303
      goto __Cont;
    }
#line 1309
    if ((unsigned long )nextf != (unsigned long )((struct nameseq *)0)) {
      {
#line 1309
      tmp___4 = copy_dep_chain(deps);
#line 1309
      this = tmp___4;
      }
    } else {
#line 1309
      this = deps;
    }
#line 1311
    if ((unsigned long )pattern != (unsigned long )((char *)0)) {
      {
#line 1316
      tmp___7 = pattern_matches(pattern, pattern_percent, name___0);
      }
#line 1316
      if (tmp___7) {
        {
#line 1329
        tmp___5 = variable_expand((char *)"");
#line 1329
        buffer = tmp___5;
#line 1331
        d = this;
        }
        {
#line 1331
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1331
          if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 1331
            goto while_break___0;
          }
          {
#line 1334
          tmp___6 = find_percent(d->name);
#line 1334
          percent = tmp___6;
          }
#line 1335
          if ((unsigned long )percent == (unsigned long )((char *)0)) {
#line 1336
            goto __Cont___0;
          }
          {
#line 1337
          o = patsubst_expand(buffer, name___0, pattern, d->name, pattern_percent,
                              percent);
#line 1339
          free((void *)d->name);
#line 1340
          d->name = savestring(buffer, o - buffer);
          }
          __Cont___0: /* CIL Label */ 
#line 1331
          d = d->next;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 1319
        makefile_error(filename, lineno, "target `%s\' doesn\'t match the target pattern",
                       name___0);
#line 1322
        this = (struct dep *)0;
        }
      }
    }
#line 1344
    if (! two_colon) {
      {
#line 1348
      f = enter_file(name___0);
      }
#line 1350
      if (f->double_colon) {
        {
#line 1351
        makefile_fatal(filename, lineno, "target file `%s\' has both : and :: entries",
                       f->name);
        }
      }
#line 1357
      if ((unsigned long )cmds != (unsigned long )((struct commands *)0)) {
#line 1357
        if ((unsigned long )cmds == (unsigned long )f->cmds) {
          {
#line 1358
          makefile_error(filename, lineno, "target `%s\' given more than once in the same rule.",
                         f->name);
          }
        } else {
#line 1357
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1366
      if ((unsigned long )cmds != (unsigned long )((struct commands *)0)) {
#line 1366
        if ((unsigned long )f->cmds != (unsigned long )((struct commands *)0)) {
#line 1366
          if (f->is_target) {
            {
#line 1368
            makefile_error(cmds->filename, cmds->lineno, "warning: overriding commands for target `%s\'",
                           f->name);
#line 1371
            makefile_error((f->cmds)->filename, (f->cmds)->lineno, "warning: ignoring old commands for target `%s\'",
                           f->name);
            }
          }
        }
      }
#line 1376
      f->is_target = 1U;
#line 1379
      if ((unsigned long )f == (unsigned long )default_file) {
#line 1379
        if ((unsigned long )this == (unsigned long )((struct dep *)0)) {
#line 1379
          if ((unsigned long )cmds == (unsigned long )((struct commands *)0)) {
#line 1380
            f->cmds = (struct commands *)0;
          }
        }
      }
#line 1381
      if ((unsigned long )cmds != (unsigned long )((struct commands *)0)) {
#line 1382
        f->cmds = cmds;
      }
#line 1385
      if ((unsigned long )f == (unsigned long )suffix_file) {
#line 1385
        if ((unsigned long )this == (unsigned long )((struct dep *)0)) {
#line 1387
          d = f->deps;
          {
#line 1388
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1388
            if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 1388
              goto while_break___1;
            }
            {
#line 1390
            nextd = d->next;
#line 1391
            free((void *)d->name);
#line 1392
            free((void *)((char *)d));
#line 1393
            d = nextd;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 1395
          f->deps = (struct dep *)0;
        } else {
#line 1385
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1397
      if ((unsigned long )f->deps != (unsigned long )((struct dep *)0)) {
#line 1402
        if ((unsigned long )cmds != (unsigned long )((struct commands *)0)) {
#line 1408
          firstdeps = this;
#line 1409
          moredeps = f->deps;
        } else {
#line 1414
          firstdeps = f->deps;
#line 1415
          moredeps = this;
        }
#line 1418
        if ((unsigned long )firstdeps == (unsigned long )((struct dep *)0)) {
#line 1419
          firstdeps = moredeps;
        } else {
#line 1422
          d = firstdeps;
          {
#line 1423
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1423
            if (! ((unsigned long )d->next != (unsigned long )((struct dep *)0))) {
#line 1423
              goto while_break___2;
            }
#line 1424
            d = d->next;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1425
          d->next = moredeps;
        }
#line 1428
        f->deps = firstdeps;
      } else {
#line 1431
        f->deps = this;
      }
#line 1436
      if ((unsigned long )pattern != (unsigned long )((char *)0)) {
        {
#line 1439
        tmp___8 = variable_expand((char *)"");
#line 1439
        buffer___0 = tmp___8;
#line 1440
        tmp___9 = patsubst_expand(buffer___0, name___0, pattern, percent___0, pattern_percent,
                                  percent___0);
#line 1440
        o___0 = tmp___9;
#line 1442
        f->stem = savestring(buffer___0, o___0 - buffer___0);
        }
      }
    } else {
      {
#line 1449
      f = lookup_file(name___0);
      }
#line 1452
      if ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 1452
        if (f->is_target) {
#line 1452
          if (! f->double_colon) {
            {
#line 1453
            makefile_fatal(filename, lineno, "target file `%s\' has both : and :: entries",
                           f->name);
            }
          }
        }
      }
      {
#line 1456
      f = enter_file(name___0);
      }
#line 1461
      if ((unsigned long )f->double_colon == (unsigned long )((struct file *)0)) {
#line 1464
        f->double_colon = f;
      }
#line 1465
      f->is_target = 1U;
#line 1466
      f->deps = this;
#line 1467
      f->cmds = cmds;
    }
#line 1471
    if ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 1471
      if ((unsigned long )name___0 != (unsigned long )f->name) {
#line 1471
        if ((unsigned long )name___0 < (unsigned long )f->name) {
          {
#line 1474
          free((void *)name___0);
#line 1475
          name___0 = f->name;
          }
        } else {
          {
#line 1471
          tmp___10 = strlen((char const   *)f->name);
          }
#line 1471
          if ((unsigned long )name___0 > (unsigned long )(f->name + tmp___10)) {
            {
#line 1474
            free((void *)name___0);
#line 1475
            name___0 = f->name;
            }
          }
        }
      }
    }
#line 1480
    if ((unsigned long )default_goal_file == (unsigned long )((struct file *)0)) {
#line 1480
      if (set_default) {
#line 1480
        if ((int )*name___0 != 46) {
#line 1480
          goto _L___1;
        } else {
          {
#line 1480
          tmp___24 = strchr((char const   *)name___0, '/');
          }
#line 1480
          if ((unsigned long )tmp___24 != (unsigned long )((char *)0)) {
            _L___1: /* CIL Label */ 
#line 1487
            reject = 0;
#line 1492
            d = suffix_file->deps;
            {
#line 1492
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 1492
              if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 1492
                goto while_break___3;
              }
#line 1495
              if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 1495
                tmp___11 = (d->file)->name;
              } else {
#line 1495
                tmp___11 = d->name;
              }
#line 1495
              if ((int )*tmp___11 != 46) {
#line 1495
                if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 1495
                  tmp___12 = (d->file)->name;
                } else {
#line 1495
                  tmp___12 = d->name;
                }
#line 1495
                if ((unsigned long )name___0 == (unsigned long )tmp___12) {
#line 1497
                  reject = 1;
#line 1498
                  goto while_break___3;
                } else {
#line 1495
                  if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 1495
                    tmp___13 = (d->file)->name;
                  } else {
#line 1495
                    tmp___13 = d->name;
                  }
#line 1495
                  if ((int )*name___0 == (int )*tmp___13) {
#line 1495
                    if ((int )*name___0 == 0) {
#line 1497
                      reject = 1;
#line 1498
                      goto while_break___3;
                    } else {
#line 1495
                      if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 1495
                        tmp___14 = (d->file)->name;
                      } else {
#line 1495
                        tmp___14 = d->name;
                      }
                      {
#line 1495
                      tmp___15 = strcmp((char const   *)(name___0 + 1), (char const   *)(tmp___14 + 1));
                      }
#line 1495
                      if (! tmp___15) {
#line 1497
                        reject = 1;
#line 1498
                        goto while_break___3;
                      }
                    }
                  }
                }
              }
#line 1500
              d2 = suffix_file->deps;
              {
#line 1500
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 1500
                if (! ((unsigned long )d2 != (unsigned long )((struct dep *)0))) {
#line 1500
                  goto while_break___4;
                }
#line 1502
                if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
#line 1502
                  tmp___16 = (d2->file)->name;
                } else {
#line 1502
                  tmp___16 = d2->name;
                }
                {
#line 1502
                tmp___17 = strlen((char const   *)tmp___16);
#line 1502
                len = (unsigned int )tmp___17;
                }
#line 1503
                if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
#line 1503
                  tmp___18 = (d2->file)->name;
                } else {
#line 1503
                  tmp___18 = d2->name;
                }
                {
#line 1503
                tmp___19 = strncmp((char const   *)name___0, (char const   *)tmp___18,
                                   (size_t )len);
                }
#line 1503
                if (tmp___19) {
#line 1504
                  goto __Cont___1;
                }
#line 1505
                if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 1505
                  tmp___20 = (d->file)->name;
                } else {
#line 1505
                  tmp___20 = d->name;
                }
#line 1505
                if ((unsigned long )(name___0 + len) == (unsigned long )tmp___20) {
#line 1507
                  reject = 1;
#line 1508
                  goto while_break___4;
                } else {
#line 1505
                  if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 1505
                    tmp___21 = (d->file)->name;
                  } else {
#line 1505
                    tmp___21 = d->name;
                  }
#line 1505
                  if ((int )*(name___0 + len) == (int )*tmp___21) {
#line 1505
                    if ((int )*(name___0 + len) == 0) {
#line 1507
                      reject = 1;
#line 1508
                      goto while_break___4;
                    } else {
#line 1505
                      if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 1505
                        tmp___22 = (d->file)->name;
                      } else {
#line 1505
                        tmp___22 = d->name;
                      }
                      {
#line 1505
                      tmp___23 = strcmp((char const   *)((name___0 + len) + 1), (char const   *)(tmp___22 + 1));
                      }
#line 1505
                      if (! tmp___23) {
#line 1507
                        reject = 1;
#line 1508
                        goto while_break___4;
                      }
                    }
                  }
                }
                __Cont___1: /* CIL Label */ 
#line 1500
                d2 = d2->next;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 1511
              if (reject) {
#line 1512
                goto while_break___3;
              }
#line 1492
              d = d->next;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 1515
            if (! reject) {
#line 1516
              default_goal_file = f;
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1261
    filenames = nextf;
  }
  while_break: /* CIL Label */ ;
  }
#line 1520
  if (implicit) {
    {
#line 1522
    *(targets + target_idx) = (char *)0;
#line 1523
    *(target_percents + target_idx) = (char *)0;
#line 1524
    create_pattern_rule(targets, target_percents, two_colon, deps, cmds, 1);
#line 1525
    free((void *)((char *)target_percents));
    }
  }
#line 1527
  return;
}
}
#line 1535 "/home/khheo/testset/make-3.76.1/read.c"
char *find_char_unquote(char *string , char *stopchars , int blank ) 
{ 
  unsigned int string_len ;
  register char *p ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  register int i ;
  size_t tmp___1 ;

  {
#line 1541
  string_len = 0U;
#line 1542
  p = string;
  {
#line 1544
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1546
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1546
      if ((int )*p != 0) {
        {
#line 1546
        tmp = strchr((char const   *)stopchars, (int )*p);
        }
#line 1546
        if ((unsigned long )tmp == (unsigned long )((char *)0)) {
#line 1546
          if (! (! blank)) {
            {
#line 1546
            tmp___0 = __ctype_b_loc();
            }
#line 1546
            if ((int const   )*(*tmp___0 + (int )*p) & 1) {
#line 1546
              goto while_break___0;
            }
          }
        } else {
#line 1546
          goto while_break___0;
        }
      } else {
#line 1546
        goto while_break___0;
      }
#line 1548
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1549
    if ((int )*p == 0) {
#line 1550
      goto while_break;
    }
#line 1552
    if ((unsigned long )p > (unsigned long )string) {
#line 1552
      if ((int )*(p + -1) == 92) {
#line 1555
        i = -2;
        {
#line 1556
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1556
          if ((unsigned long )(p + i) >= (unsigned long )string) {
#line 1556
            if (! ((int )*(p + i) == 92)) {
#line 1556
              goto while_break___1;
            }
          } else {
#line 1556
            goto while_break___1;
          }
#line 1557
          i --;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1558
        i ++;
#line 1560
        if (string_len == 0U) {
          {
#line 1561
          tmp___1 = strlen((char const   *)string);
#line 1561
          string_len = (unsigned int )tmp___1;
          }
        }
        {
#line 1564
        memmove((void *)(p + i), (void const   *)(p + i / 2), (size_t )((((long )string_len - (p - string)) - (long )(i / 2)) + 1L));
#line 1565
        p += i / 2;
        }
#line 1566
        if (i % 2 == 0) {
#line 1569
          return (p);
        }
      } else {
#line 1575
        return (p);
      }
    } else {
#line 1575
      return (p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1579
  return ((char *)0);
}
}
#line 1584 "/home/khheo/testset/make-3.76.1/read.c"
char *find_percent(char *pattern ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 1588
  tmp = find_char_unquote(pattern, (char *)"%", 0);
  }
#line 1588
  return (tmp);
}
}
#line 1604 "/home/khheo/testset/make-3.76.1/read.c"
struct nameseq *parse_file_seq(char **stringp , int stopchar , unsigned int size ,
                               int strip ) 
{ 
  register struct nameseq *new ;
  register struct nameseq *new1 ;
  register struct nameseq *lastnew1 ;
  register char *p ;
  char *q ;
  char *name___0 ;
  char stopchars[3] ;
  size_t tmp ;
  char *tmp___0 ;
  struct nameseq *n ;
  struct nameseq *lastn ;
  char *paren ;
  char *libname ;
  void *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 1611
  new = (struct nameseq *)0;
#line 1613
  p = *stringp;
#line 1623
  stopchars[0] = (char )stopchar;
#line 1624
  stopchars[1] = (char )'\000';
  {
#line 1627
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1630
    p = next_token(p);
    }
#line 1631
    if ((int )*p == 0) {
#line 1632
      goto while_break;
    }
#line 1633
    if ((int )*p == stopchar) {
#line 1634
      goto while_break;
    }
    {
#line 1637
    q = p;
#line 1638
    p = find_char_unquote(q, stopchars, 1);
    }
#line 1669
    if ((unsigned long )p == (unsigned long )((char *)0)) {
      {
#line 1670
      tmp = strlen((char const   *)q);
#line 1670
      p = q + tmp;
      }
    }
#line 1672
    if (strip) {
      {
#line 1678
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1678
        if (p - q > 2L) {
#line 1678
          if ((int )*(q + 0) == 46) {
#line 1678
            if (! ((int )*(q + 1) == 47)) {
#line 1678
              goto while_break___0;
            }
          } else {
#line 1678
            goto while_break___0;
          }
        } else {
#line 1678
          goto while_break___0;
        }
#line 1681
        q += 2;
        {
#line 1682
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1682
          if ((unsigned long )q < (unsigned long )p) {
#line 1682
            if (! ((int )*q == 47)) {
#line 1682
              goto while_break___1;
            }
          } else {
#line 1682
            goto while_break___1;
          }
#line 1684
          q ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1689
    if ((unsigned long )q == (unsigned long )p) {
      {
#line 1697
      name___0 = savestring("./", 2);
      }
    } else {
      {
#line 1726
      name___0 = savestring(q, p - q);
      }
    }
    {
#line 1730
    tmp___0 = xmalloc(size);
#line 1730
    new1 = (struct nameseq *)tmp___0;
#line 1731
    new1->name = name___0;
#line 1732
    new1->next = new;
#line 1733
    new = new1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1743
  new1 = new;
#line 1744
  lastnew1 = (struct nameseq *)0;
  {
#line 1745
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1745
    if (! ((unsigned long )new1 != (unsigned long )((struct nameseq *)0))) {
#line 1745
      goto while_break___2;
    }
#line 1746
    if ((int )*(new1->name + 0) != 40) {
      {
#line 1746
      tmp___2 = strlen((char const   *)new1->name);
      }
#line 1746
      if ((int )*(new1->name + (tmp___2 - 1UL)) == 41) {
        {
#line 1746
        tmp___3 = strchr((char const   *)new1->name, '(');
        }
#line 1746
        if ((unsigned long )tmp___3 == (unsigned long )((char *)0)) {
#line 1753
          n = new1->next;
#line 1753
          lastn = new1;
          {
#line 1755
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1755
            if ((unsigned long )n != (unsigned long )((struct nameseq *)0)) {
              {
#line 1755
              paren = strchr((char const   *)n->name, '(');
              }
#line 1755
              if (! ((unsigned long )paren == (unsigned long )((char *)0))) {
#line 1755
                goto while_break___3;
              }
            } else {
#line 1755
              goto while_break___3;
            }
#line 1757
            lastn = n;
#line 1758
            n = n->next;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1760
          if ((unsigned long )n != (unsigned long )((struct nameseq *)0)) {
#line 1760
            if ((int )*(n->name + 0) != 40) {
              {
#line 1772
              paren ++;
#line 1773
              tmp___1 = __builtin_alloca((unsigned long )((paren - n->name) + 1L));
#line 1773
              libname = (char *)tmp___1;
#line 1774
              memmove((void *)libname, (void const   *)n->name, (size_t )(paren - n->name));
#line 1775
              *(libname + (paren - n->name)) = (char )'\000';
              }
#line 1777
              if ((int )*paren == 0) {
                {
#line 1781
                lastn->next = n->next;
#line 1782
                free((void *)n->name);
#line 1783
                free((void *)((char *)n));
#line 1785
                n = lastn->next;
                }
              } else {
                {
#line 1790
                name___0 = concat(libname, paren, ")");
#line 1791
                free((void *)n->name);
#line 1792
                n->name = name___0;
                }
              }
#line 1795
              if ((int )*(new1->name + 1) == 0) {
#line 1799
                if ((unsigned long )lastnew1 == (unsigned long )((struct nameseq *)0)) {
#line 1800
                  new = new1->next;
                } else {
#line 1802
                  lastnew1->next = new1->next;
                }
                {
#line 1803
                lastn = new1;
#line 1804
                new1 = new1->next;
#line 1805
                free((void *)lastn->name);
#line 1806
                free((void *)((char *)lastn));
                }
              } else {
                {
#line 1811
                name___0 = concat(libname, new1->name, "");
#line 1812
                free((void *)new1->name);
#line 1813
                new1->name = name___0;
#line 1814
                new1 = new1->next;
                }
              }
              {
#line 1821
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 1821
                if (! ((unsigned long )new1 != (unsigned long )n)) {
#line 1821
                  goto while_break___4;
                }
                {
#line 1823
                name___0 = concat(libname, new1->name, ")");
#line 1824
                free((void *)new1->name);
#line 1825
                new1->name = name___0;
#line 1826
                lastnew1 = new1;
#line 1827
                new1 = new1->next;
                }
              }
              while_break___4: /* CIL Label */ ;
              }
            } else {
#line 1833
              lastnew1 = new1;
#line 1834
              new1 = new1->next;
            }
          } else {
#line 1833
            lastnew1 = new1;
#line 1834
            new1 = new1->next;
          }
        } else {
#line 1839
          lastnew1 = new1;
#line 1840
          new1 = new1->next;
        }
      } else {
#line 1839
        lastnew1 = new1;
#line 1840
        new1 = new1->next;
      }
    } else {
#line 1839
      lastnew1 = new1;
#line 1840
      new1 = new1->next;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1845
  *stringp = p;
#line 1846
  return (new);
}
}
#line 1854 "/home/khheo/testset/make-3.76.1/read.c"
static unsigned int readline(struct linebuffer *linebuffer , FILE *stream , char *filename ,
                             unsigned int lineno ) 
{ 
  char *buffer ;
  register char *p ;
  register char *end ;
  register int len ;
  register int lastlen ;
  register char *p2 ;
  register unsigned int nlines ;
  register int backslash ;
  size_t tmp ;
  register unsigned int p_off ;
  char *tmp___0 ;
  register unsigned int p_off___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp20 ;

  {
#line 1861
  buffer = linebuffer->buffer;
#line 1862
  p = linebuffer->buffer;
#line 1863
  end = p + linebuffer->size;
#line 1864
  lastlen = 0;
#line 1866
  nlines = 0U;
#line 1869
  *p = (char )'\000';
  {
#line 1871
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1871
    tmp___2 = fgets((char */* __restrict  */)p, (int )(end - p), (FILE */* __restrict  */)stream);
    }
#line 1871
    if (! ((unsigned long )tmp___2 != (unsigned long )((char *)0))) {
#line 1871
      goto while_break;
    }
    {
#line 1873
    tmp = strlen((char const   *)p);
#line 1873
    len = (int )tmp;
    }
#line 1874
    if (len == 0) {
      {
#line 1881
      makefile_error(filename, lineno, "warning: NUL character seen; rest of line ignored");
#line 1883
      *(p + 0) = (char )'\n';
#line 1884
      len = 1;
      }
    }
#line 1887
    p += len;
#line 1888
    if ((int )*(p + -1) != 10) {
      {
#line 1891
      p_off = (unsigned int )(p - buffer);
#line 1892
      linebuffer->size *= 2U;
#line 1893
      tmp___0 = xrealloc(buffer, linebuffer->size);
#line 1893
      buffer = tmp___0;
#line 1894
      p = buffer + p_off;
#line 1895
      end = buffer + linebuffer->size;
#line 1896
      linebuffer->buffer = buffer;
#line 1897
      *p = (char )'\000';
#line 1898
      lastlen = len;
      }
#line 1899
      goto while_continue;
    }
#line 1902
    nlines ++;
#line 1904
    if (len == 1) {
#line 1904
      if ((unsigned long )p > (unsigned long )buffer) {
#line 1912
        len += lastlen;
      }
    }
#line 1913
    lastlen = len;
#line 1914
    backslash = 0;
#line 1915
    p2 = p - 2;
    {
#line 1915
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1915
      len --;
#line 1915
      if (! (len > 0)) {
#line 1915
        goto while_break___0;
      }
#line 1917
      if ((int )*p2 == 92) {
#line 1918
        backslash = ! backslash;
      } else {
#line 1920
        goto while_break___0;
      }
#line 1915
      p2 --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1923
    if (! backslash) {
#line 1925
      *(p + -1) = (char )'\000';
#line 1926
      goto while_break;
    }
#line 1929
    if (end - p <= 1L) {
      {
#line 1932
      p_off___0 = (unsigned int )(p - buffer);
#line 1933
      linebuffer->size *= 2U;
#line 1934
      tmp___1 = xrealloc(buffer, linebuffer->size);
#line 1934
      buffer = tmp___1;
#line 1935
      p = buffer + p_off___0;
#line 1936
      end = buffer + linebuffer->size;
#line 1937
      linebuffer->buffer = buffer;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1941
  tmp___3 = ferror(stream);
  }
#line 1941
  if (tmp___3) {
    {
#line 1942
    pfatal_with_name(filename);
    }
  }
#line 1944
  return (nlines);
}
}
#line 1950 "/home/khheo/testset/make-3.76.1/read.c"
void construct_include_path(char **arg_dirs ) 
{ 
  register unsigned int i ;
  struct stat stbuf ;
  register unsigned int defsize ;
  register unsigned int max ;
  register char **dirs___0 ;
  char *tmp ;
  register unsigned int idx ;
  char *dir ;
  char **tmp___0 ;
  char *expanded ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  unsigned int len ;
  size_t tmp___7 ;

  {
  {
#line 1962
  defsize = (unsigned int )(sizeof(default_include_directories) / sizeof(default_include_directories[0]));
#line 1964
  max = 5U;
#line 1965
  tmp = xmalloc((unsigned long )(5U + defsize) * sizeof(char *));
#line 1965
  dirs___0 = (char **)tmp;
#line 1966
  idx = 0U;
  }
#line 1975
  if ((unsigned long )arg_dirs != (unsigned long )((char **)0)) {
    {
#line 1976
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1976
      if (! ((unsigned long )*arg_dirs != (unsigned long )((char *)0))) {
#line 1976
        goto while_break;
      }
#line 1978
      tmp___0 = arg_dirs;
#line 1978
      arg_dirs ++;
#line 1978
      dir = *tmp___0;
#line 1980
      if ((int )*(dir + 0) == 126) {
        {
#line 1982
        tmp___1 = tilde_expand(dir);
#line 1982
        expanded = tmp___1;
        }
#line 1983
        if ((unsigned long )expanded != (unsigned long )((char *)0)) {
#line 1984
          dir = expanded;
        }
      }
      {
#line 1987
      tmp___4 = stat((char const   */* __restrict  */)dir, (struct stat */* __restrict  */)(& stbuf));
      }
#line 1987
      if (tmp___4 == 0) {
#line 1987
        if ((stbuf.st_mode & 61440U) == 16384U) {
#line 1989
          if (idx == max - 1U) {
            {
#line 1991
            max += 5U;
#line 1992
            tmp___2 = xrealloc((char *)dirs___0, (unsigned long )(max + defsize) * sizeof(char *));
#line 1992
            dirs___0 = (char **)tmp___2;
            }
          }
#line 1995
          tmp___3 = idx;
#line 1995
          idx ++;
#line 1995
          *(dirs___0 + tmp___3) = dir;
        } else {
#line 1987
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1997
      if ((unsigned long )dir != (unsigned long )*(arg_dirs + -1)) {
        {
#line 1998
        free((void *)dir);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2019
  i = 0U;
  {
#line 2019
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2019
    if (! ((unsigned long )default_include_directories[i] != (unsigned long )((char *)0))) {
#line 2019
      goto while_break___0;
    }
    {
#line 2020
    tmp___6 = stat((char const   */* __restrict  */)default_include_directories[i],
                   (struct stat */* __restrict  */)(& stbuf));
    }
#line 2020
    if (tmp___6 == 0) {
#line 2020
      if ((stbuf.st_mode & 61440U) == 16384U) {
#line 2022
        tmp___5 = idx;
#line 2022
        idx ++;
#line 2022
        *(dirs___0 + tmp___5) = default_include_directories[i];
      }
    }
#line 2019
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2024
  *(dirs___0 + idx) = (char *)0;
#line 2028
  max_incl_len = 0U;
#line 2029
  i = 0U;
  {
#line 2029
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2029
    if (! (i < idx)) {
#line 2029
      goto while_break___1;
    }
    {
#line 2031
    tmp___7 = strlen((char const   *)*(dirs___0 + i));
#line 2031
    len = (unsigned int )tmp___7;
    }
#line 2033
    if ((int )*(*(dirs___0 + i) + (len - 1U)) == 47) {
      {
#line 2036
      *(dirs___0 + i) = savestring(*(dirs___0 + i), len - 1U);
      }
    }
#line 2037
    if (len > max_incl_len) {
#line 2038
      max_incl_len = len;
    }
#line 2029
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2041
  include_directories = dirs___0;
#line 2042
  return;
}
}
#line 2047 "/home/khheo/testset/make-3.76.1/read.c"
char *tilde_expand(char *name___0 ) 
{ 
  char *home_dir ;
  int is_variable ;
  int save ;
  char *name___1 ;
  char *tmp ;
  struct passwd *p ;
  struct passwd *tmp___0 ;
  char *new ;
  char *tmp___1 ;
  struct passwd *pwent ;
  char *userend ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 2052
  if ((int )*(name___0 + 1) == 47) {
#line 2052
    goto _L___0;
  } else
#line 2052
  if ((int )*(name___0 + 1) == 0) {
    _L___0: /* CIL Label */ 
    {
#line 2060
    save = warn_undefined_variables_flag;
#line 2061
    warn_undefined_variables_flag = 0;
#line 2063
    home_dir = allocated_variable_expand_for_file((char *)"$(HOME)", (struct file *)0);
#line 2065
    warn_undefined_variables_flag = save;
#line 2068
    is_variable = (int )*(home_dir + 0) != 0;
    }
#line 2069
    if (! is_variable) {
      {
#line 2071
      free((void *)home_dir);
#line 2072
      home_dir = getenv("HOME");
      }
    }
#line 2075
    if ((unsigned long )home_dir == (unsigned long )((char *)0)) {
#line 2075
      goto _L;
    } else
#line 2075
    if ((int )*(home_dir + 0) == 0) {
      _L: /* CIL Label */ 
      {
#line 2078
      tmp = getlogin();
#line 2078
      name___1 = tmp;
#line 2079
      home_dir = (char *)0;
      }
#line 2080
      if ((unsigned long )name___1 != (unsigned long )((char *)0)) {
        {
#line 2082
        tmp___0 = getpwnam((char const   *)name___1);
#line 2082
        p = tmp___0;
        }
#line 2083
        if ((unsigned long )p != (unsigned long )((struct passwd *)0)) {
#line 2084
          home_dir = p->pw_dir;
        }
      }
    }
#line 2088
    if ((unsigned long )home_dir != (unsigned long )((char *)0)) {
      {
#line 2090
      tmp___1 = concat(home_dir, "", name___0 + 1);
#line 2090
      new = tmp___1;
      }
#line 2091
      if (is_variable) {
        {
#line 2092
        free((void *)home_dir);
        }
      }
#line 2093
      return (new);
    }
  } else {
    {
#line 2100
    tmp___2 = strchr((char const   *)(name___0 + 1), '/');
#line 2100
    userend = tmp___2;
    }
#line 2101
    if ((unsigned long )userend != (unsigned long )((char *)0)) {
#line 2102
      *userend = (char )'\000';
    }
    {
#line 2103
    pwent = getpwnam((char const   *)(name___0 + 1));
    }
#line 2104
    if ((unsigned long )pwent != (unsigned long )((struct passwd *)0)) {
#line 2106
      if ((unsigned long )userend == (unsigned long )((char *)0)) {
        {
#line 2107
        tmp___3 = strlen((char const   *)pwent->pw_dir);
#line 2107
        tmp___4 = savestring(pwent->pw_dir, tmp___3);
        }
#line 2107
        return (tmp___4);
      } else {
        {
#line 2109
        tmp___5 = concat(pwent->pw_dir, "/", userend + 1);
        }
#line 2109
        return (tmp___5);
      }
    } else
#line 2111
    if ((unsigned long )userend != (unsigned long )((char *)0)) {
#line 2112
      *userend = (char )'/';
    }
  }
#line 2116
  return ((char *)0);
}
}
#line 2134
void dir_setup_glob(glob_t *gl ) ;
#line 2129 "/home/khheo/testset/make-3.76.1/read.c"
struct nameseq *multi_glob(struct nameseq *chain , unsigned int size ) 
{ 
  register struct nameseq *new ;
  register struct nameseq *old ;
  struct nameseq *nexto ;
  glob_t gl ;
  char *memname ;
  char *newname ;
  char *tmp ;
  char *arname ;
  int tmp___0 ;
  int tmp___1 ;
  register int i ;
  struct nameseq *found ;
  struct nameseq *tmp___2 ;
  struct nameseq *elt ;
  char *tmp___3 ;
  unsigned int alen ;
  size_t tmp___4 ;
  unsigned int mlen ;
  size_t tmp___5 ;
  char *tmp___6 ;
  struct nameseq *f ;
  struct nameseq *elt___0 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp28 ;

  {
  {
#line 2135
  new = (struct nameseq *)0;
#line 2140
  dir_setup_glob(& gl);
#line 2142
  old = chain;
  }
  {
#line 2142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2142
    if (! ((unsigned long )old != (unsigned long )((struct nameseq *)0))) {
#line 2142
      goto while_break;
    }
#line 2148
    nexto = old->next;
#line 2150
    if ((int )*(old->name + 0) == 126) {
      {
#line 2152
      tmp = tilde_expand(old->name);
#line 2152
      newname = tmp;
      }
#line 2153
      if ((unsigned long )newname != (unsigned long )((char *)0)) {
        {
#line 2155
        free((void *)old->name);
#line 2156
        old->name = newname;
        }
      }
    }
    {
#line 2161
    tmp___0 = ar_name(old->name);
    }
#line 2161
    if (tmp___0) {
      {
#line 2169
      ar_parse_name(old->name, & arname, & memname);
#line 2170
      free((void *)old->name);
#line 2171
      old->name = arname;
      }
    } else {
#line 2174
      memname = (char *)0;
    }
    {
#line 2177
    tmp___1 = glob((char const   *)old->name, (1 << 4) | (1 << 9), (int (*)(char const   * ,
                                                                            int  ))((void *)0),
                   & gl);
    }
    {
#line 2179
    if (tmp___1 == 0) {
#line 2179
      goto case_0;
    }
#line 2237
    if (tmp___1 == 1) {
#line 2237
      goto case_1;
    }
#line 2241
    goto switch_default;
    case_0: /* CIL Label */ 
#line 2181
    i = gl.gl_pathc;
    {
#line 2182
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2182
      tmp___9 = i;
#line 2182
      i --;
#line 2182
      if (! (tmp___9 > 0)) {
#line 2182
        goto while_break___0;
      }
#line 2185
      if ((unsigned long )memname != (unsigned long )((char *)0)) {
        {
#line 2188
        tmp___2 = ar_glob(*(gl.gl_pathv + i), memname, size);
#line 2188
        found = tmp___2;
        }
#line 2190
        if ((unsigned long )found == (unsigned long )((struct nameseq *)0)) {
          {
#line 2193
          tmp___3 = xmalloc(size);
#line 2193
          elt = (struct nameseq *)tmp___3;
#line 2195
          tmp___4 = strlen((char const   *)*(gl.gl_pathv + i));
#line 2195
          alen = (unsigned int )tmp___4;
#line 2196
          tmp___5 = strlen((char const   *)memname);
#line 2196
          mlen = (unsigned int )tmp___5;
#line 2197
          tmp___6 = xmalloc(((alen + 1U) + mlen) + 2U);
#line 2197
          elt->name = tmp___6;
#line 2198
          memmove((void *)elt->name, (void const   *)*(gl.gl_pathv + i), (size_t )alen);
#line 2199
          *(elt->name + alen) = (char )'(';
#line 2200
          memmove((void *)(elt->name + (alen + 1U)), (void const   *)memname, (size_t )mlen);
#line 2201
          *(elt->name + ((alen + 1U) + mlen)) = (char )')';
#line 2202
          *(elt->name + (((alen + 1U) + mlen) + 1U)) = (char )'\000';
#line 2203
          elt->next = new;
#line 2204
          new = elt;
          }
        } else {
#line 2209
          f = found;
          {
#line 2210
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2210
            if (! ((unsigned long )f->next != (unsigned long )((struct nameseq *)0))) {
#line 2210
              goto while_break___1;
            }
#line 2211
            f = f->next;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 2215
          f->next = new;
#line 2216
          new = found;
        }
        {
#line 2219
        free((void *)memname);
        }
      } else {
        {
#line 2224
        tmp___7 = xmalloc(size);
#line 2224
        elt___0 = (struct nameseq *)tmp___7;
#line 2225
        tmp___8 = strlen((char const   *)*(gl.gl_pathv + i));
#line 2225
        elt___0->name = savestring(*(gl.gl_pathv + i), tmp___8);
#line 2227
        elt___0->next = new;
#line 2228
        new = elt___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2231
    globfree(& gl);
#line 2232
    free((void *)old->name);
#line 2233
    free((void *)((char *)old));
    }
#line 2234
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 2238
    fatal("virtual memory exhausted");
    }
#line 2239
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2242
    old->next = new;
#line 2243
    new = old;
#line 2244
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2142
    old = nexto;
  }
  while_break: /* CIL Label */ ;
  }
#line 2248
  return (new);
}
}
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 356 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 675 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 710
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) seteuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 727
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setegid)(__gid_t __gid ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 315 "/home/khheo/testset/make-3.76.1/make.h"
void die(int status ) ;
#line 319
void log_working_directory(int entering ) ;
#line 374
void user_access(void) ;
#line 375
void make_access(void) ;
#line 376
void child_access(void) ;
#line 423
char *program ;
#line 27 "/home/khheo/testset/make-3.76.1/misc.c"
int alpha_compare(char **s1 , char **s2 ) 
{ 
  int tmp ;

  {
#line 31
  if ((int )*(*s1) != (int )*(*s2)) {
#line 32
    return ((int )*(*s1) - (int )*(*s2));
  }
  {
#line 33
  tmp = strcmp((char const   *)*s1, (char const   *)*s2);
  }
#line 33
  return (tmp);
}
}
#line 40 "/home/khheo/testset/make-3.76.1/misc.c"
void collapse_continuations(char *line ) 
{ 
  register char *in ;
  register char *out ;
  register char *p ;
  register int backslash ;
  register unsigned int bs_write ;
  char *tmp ;
  unsigned int tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 48
  in = strchr((char const   *)line, '\n');
  }
#line 49
  if ((unsigned long )in == (unsigned long )((char *)0)) {
#line 50
    return;
  }
#line 52
  out = in;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if ((unsigned long )out > (unsigned long )line) {
#line 53
      if (! ((int )*(out + -1) == 92)) {
#line 53
        goto while_break;
      }
    } else {
#line 53
      goto while_break;
    }
#line 54
    out --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 56
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 56
    if (! ((int )*in != 0)) {
#line 56
      goto while_break___0;
    }
#line 61
    backslash = 0;
#line 62
    bs_write = 0U;
#line 63
    p = in - 1;
    {
#line 63
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 63
      if ((unsigned long )p >= (unsigned long )line) {
#line 63
        if (! ((int )*p == 92)) {
#line 63
          goto while_break___1;
        }
      } else {
#line 63
        goto while_break___1;
      }
#line 65
      if (backslash) {
#line 66
        bs_write ++;
      }
#line 67
      backslash = ! backslash;
#line 71
      if ((unsigned long )in == (unsigned long )(out - 1)) {
        {
#line 72
        abort();
        }
      }
#line 63
      p --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 76
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 76
      tmp___0 = bs_write;
#line 76
      bs_write --;
#line 76
      if (! (tmp___0 > 0U)) {
#line 76
        goto while_break___2;
      }
#line 77
      tmp = out;
#line 77
      out ++;
#line 77
      *tmp = (char )'\\';
    }
    while_break___2: /* CIL Label */ ;
    }
#line 80
    in ++;
#line 84
    if (backslash) {
      {
#line 86
      in = next_token(in);
      }
      {
#line 87
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 87
        if ((unsigned long )out > (unsigned long )line) {
          {
#line 87
          tmp___1 = __ctype_b_loc();
          }
#line 87
          if (! ((int const   )*(*tmp___1 + (int )*(out + -1)) & 1)) {
#line 87
            goto while_break___3;
          }
        } else {
#line 87
          goto while_break___3;
        }
#line 88
        out --;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 89
      tmp___2 = out;
#line 89
      out ++;
#line 89
      *tmp___2 = (char )' ';
    } else {
#line 93
      tmp___3 = out;
#line 93
      out ++;
#line 93
      *tmp___3 = (char )'\n';
    }
    {
#line 97
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 97
      if (! ((int )*in != 0)) {
#line 97
        goto while_break___4;
      }
#line 98
      if ((int )*in == 92) {
#line 100
        p = in + 1;
        {
#line 101
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 101
          if (! ((int )*p == 92)) {
#line 101
            goto while_break___5;
          }
#line 102
          p ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 103
        if ((int )*p == 10) {
#line 105
          in = p;
#line 106
          goto while_break___4;
        }
        {
#line 108
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 108
          if (! ((unsigned long )in < (unsigned long )p)) {
#line 108
            goto while_break___6;
          }
#line 109
          tmp___4 = out;
#line 109
          out ++;
#line 109
          tmp___5 = in;
#line 109
          in ++;
#line 109
          *tmp___4 = *tmp___5;
        }
        while_break___6: /* CIL Label */ ;
        }
      } else {
#line 112
        tmp___6 = out;
#line 112
        out ++;
#line 112
        tmp___7 = in;
#line 112
        in ++;
#line 112
        *tmp___6 = *tmp___7;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 115
  *out = (char )'\000';
#line 116
  return;
}
}
#line 122 "/home/khheo/testset/make-3.76.1/misc.c"
void remove_comments(char *line ) 
{ 
  char *comment ;
  char *__cil_tmp3 ;

  {
  {
#line 128
  comment = find_char_unquote(line, "#", 0);
  }
#line 130
  if ((unsigned long )comment != (unsigned long )((char *)0)) {
#line 132
    *comment = (char )'\000';
  }
#line 133
  return;
}
}
#line 137 "/home/khheo/testset/make-3.76.1/misc.c"
void print_spaces(unsigned int n ) 
{ 
  unsigned int tmp ;

  {
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    tmp = n;
#line 141
    n --;
#line 141
    if (! (tmp > 0U)) {
#line 141
      goto while_break;
    }
    {
#line 142
    putchar(' ');
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 149 "/home/khheo/testset/make-3.76.1/misc.c"
char *concat(char *s1 , char *s2 , char *s3 ) 
{ 
  register unsigned int len1 ;
  register unsigned int len2 ;
  register unsigned int len3 ;
  register char *result___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
#line 156
  if ((int )*s1 != 0) {
    {
#line 156
    tmp = strlen((char const   *)s1);
#line 156
    len1 = (unsigned int )tmp;
    }
  } else {
#line 156
    len1 = 0U;
  }
#line 157
  if ((int )*s2 != 0) {
    {
#line 157
    tmp___0 = strlen((char const   *)s2);
#line 157
    len2 = (unsigned int )tmp___0;
    }
  } else {
#line 157
    len2 = 0U;
  }
#line 158
  if ((int )*s3 != 0) {
    {
#line 158
    tmp___1 = strlen((char const   *)s3);
#line 158
    len3 = (unsigned int )tmp___1;
    }
  } else {
#line 158
    len3 = 0U;
  }
  {
#line 160
  tmp___2 = xmalloc(((len1 + len2) + len3) + 1U);
#line 160
  result___0 = tmp___2;
  }
#line 162
  if ((int )*s1 != 0) {
    {
#line 163
    memmove((void *)result___0, (void const   *)s1, (size_t )len1);
    }
  }
#line 164
  if ((int )*s2 != 0) {
    {
#line 165
    memmove((void *)(result___0 + len1), (void const   *)s2, (size_t )len2);
    }
  }
#line 166
  if ((int )*s3 != 0) {
    {
#line 167
    memmove((void *)((result___0 + len1) + len2), (void const   *)s3, (size_t )len3);
    }
  }
#line 168
  *(((result___0 + len1) + len2) + len3) = (char )'\000';
#line 170
  return (result___0);
}
}
#line 175 "/home/khheo/testset/make-3.76.1/misc.c"
void message(int prefix , char *s1 , char *s2 , char *s3 , char *s4 , char *s5 , char *s6 ) 
{ 
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 180
  log_working_directory(1);
  }
#line 182
  if ((unsigned long )s1 != (unsigned long )((char *)0)) {
#line 184
    if (prefix) {
#line 186
      if (makelevel == 0U) {
        {
#line 187
        printf((char const   */* __restrict  */)"%s: ", program);
        }
      } else {
        {
#line 189
        printf((char const   */* __restrict  */)"%s[%u]: ", program, makelevel);
        }
      }
    }
    {
#line 191
    printf((char const   */* __restrict  */)s1, s2, s3, s4, s5, s6);
#line 192
    putchar('\n');
    }
  }
  {
#line 195
  fflush(stdout);
  }
#line 196
  return;
}
}
#line 201 "/home/khheo/testset/make-3.76.1/misc.c"
void fatal(char *s1 , char *s2 , char *s3 , char *s4 , char *s5 , char *s6 ) 
{ 
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 205
  log_working_directory(1);
  }
#line 207
  if (makelevel == 0U) {
    {
#line 208
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: *** ",
            program);
    }
  } else {
    {
#line 210
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s[%u]: *** ",
            program, makelevel);
    }
  }
  {
#line 211
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)s1, s2,
          s3, s4, s5, s6);
#line 212
  fputs((char const   */* __restrict  */)".  Stop.\n", (FILE */* __restrict  */)stderr);
#line 214
  die(2);
  }
#line 215
  return;
}
}
#line 221 "/home/khheo/testset/make-3.76.1/misc.c"
void error(char *s1 , char *s2 , char *s3 , char *s4 , char *s5 , char *s6 ) 
{ 
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 225
  log_working_directory(1);
  }
#line 227
  if (makelevel == 0U) {
    {
#line 228
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            program);
    }
  } else {
    {
#line 230
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s[%u]: ",
            program, makelevel);
    }
  }
  {
#line 231
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)s1, s2,
          s3, s4, s5, s6);
#line 232
  _IO_putc('\n', stderr);
#line 233
  fflush(stderr);
  }
#line 234
  return;
}
}
#line 236 "/home/khheo/testset/make-3.76.1/misc.c"
void makefile_error(char *file , unsigned int lineno , char *s1 , char *s2 , char *s3 ,
                    char *s4 , char *s5 , char *s6 ) 
{ 
  char *__cil_tmp9 ;

  {
  {
#line 242
  log_working_directory(1);
#line 244
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%u: ",
          file, lineno);
#line 245
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)s1, s2,
          s3, s4, s5, s6);
#line 246
  _IO_putc('\n', stderr);
#line 247
  fflush(stderr);
  }
#line 248
  return;
}
}
#line 250 "/home/khheo/testset/make-3.76.1/misc.c"
void makefile_fatal(char *file , unsigned int lineno , char *s1 , char *s2 , char *s3 ,
                    char *s4 , char *s5 , char *s6 ) 
{ 
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 256
  log_working_directory(1);
#line 258
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%u: *** ",
          file, lineno);
#line 259
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)s1, s2,
          s3, s4, s5, s6);
#line 260
  fputs((char const   */* __restrict  */)".  Stop.\n", (FILE */* __restrict  */)stderr);
#line 262
  die(2);
  }
#line 263
  return;
}
}
#line 289 "/home/khheo/testset/make-3.76.1/misc.c"
void perror_with_name(char *str , char *name___0 ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 293
  tmp = __errno_location();
#line 293
  tmp___0 = strerror(*tmp);
#line 293
  error((char *)"%s%s: %s", str, name___0, tmp___0);
  }
#line 294
  return;
}
}
#line 298 "/home/khheo/testset/make-3.76.1/misc.c"
void pfatal_with_name(char *name___0 ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char *__cil_tmp4 ;

  {
  {
#line 302
  tmp = __errno_location();
#line 302
  tmp___0 = strerror(*tmp);
#line 302
  fatal((char *)"%s: %s", name___0, tmp___0);
  }
#line 305
  return;
}
}
#line 312 "/home/khheo/testset/make-3.76.1/misc.c"
char *xmalloc(unsigned int size ) 
{ 
  char *result___0 ;
  void *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 316
  tmp = malloc((size_t )size);
#line 316
  result___0 = (char *)tmp;
  }
#line 317
  if ((unsigned long )result___0 == (unsigned long )((char *)0)) {
    {
#line 318
    fatal((char *)"virtual memory exhausted");
    }
  }
#line 319
  return (result___0);
}
}
#line 323 "/home/khheo/testset/make-3.76.1/misc.c"
char *xrealloc(char *ptr , unsigned int size ) 
{ 
  char *result___0 ;
  void *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 328
  tmp = realloc((void *)ptr, (size_t )size);
#line 328
  result___0 = (char *)tmp;
  }
#line 329
  if ((unsigned long )result___0 == (unsigned long )((char *)0)) {
    {
#line 330
    fatal((char *)"virtual memory exhausted");
    }
  }
#line 331
  return (result___0);
}
}
#line 334 "/home/khheo/testset/make-3.76.1/misc.c"
char *savestring(char *str , unsigned int length___0 ) 
{ 
  register char *out ;
  char *tmp ;

  {
  {
#line 339
  tmp = xmalloc(length___0 + 1U);
#line 339
  out = tmp;
  }
#line 340
  if (length___0 > 0U) {
    {
#line 341
    memmove((void *)out, (void const   *)str, (size_t )length___0);
    }
  }
#line 342
  *(out + length___0) = (char )'\000';
#line 343
  return (out);
}
}
#line 350 "/home/khheo/testset/make-3.76.1/misc.c"
char *sindex(char *big , unsigned int blen , char *small , unsigned int slen ) 
{ 
  register unsigned int b ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 359
  if (blen < 1U) {
    {
#line 360
    tmp = strlen((char const   *)big);
#line 360
    blen = (unsigned int )tmp;
    }
  }
#line 361
  if (slen < 1U) {
    {
#line 362
    tmp___0 = strlen((char const   *)small);
#line 362
    slen = (unsigned int )tmp___0;
    }
  }
#line 364
  b = 0U;
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 364
    if (! (b < blen)) {
#line 364
      goto while_break;
    }
#line 365
    if ((int )*(big + b) == (int )*small) {
      {
#line 365
      tmp___1 = strncmp((char const   *)(big + (b + 1U)), (char const   *)(small + 1),
                        (size_t )(slen - 1U));
      }
#line 365
      if (! tmp___1) {
#line 366
        return (big + b);
      }
    }
#line 364
    b ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  return ((char *)0);
}
}
#line 377 "/home/khheo/testset/make-3.76.1/misc.c"
char *lindex(char *s , char *limit , int c ) 
{ 
  char *tmp ;

  {
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 382
    if (! ((unsigned long )s < (unsigned long )limit)) {
#line 382
      goto while_break;
    }
#line 383
    tmp = s;
#line 383
    s ++;
#line 383
    if ((int )*tmp == c) {
#line 384
      return (s - 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 386
  return ((char *)0);
}
}
#line 391 "/home/khheo/testset/make-3.76.1/misc.c"
char *end_of_token(char *s ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 395
  while (1) {
    while_continue: /* CIL Label */ ;
#line 395
    if ((int )*s != 0) {
      {
#line 395
      tmp = __ctype_b_loc();
      }
#line 395
      if ((int const   )*(*tmp + (int )*s) & 1) {
#line 395
        goto while_break;
      }
    } else {
#line 395
      goto while_break;
    }
#line 396
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  return (s);
}
}
#line 433 "/home/khheo/testset/make-3.76.1/misc.c"
char *next_token(char *s ) 
{ 
  register char *p ;
  unsigned short const   **tmp ;

  {
#line 437
  p = s;
  {
#line 439
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 439
    tmp = __ctype_b_loc();
    }
#line 439
    if (! ((int const   )*(*tmp + (int )*p) & 1)) {
#line 439
      goto while_break;
    }
#line 440
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  return (p);
}
}
#line 447 "/home/khheo/testset/make-3.76.1/misc.c"
char *find_next_token(char **ptr , unsigned int *lengthptr ) 
{ 
  char *p ;
  char *tmp ;
  char *end ;

  {
  {
#line 452
  tmp = next_token(*ptr);
#line 452
  p = tmp;
  }
#line 455
  if ((int )*p == 0) {
#line 456
    return ((char *)0);
  }
  {
#line 458
  end = end_of_token(p);
#line 458
  *ptr = end;
  }
#line 459
  if ((unsigned long )lengthptr != (unsigned long )((unsigned int *)0)) {
#line 460
    *lengthptr = (unsigned int )(end - p);
  }
#line 461
  return (p);
}
}
#line 467 "/home/khheo/testset/make-3.76.1/misc.c"
struct dep *copy_dep_chain(struct dep *d ) 
{ 
  register struct dep *c ;
  struct dep *firstnew ;
  struct dep *lastnew ;
  char *tmp ;
  size_t tmp___0 ;
  struct dep *tmp___1 ;

  {
#line 472
  firstnew = (struct dep *)0;
  {
#line 475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 475
    if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 475
      goto while_break;
    }
    {
#line 477
    tmp = xmalloc((unsigned int )sizeof(struct dep ));
#line 477
    c = (struct dep *)tmp;
#line 478
    memmove((void *)((char *)c), (void const   *)((char *)d), sizeof(struct dep ));
    }
#line 479
    if ((unsigned long )c->name != (unsigned long )((char *)0)) {
      {
#line 480
      tmp___0 = strlen((char const   *)c->name);
#line 480
      c->name = savestring(c->name, (unsigned int )tmp___0);
      }
    }
#line 481
    c->next = (struct dep *)0;
#line 482
    if ((unsigned long )firstnew == (unsigned long )((struct dep *)0)) {
#line 483
      lastnew = c;
#line 483
      firstnew = lastnew;
    } else {
#line 485
      tmp___1 = c;
#line 485
      lastnew->next = tmp___1;
#line 485
      lastnew = tmp___1;
    }
#line 487
    d = d->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 490
  return (firstnew);
}
}
#line 549 "/home/khheo/testset/make-3.76.1/misc.c"
static int user_uid  =    -1;
#line 549 "/home/khheo/testset/make-3.76.1/misc.c"
static int user_gid  =    -1;
#line 549 "/home/khheo/testset/make-3.76.1/misc.c"
static int make_uid  =    -1;
#line 549 "/home/khheo/testset/make-3.76.1/misc.c"
static int make_gid  =    -1;
#line 551 "/home/khheo/testset/make-3.76.1/misc.c"
static enum __anonenum_current_access_55 current_access  ;
#line 556 "/home/khheo/testset/make-3.76.1/misc.c"
static void log_access(char *flavor ) 
{ 
  __gid_t tmp ;
  __gid_t tmp___0 ;
  __uid_t tmp___1 ;
  __uid_t tmp___2 ;
  char *__cil_tmp6 ;

  {
#line 560
  if (! debug_flag) {
#line 561
    return;
  }
  {
#line 567
  tmp = getgid();
#line 567
  tmp___0 = getegid();
#line 567
  tmp___1 = getuid();
#line 567
  tmp___2 = geteuid();
#line 567
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s access: user %d (real %d), group %d (real %d)\n",
          flavor, tmp___2, tmp___1, tmp___0, tmp);
#line 569
  fflush(stderr);
  }
#line 570
  return;
}
}
#line 573 "/home/khheo/testset/make-3.76.1/misc.c"
static void init_access(void) 
{ 
  __uid_t tmp ;
  __gid_t tmp___0 ;
  __uid_t tmp___1 ;
  __gid_t tmp___2 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 577
  tmp = getuid();
#line 577
  user_uid = (int )tmp;
#line 578
  tmp___0 = getgid();
#line 578
  user_gid = (int )tmp___0;
#line 580
  tmp___1 = geteuid();
#line 580
  make_uid = (int )tmp___1;
#line 581
  tmp___2 = getegid();
#line 581
  make_gid = (int )tmp___2;
  }
#line 584
  if (user_uid == -1) {
    {
#line 585
    pfatal_with_name((char *)"get{e}[gu]id");
    }
  } else
#line 584
  if (user_gid == -1) {
    {
#line 585
    pfatal_with_name((char *)"get{e}[gu]id");
    }
  } else
#line 584
  if (make_uid == -1) {
    {
#line 585
    pfatal_with_name((char *)"get{e}[gu]id");
    }
  } else
#line 584
  if (make_gid == -1) {
    {
#line 585
    pfatal_with_name((char *)"get{e}[gu]id");
    }
  }
  {
#line 587
  log_access((char *)"Initialized");
#line 589
  current_access = (enum __anonenum_current_access_55 )0;
  }
#line 591
  return;
}
}
#line 597 "/home/khheo/testset/make-3.76.1/misc.c"
void user_access(void) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 602
  if (! (user_uid != -1)) {
    {
#line 603
    init_access();
    }
  }
#line 605
  if ((unsigned int )current_access == 1U) {
#line 606
    return;
  }
  {
#line 618
  tmp = seteuid((__uid_t )user_uid);
  }
#line 618
  if (tmp < 0) {
    {
#line 619
    pfatal_with_name((char *)"user_access: seteuid");
    }
  }
  {
#line 652
  tmp___0 = setegid((__gid_t )user_gid);
  }
#line 652
  if (tmp___0 < 0) {
    {
#line 653
    pfatal_with_name((char *)"user_access: setegid");
    }
  }
  {
#line 664
  current_access = (enum __anonenum_current_access_55 )1;
#line 666
  log_access((char *)"User");
  }
#line 669
  return;
}
}
#line 673 "/home/khheo/testset/make-3.76.1/misc.c"
void make_access(void) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 678
  if (! (user_uid != -1)) {
    {
#line 679
    init_access();
    }
  }
#line 681
  if ((unsigned int )current_access == 0U) {
#line 682
    return;
  }
  {
#line 687
  tmp = seteuid((__uid_t )make_uid);
  }
#line 687
  if (tmp < 0) {
    {
#line 688
    pfatal_with_name((char *)"make_access: seteuid");
    }
  }
  {
#line 700
  tmp___0 = setegid((__gid_t )make_gid);
  }
#line 700
  if (tmp___0 < 0) {
    {
#line 701
    pfatal_with_name((char *)"make_access: setegid");
    }
  }
  {
#line 712
  current_access = (enum __anonenum_current_access_55 )0;
#line 714
  log_access((char *)"Make");
  }
#line 717
  return;
}
}
#line 721 "/home/khheo/testset/make-3.76.1/misc.c"
void child_access(void) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 726
  if (! (user_uid != -1)) {
    {
#line 727
    abort();
    }
  }
  {
#line 733
  tmp = setuid((__uid_t )user_uid);
  }
#line 733
  if (tmp < 0) {
    {
#line 734
    pfatal_with_name((char *)"child_access: setuid");
    }
  }
  {
#line 741
  tmp___0 = setgid((__gid_t )user_gid);
  }
#line 741
  if (tmp___0 < 0) {
    {
#line 742
    pfatal_with_name((char *)"child_access: setgid");
    }
  }
  {
#line 748
  log_access((char *)"Child");
  }
#line 751
  return;
}
}
#line 264 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 409 "/home/khheo/testset/make-3.76.1/make.h"
int ignore_errors_flag ;
#line 413
int posix_pedantic ;
#line 93 "/home/khheo/testset/make-3.76.1/filedef.h"
void remove_intermediates(int sig ) ;
#line 93
void snap_deps(void) ;
#line 94
void file_hash_enter(struct file *file , char *name___0 , unsigned int oldhash , char *oldname ) ;
#line 33 "/home/khheo/testset/make-3.76.1/file.c"
static struct file *files[1007]  ;
#line 37 "/home/khheo/testset/make-3.76.1/file.c"
unsigned int num_intermediates  =    0U;
#line 45 "/home/khheo/testset/make-3.76.1/file.c"
struct file *lookup_file(char *name___0 ) 
{ 
  register struct file *f ;
  register char *n ;
  register unsigned int hashval ;
  int tmp ;
  char *__cil_tmp6 ;

  {
#line 53
  if ((int )*name___0 == 0) {
    {
#line 54
    abort();
    }
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if ((int )*(name___0 + 0) == 46) {
#line 63
      if ((int )*(name___0 + 1) == 47) {
#line 63
        if (! ((int )*(name___0 + 2) != 0)) {
#line 63
          goto while_break;
        }
      } else {
#line 63
        goto while_break;
      }
    } else {
#line 63
      goto while_break;
    }
#line 65
    name___0 += 2;
    {
#line 66
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 66
      if (! ((int )*name___0 == 47)) {
#line 66
        goto while_break___0;
      }
#line 68
      name___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  if ((int )*name___0 == 0) {
#line 79
    name___0 = (char *)"./";
  }
#line 83
  hashval = 0U;
#line 84
  n = name___0;
  {
#line 84
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 84
    if (! ((int )*n != 0)) {
#line 84
      goto while_break___1;
    }
#line 85
    hashval += (unsigned int )*n;
#line 85
    hashval = (hashval << 7) + (hashval >> 20);
#line 84
    n ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 86
  hashval %= 1007U;
#line 88
  f = files[hashval];
  {
#line 88
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 88
    if (! ((unsigned long )f != (unsigned long )((struct file *)0))) {
#line 88
      goto while_break___2;
    }
#line 90
    if ((unsigned long )f->hname == (unsigned long )name___0) {
#line 92
      return (f);
    } else
#line 90
    if ((int )*(f->hname) == (int )*name___0) {
#line 90
      if ((int )*(f->hname) == 0) {
#line 92
        return (f);
      } else {
        {
#line 90
        tmp = strcmp((char const   *)(f->hname + 1), (char const   *)(name___0 + 1));
        }
#line 90
        if (! tmp) {
#line 92
          return (f);
        }
      }
    }
#line 88
    f = f->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 95
  return ((struct file *)0);
}
}
#line 98 "/home/khheo/testset/make-3.76.1/file.c"
struct file *enter_file(char *name___0 ) 
{ 
  register struct file *f ;
  register struct file *new ;
  register char *n ;
  register unsigned int hashval ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 109
  if ((int )*name___0 == 0) {
    {
#line 110
    abort();
    }
  }
#line 125
  hashval = 0U;
#line 126
  n = name___0;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! ((int )*n != 0)) {
#line 126
      goto while_break;
    }
#line 127
    hashval += (unsigned int )*n;
#line 127
    hashval = (hashval << 7) + (hashval >> 20);
#line 126
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  hashval %= 1007U;
#line 130
  f = files[hashval];
  {
#line 130
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 130
    if (! ((unsigned long )f != (unsigned long )((struct file *)0))) {
#line 130
      goto while_break___0;
    }
#line 131
    if ((unsigned long )f->hname == (unsigned long )name___0) {
#line 132
      goto while_break___0;
    } else
#line 131
    if ((int )*(f->hname) == (int )*name___0) {
#line 131
      if ((int )*(f->hname) == 0) {
#line 132
        goto while_break___0;
      } else {
        {
#line 131
        tmp = strcmp((char const   *)(f->hname + 1), (char const   *)(name___0 + 1));
        }
#line 131
        if (! tmp) {
#line 132
          goto while_break___0;
        }
      }
    }
#line 130
    f = f->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 134
  if ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 134
    if (! f->double_colon) {
#line 139
      return (f);
    }
  }
  {
#line 142
  tmp___0 = xmalloc(sizeof(struct file ));
#line 142
  new = (struct file *)tmp___0;
#line 143
  memset((void *)((char *)new), 0, sizeof(struct file ));
#line 144
  tmp___1 = name___0;
#line 144
  new->hname = tmp___1;
#line 144
  new->name = tmp___1;
#line 145
  new->update_status = (short)-1;
  }
#line 147
  if ((unsigned long )f == (unsigned long )((struct file *)0)) {
#line 150
    new->next = files[hashval];
#line 151
    files[hashval] = new;
  } else {
#line 156
    new->double_colon = f;
    {
#line 157
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 157
      if (! ((unsigned long )f->prev != (unsigned long )((struct file *)0))) {
#line 157
        goto while_break___1;
      }
#line 158
      f = f->prev;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 159
    f->prev = new;
  }
#line 162
  return (new);
}
}
#line 169 "/home/khheo/testset/make-3.76.1/file.c"
void rehash_file(struct file *file , char *name___0 ) 
{ 
  char *oldname ;
  register unsigned int oldhash ;
  register char *n ;

  {
#line 174
  oldname = file->hname;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! ((unsigned long )file->renamed != (unsigned long )((struct file *)0))) {
#line 178
      goto while_break;
    }
#line 179
    file = file->renamed;
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  oldhash = 0U;
#line 184
  n = oldname;
  {
#line 184
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 184
    if (! ((int )*n != 0)) {
#line 184
      goto while_break___0;
    }
#line 185
    oldhash += (unsigned int )*n;
#line 185
    oldhash = (oldhash << 7) + (oldhash >> 20);
#line 184
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 187
  file_hash_enter(file, name___0, oldhash, file->name);
  }
#line 188
  return;
}
}
#line 194 "/home/khheo/testset/make-3.76.1/file.c"
void rename_file(struct file *file , char *name___0 ) 
{ 


  {
  {
#line 199
  rehash_file(file, name___0);
  }
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! file) {
#line 200
      goto while_break;
    }
#line 202
    file->name = file->hname;
#line 203
    file = file->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return;
}
}
#line 207 "/home/khheo/testset/make-3.76.1/file.c"
void file_hash_enter(struct file *file , char *name___0 , unsigned int oldhash , char *oldname ) 
{ 
  unsigned int oldbucket ;
  register unsigned int newhash ;
  register unsigned int newbucket ;
  struct file *oldfile ;
  register char *n ;
  register struct file *f ;
  int tmp ;
  struct file *lastf ;
  register struct dep *d ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 214
  oldbucket = oldhash % 1007U;
#line 220
  newhash = 0U;
#line 221
  n = name___0;
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! ((int )*n != 0)) {
#line 221
      goto while_break;
    }
#line 222
    newhash += (unsigned int )*n;
#line 222
    newhash = (newhash << 7) + (newhash >> 20);
#line 221
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  newbucket = newhash % 1007U;
#line 227
  oldfile = files[newbucket];
  {
#line 227
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 227
    if (! ((unsigned long )oldfile != (unsigned long )((struct file *)0))) {
#line 227
      goto while_break___0;
    }
#line 228
    if ((unsigned long )oldfile->hname == (unsigned long )name___0) {
#line 229
      goto while_break___0;
    } else
#line 228
    if ((int )*(oldfile->hname) == (int )*name___0) {
#line 228
      if ((int )*(oldfile->hname) == 0) {
#line 229
        goto while_break___0;
      } else {
        {
#line 228
        tmp = strcmp((char const   *)(oldfile->hname + 1), (char const   *)(name___0 + 1));
        }
#line 228
        if (! tmp) {
#line 229
          goto while_break___0;
        }
      }
    }
#line 227
    oldfile = oldfile->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 232
  if (! ((unsigned long )oldfile != (unsigned long )file)) {
    {
#line 232
    __assert_fail("oldfile != file", "/home/khheo/testset/make-3.76.1/file.c", 232U,
                  "file_hash_enter");
    }
  }
#line 234
  if (oldhash != 0U) {
#line 234
    if (newbucket != oldbucket) {
#line 234
      goto _L;
    } else
#line 234
    if ((unsigned long )oldfile != (unsigned long )((struct file *)0)) {
      _L: /* CIL Label */ 
#line 238
      lastf = (struct file *)0;
#line 240
      f = files[oldbucket];
      {
#line 240
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 240
        if (! ((unsigned long )f != (unsigned long )file)) {
#line 240
          goto while_break___1;
        }
#line 241
        lastf = f;
#line 240
        f = f->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 243
      if ((unsigned long )lastf == (unsigned long )((struct file *)0)) {
#line 244
        files[oldbucket] = f->next;
      } else {
#line 246
        lastf->next = f->next;
      }
    }
  }
#line 251
  file->hname = name___0;
#line 252
  f = file->double_colon;
  {
#line 252
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 252
    if (! ((unsigned long )f != (unsigned long )((struct file *)0))) {
#line 252
      goto while_break___2;
    }
#line 253
    f->hname = name___0;
#line 252
    f = f->prev;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 255
  if ((unsigned long )oldfile == (unsigned long )((struct file *)0)) {
#line 259
    if (newbucket != oldbucket) {
#line 262
      file->next = files[newbucket];
#line 263
      files[newbucket] = file;
    }
  } else {
#line 273
    if ((unsigned long )file->cmds != (unsigned long )((struct commands *)0)) {
#line 275
      if ((unsigned long )oldfile->cmds == (unsigned long )((struct commands *)0)) {
#line 276
        oldfile->cmds = file->cmds;
      } else
#line 277
      if ((unsigned long )file->cmds != (unsigned long )oldfile->cmds) {
#line 282
        if ((unsigned long )(oldfile->cmds)->filename != (unsigned long )((char *)0)) {
          {
#line 283
          makefile_error((file->cmds)->filename, (file->cmds)->lineno, "Commands were specified for file `%s\' at %s:%u,",
                         oldname, (oldfile->cmds)->filename, (oldfile->cmds)->lineno);
          }
        } else {
          {
#line 289
          makefile_error((file->cmds)->filename, (file->cmds)->lineno, "Commands for file `%s\' were found by implicit rule search,",
                         oldname);
          }
        }
        {
#line 293
        makefile_error((file->cmds)->filename, (file->cmds)->lineno, "but `%s\' is now considered the same file as `%s\'.",
                       oldname, name___0);
#line 297
        makefile_error((file->cmds)->filename, (file->cmds)->lineno, "Commands for `%s\' will be ignored in favor of those for `%s\'.",
                       name___0, oldname);
        }
      }
    }
#line 306
    d = oldfile->deps;
#line 307
    if ((unsigned long )d == (unsigned long )((struct dep *)0)) {
#line 308
      oldfile->deps = file->deps;
    } else {
      {
#line 311
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 311
        if (! ((unsigned long )d->next != (unsigned long )((struct dep *)0))) {
#line 311
          goto while_break___3;
        }
#line 312
        d = d->next;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 313
      d->next = file->deps;
    }
    {
#line 316
    merge_variable_set_lists(& oldfile->variables, file->variables);
    }
#line 318
    if (oldfile->double_colon) {
#line 318
      if (file->is_target) {
#line 318
        if (! file->double_colon) {
          {
#line 319
          fatal("can\'t rename single-colon `%s\' to double-colon `%s\'", oldname,
                name___0);
          }
        }
      }
    }
#line 321
    if (! oldfile->double_colon) {
#line 321
      if (file->double_colon) {
#line 323
        if (oldfile->is_target) {
          {
#line 324
          fatal("can\'t rename double-colon `%s\' to single-colon `%s\'", oldname,
                name___0);
          }
        } else {
#line 327
          oldfile->double_colon = file->double_colon;
        }
      }
    }
#line 330
    if (file->last_mtime > oldfile->last_mtime) {
#line 332
      oldfile->last_mtime = file->last_mtime;
    }
#line 335
    oldfile->precious |= file->precious;
#line 336
    oldfile->tried_implicit |= file->tried_implicit;
#line 337
    oldfile->updating |= file->updating;
#line 338
    oldfile->updated |= file->updated;
#line 339
    oldfile->is_target |= file->is_target;
#line 340
    oldfile->cmd_target |= file->cmd_target;
#line 341
    oldfile->phony |= file->phony;
#line 342
    oldfile->ignore_vpath |= file->ignore_vpath;
#line 345
    file->renamed = oldfile;
  }
#line 347
  return;
}
}
#line 354 "/home/khheo/testset/make-3.76.1/file.c"
void remove_intermediates(int sig ) 
{ 
  register int i ;
  register struct file *f ;
  char doneany ;
  int status ;
  int *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 362
  if (question_flag) {
#line 363
    return;
  } else
#line 362
  if (touch_flag) {
#line 363
    return;
  }
#line 364
  if (sig) {
#line 364
    if (just_print_flag) {
#line 365
      return;
    }
  }
#line 367
  doneany = (char)0;
#line 368
  i = 0;
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (! (i < 1007)) {
#line 368
      goto while_break;
    }
#line 369
    f = files[i];
    {
#line 369
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 369
      if (! ((unsigned long )f != (unsigned long )((struct file *)0))) {
#line 369
        goto while_break___0;
      }
#line 370
      if (f->intermediate) {
#line 370
        if (f->dontcare) {
#line 370
          goto _L;
        } else
#line 370
        if (! f->precious) {
          _L: /* CIL Label */ 
#line 370
          if (! f->secondary) {
#line 374
            if ((int )f->update_status == -1) {
#line 377
              goto __Cont;
            } else
#line 378
            if (just_print_flag) {
#line 379
              status = 0;
            } else {
              {
#line 382
              status = unlink((char const   *)f->name);
              }
#line 383
              if (status < 0) {
                {
#line 383
                tmp = __errno_location();
                }
#line 383
                if (*tmp == 2) {
#line 384
                  goto __Cont;
                }
              }
            }
#line 386
            if (! f->dontcare) {
#line 388
              if (sig) {
                {
#line 389
                error("*** Deleting intermediate file `%s\'", f->name);
                }
              } else
#line 390
              if (! silent_flag) {
#line 392
                if (! doneany) {
                  {
#line 394
                  fputs((char const   */* __restrict  */)"rm ", (FILE */* __restrict  */)stdout);
#line 395
                  doneany = (char)1;
                  }
                } else {
                  {
#line 398
                  putchar(' ');
                  }
                }
                {
#line 399
                fputs((char const   */* __restrict  */)f->name, (FILE */* __restrict  */)stdout);
#line 400
                fflush(stdout);
                }
              }
#line 402
              if (status < 0) {
                {
#line 403
                perror_with_name("unlink: ", f->name);
                }
              }
            }
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 369
      f = f->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 368
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 407
  if (doneany) {
#line 407
    if (! sig) {
      {
#line 409
      putchar('\n');
#line 410
      fflush(stdout);
      }
    }
  }
#line 412
  return;
}
}
#line 420 "/home/khheo/testset/make-3.76.1/file.c"
void snap_deps(void) 
{ 
  register struct file *f ;
  register struct file *f2 ;
  register struct dep *d ;
  register int i ;
  unsigned int tmp ;
  int i___0 ;
  unsigned int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 428
  i = 0;
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if (! (i < 1007)) {
#line 428
      goto while_break;
    }
#line 429
    f = files[i];
    {
#line 429
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 429
      if (! ((unsigned long )f != (unsigned long )((struct file *)0))) {
#line 429
        goto while_break___0;
      }
#line 430
      f2 = f;
      {
#line 430
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 430
        if (! ((unsigned long )f2 != (unsigned long )((struct file *)0))) {
#line 430
          goto while_break___1;
        }
#line 431
        d = f2->deps;
        {
#line 431
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 431
          if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 431
            goto while_break___2;
          }
#line 432
          if ((unsigned long )d->name != (unsigned long )((char *)0)) {
            {
#line 434
            d->file = lookup_file(d->name);
            }
#line 435
            if ((unsigned long )d->file == (unsigned long )((struct file *)0)) {
              {
#line 436
              d->file = enter_file(d->name);
              }
            } else {
              {
#line 438
              free((void *)d->name);
              }
            }
#line 439
            d->name = (char *)0;
          }
#line 431
          d = d->next;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 430
        f2 = f2->prev;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 429
      f = f->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 428
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 442
  f = lookup_file((char *)".PRECIOUS");
  }
  {
#line 442
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 442
    if (! ((unsigned long )f != (unsigned long )((struct file *)0))) {
#line 442
      goto while_break___3;
    }
#line 443
    d = f->deps;
    {
#line 443
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 443
      if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 443
        goto while_break___4;
      }
#line 444
      f2 = d->file;
      {
#line 444
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 444
        if (! ((unsigned long )f2 != (unsigned long )((struct file *)0))) {
#line 444
          goto while_break___5;
        }
#line 445
        f2->precious = 1U;
#line 444
        f2 = f2->prev;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 443
      d = d->next;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 442
    f = f->prev;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 447
  f = lookup_file((char *)".PHONY");
  }
  {
#line 447
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 447
    if (! ((unsigned long )f != (unsigned long )((struct file *)0))) {
#line 447
      goto while_break___6;
    }
#line 448
    d = f->deps;
    {
#line 448
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 448
      if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 448
        goto while_break___7;
      }
#line 449
      f2 = d->file;
      {
#line 449
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 449
        if (! ((unsigned long )f2 != (unsigned long )((struct file *)0))) {
#line 449
          goto while_break___8;
        }
#line 452
        f2->phony = 1U;
#line 453
        f2->last_mtime = (time_t )-1;
#line 449
        f2 = f2->prev;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 448
      d = d->next;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 447
    f = f->prev;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 456
  f = lookup_file((char *)".INTERMEDIATE");
  }
  {
#line 456
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 456
    if (! ((unsigned long )f != (unsigned long )((struct file *)0))) {
#line 456
      goto while_break___9;
    }
#line 460
    d = f->deps;
    {
#line 460
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 460
      if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 460
        goto while_break___10;
      }
#line 461
      f2 = d->file;
      {
#line 461
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 461
        if (! ((unsigned long )f2 != (unsigned long )((struct file *)0))) {
#line 461
          goto while_break___11;
        }
#line 462
        f2->intermediate = 1U;
#line 461
        f2 = f2->prev;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 460
      d = d->next;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 456
    f = f->prev;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 468
  f = lookup_file((char *)".SECONDARY");
  }
  {
#line 468
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 468
    if (! ((unsigned long )f != (unsigned long )((struct file *)0))) {
#line 468
      goto while_break___12;
    }
#line 475
    if (f->deps) {
#line 477
      d = f->deps;
      {
#line 477
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 477
        if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 477
          goto while_break___13;
        }
#line 478
        f2 = d->file;
        {
#line 478
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 478
          if (! ((unsigned long )f2 != (unsigned long )((struct file *)0))) {
#line 478
            goto while_break___14;
          }
#line 479
          tmp = 1U;
#line 479
          f2->secondary = tmp;
#line 479
          f2->intermediate = tmp;
#line 478
          f2 = f2->prev;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 477
        d = d->next;
      }
      while_break___13: /* CIL Label */ ;
      }
    } else {
#line 485
      i___0 = 0;
      {
#line 485
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 485
        if (! (i___0 < 1007)) {
#line 485
          goto while_break___15;
        }
#line 486
        f2 = files[i___0];
        {
#line 486
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 486
          if (! f2) {
#line 486
            goto while_break___16;
          }
#line 487
          tmp___0 = 1U;
#line 487
          f2->secondary = tmp___0;
#line 487
          f2->intermediate = tmp___0;
#line 486
          f2 = f2->next;
        }
        while_break___16: /* CIL Label */ ;
        }
#line 485
        i___0 ++;
      }
      while_break___15: /* CIL Label */ ;
      }
    }
#line 468
    f = f->prev;
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 491
  f = lookup_file((char *)".EXPORT_ALL_VARIABLES");
  }
#line 492
  if ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 492
    if (f->is_target) {
#line 493
      export_all_variables = 1;
    }
  }
  {
#line 495
  f = lookup_file((char *)".IGNORE");
  }
#line 496
  if ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 496
    if (f->is_target) {
#line 498
      if ((unsigned long )f->deps == (unsigned long )((struct dep *)0)) {
#line 499
        ignore_errors_flag = 1;
      } else {
#line 501
        d = f->deps;
        {
#line 501
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 501
          if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 501
            goto while_break___17;
          }
#line 502
          f2 = d->file;
          {
#line 502
          while (1) {
            while_continue___18: /* CIL Label */ ;
#line 502
            if (! ((unsigned long )f2 != (unsigned long )((struct file *)0))) {
#line 502
              goto while_break___18;
            }
#line 503
            f2->command_flags |= 4;
#line 502
            f2 = f2->prev;
          }
          while_break___18: /* CIL Label */ ;
          }
#line 501
          d = d->next;
        }
        while_break___17: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 506
  f = lookup_file((char *)".SILENT");
  }
#line 507
  if ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 507
    if (f->is_target) {
#line 509
      if ((unsigned long )f->deps == (unsigned long )((struct dep *)0)) {
#line 510
        silent_flag = 1;
      } else {
#line 512
        d = f->deps;
        {
#line 512
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 512
          if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 512
            goto while_break___19;
          }
#line 513
          f2 = d->file;
          {
#line 513
          while (1) {
            while_continue___20: /* CIL Label */ ;
#line 513
            if (! ((unsigned long )f2 != (unsigned long )((struct file *)0))) {
#line 513
              goto while_break___20;
            }
#line 514
            f2->command_flags |= 2;
#line 513
            f2 = f2->prev;
          }
          while_break___20: /* CIL Label */ ;
          }
#line 512
          d = d->next;
        }
        while_break___19: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 517
  f = lookup_file((char *)".POSIX");
  }
#line 518
  if ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 518
    if (f->is_target) {
#line 519
      posix_pedantic = 1;
    }
  }
#line 520
  return;
}
}
#line 524 "/home/khheo/testset/make-3.76.1/file.c"
void set_command_state(struct file *file , int state ) 
{ 
  struct dep *d ;

  {
#line 531
  file->command_state = (enum __anonenum_command_state_55 )state;
#line 533
  d = file->also_make;
  {
#line 533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 533
    if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 533
      goto while_break;
    }
#line 534
    (d->file)->command_state = (enum __anonenum_command_state_55 )state;
#line 533
    d = d->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 535
  return;
}
}
#line 539 "/home/khheo/testset/make-3.76.1/file.c"
static void print_file(struct file *f ) 
{ 
  register struct dep *d ;
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
#line 545
  putchar('\n');
  }
#line 546
  if (! f->is_target) {
    {
#line 547
    puts("# Not a target:");
    }
  }
#line 548
  if (f->double_colon) {
#line 548
    tmp = ":";
  } else {
#line 548
    tmp = "";
  }
  {
#line 548
  printf((char const   */* __restrict  */)"%s:%s", f->name, tmp);
#line 550
  d = f->deps;
  }
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
#line 550
    if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 550
      goto while_break;
    }
#line 551
    if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 551
      tmp___0 = (d->file)->name;
    } else {
#line 551
      tmp___0 = d->name;
    }
    {
#line 551
    printf((char const   */* __restrict  */)" %s", tmp___0);
#line 550
    d = d->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 552
  putchar('\n');
  }
#line 554
  if (f->precious) {
    {
#line 555
    puts("#  Precious file (dependency of .PRECIOUS).");
    }
  }
#line 556
  if (f->phony) {
    {
#line 557
    puts("#  Phony target (dependency of .PHONY).");
    }
  }
#line 558
  if (f->cmd_target) {
    {
#line 559
    puts("#  Command-line target.");
    }
  }
#line 560
  if (f->dontcare) {
    {
#line 561
    puts("#  A default or MAKEFILES makefile.");
    }
  }
#line 562
  if (f->tried_implicit) {
#line 562
    tmp___1 = "";
  } else {
#line 562
    tmp___1 = " not";
  }
  {
#line 562
  printf((char const   */* __restrict  */)"#  Implicit rule search has%s been done.\n",
         tmp___1);
  }
#line 564
  if ((unsigned long )f->stem != (unsigned long )((char *)0)) {
    {
#line 565
    printf((char const   */* __restrict  */)"#  Implicit/static pattern stem: `%s\'\n",
           f->stem);
    }
  }
#line 566
  if (f->intermediate) {
    {
#line 567
    puts("#  File is an intermediate dependency.");
    }
  }
#line 568
  if ((unsigned long )f->also_make != (unsigned long )((struct dep *)0)) {
    {
#line 570
    fputs((char const   */* __restrict  */)"#  Also makes:", (FILE */* __restrict  */)stdout);
#line 571
    d = f->also_make;
    }
    {
#line 571
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 571
      if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 571
        goto while_break___0;
      }
#line 572
      if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 572
        tmp___2 = (d->file)->name;
      } else {
#line 572
        tmp___2 = d->name;
      }
      {
#line 572
      printf((char const   */* __restrict  */)" %s", tmp___2);
#line 571
      d = d->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 573
    putchar('\n');
    }
  }
#line 575
  if (f->last_mtime == 0L) {
    {
#line 576
    puts("#  Modification time never checked.");
    }
  } else
#line 577
  if (f->last_mtime == -1L) {
    {
#line 578
    puts("#  File does not exist.");
    }
  } else {
    {
#line 580
    tmp___3 = ctime((time_t const   *)(& f->last_mtime));
#line 580
    printf((char const   */* __restrict  */)"#  Last modified %.24s (%ld)\n", tmp___3,
           f->last_mtime);
    }
  }
#line 582
  if (f->updated) {
#line 582
    tmp___4 = "";
  } else {
#line 582
    tmp___4 = " not";
  }
  {
#line 582
  printf((char const   */* __restrict  */)"#  File has%s been updated.\n", tmp___4);
  }
  {
#line 586
  if ((unsigned int )f->command_state == 2U) {
#line 586
    goto case_2;
  }
#line 589
  if ((unsigned int )f->command_state == 1U) {
#line 589
    goto case_1;
  }
#line 593
  if ((unsigned int )f->command_state == 3U) {
#line 593
    goto case_3;
  }
#line 593
  if ((unsigned int )f->command_state == 0U) {
#line 593
    goto case_3;
  }
#line 615
  goto switch_default___0;
  case_2: /* CIL Label */ 
  {
#line 587
  puts("#  Commands currently running (THIS IS A BUG).");
  }
#line 588
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 590
  puts("#  Dependencies commands running (THIS IS A BUG).");
  }
#line 591
  goto switch_break;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 596
  if ((int )f->update_status == -1) {
#line 596
    goto case_neg_1;
  }
#line 598
  if ((int )f->update_status == 0) {
#line 598
    goto case_0___0;
  }
#line 601
  if ((int )f->update_status == 1) {
#line 601
    goto case_1___0;
  }
#line 605
  if ((int )f->update_status == 2) {
#line 605
    goto case_2___0;
  }
#line 608
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 597
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
  {
#line 599
  puts("#  Successfully updated.");
  }
#line 600
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 602
  if (! question_flag) {
    {
#line 602
    __assert_fail("question_flag", "/home/khheo/testset/make-3.76.1/file.c", 602U,
                  "print_file");
    }
  }
  {
#line 603
  puts("#  Needs to be updated (-q is set).");
  }
#line 604
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 606
  puts("#  Failed to be updated.");
  }
#line 607
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 609
  puts("#  Invalid value in `update_status\' member!");
#line 610
  fflush(stdout);
#line 611
  fflush(stderr);
#line 612
  abort();
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 614
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 616
  puts("#  Invalid value in `command_state\' member!");
#line 617
  fflush(stdout);
#line 618
  fflush(stderr);
#line 619
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 622
  if ((unsigned long )f->variables != (unsigned long )((struct variable_set_list *)0)) {
    {
#line 623
    print_file_variables(f);
    }
  }
#line 625
  if ((unsigned long )f->cmds != (unsigned long )((struct commands *)0)) {
    {
#line 626
    print_commands(f->cmds);
    }
  }
#line 627
  return;
}
}
#line 629 "/home/khheo/testset/make-3.76.1/file.c"
void print_file_data_base(void) 
{ 
  register unsigned int i ;
  register unsigned int nfiles ;
  register unsigned int per_bucket ;
  register struct file *file ;
  register unsigned int this_bucket ;
  register struct file *f ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 635
  puts("\n# Files");
#line 637
  nfiles = 0U;
#line 637
  per_bucket = nfiles;
#line 638
  i = 0U;
  }
  {
#line 638
  while (1) {
    while_continue: /* CIL Label */ ;
#line 638
    if (! (i < 1007U)) {
#line 638
      goto while_break;
    }
#line 640
    this_bucket = 0U;
#line 642
    file = files[i];
    {
#line 642
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 642
      if (! ((unsigned long )file != (unsigned long )((struct file *)0))) {
#line 642
        goto while_break___0;
      }
#line 646
      this_bucket ++;
#line 648
      f = file;
      {
#line 648
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 648
        if (! ((unsigned long )f != (unsigned long )((struct file *)0))) {
#line 648
          goto while_break___1;
        }
        {
#line 649
        print_file(f);
#line 648
        f = f->prev;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 642
      file = file->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 652
    nfiles += this_bucket;
#line 653
    if (this_bucket > per_bucket) {
#line 654
      per_bucket = this_bucket;
    }
#line 638
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 657
  if (nfiles == 0U) {
    {
#line 658
    puts("\n# No files.");
    }
  } else {
    {
#line 661
    printf((char const   */* __restrict  */)"\n# %u files in %u hash buckets.\n",
           nfiles, 1007);
#line 663
    printf((char const   */* __restrict  */)"# average %.1f files per bucket, max %u files in one bucket.\n",
           ((double )nfiles / (double )1007) * 100.0, per_bucket);
    }
  }
#line 667
  return;
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 238 "/home/khheo/testset/make-3.76.1/dir.c"
static struct directory_contents *directories_contents[199]  ;
#line 253 "/home/khheo/testset/make-3.76.1/dir.c"
static struct directory *directories[199]  ;
#line 260 "/home/khheo/testset/make-3.76.1/dir.c"
static unsigned int open_directories  =    0U;
#line 276
static int dir_contents_file_exists_p(struct directory_contents *dir , char *filename ) ;
#line 277
static struct directory *find_directory(char *name___0 ) ;
#line 281 "/home/khheo/testset/make-3.76.1/dir.c"
static struct directory *find_directory(char *name___0 ) 
{ 
  register unsigned int hash ;
  register char *p ;
  register struct directory *dir ;
  int tmp ;
  struct stat st ;
  char *tmp___0 ;
  struct directory_contents *dc ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 285
  hash = 0U;
#line 303
  p = name___0;
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    if (! ((int )*p != 0)) {
#line 303
      goto while_break;
    }
#line 304
    hash += (unsigned int )*p;
#line 304
    hash = (hash << 7) + (hash >> 20);
#line 303
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  hash %= 199U;
#line 307
  dir = directories[hash];
  {
#line 307
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 307
    if (! ((unsigned long )dir != (unsigned long )((struct directory *)0))) {
#line 307
      goto while_break___0;
    }
#line 308
    if ((unsigned long )dir->name == (unsigned long )name___0) {
#line 309
      goto while_break___0;
    } else
#line 308
    if ((int )*(dir->name) == (int )*name___0) {
#line 308
      if ((int )*(dir->name) == 0) {
#line 309
        goto while_break___0;
      } else {
        {
#line 308
        tmp = strcmp((char const   *)(dir->name + 1), (char const   *)(name___0 + 1));
        }
#line 308
        if (! tmp) {
#line 309
          goto while_break___0;
        }
      }
    }
#line 307
    dir = dir->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 311
  if ((unsigned long )dir == (unsigned long )((struct directory *)0)) {
    {
#line 317
    tmp___0 = xmalloc(sizeof(struct directory ));
#line 317
    dir = (struct directory *)tmp___0;
#line 318
    dir->next = directories[hash];
#line 319
    directories[hash] = dir;
#line 320
    dir->name = savestring(name___0, p - name___0);
#line 328
    tmp___3 = stat((char const   */* __restrict  */)name___0, (struct stat */* __restrict  */)(& st));
    }
#line 328
    if (tmp___3 < 0) {
#line 333
      dir->contents = (struct directory_contents *)0;
    } else {
#line 351
      hash = ((unsigned int )st.st_dev << 16) | (unsigned int )st.st_ino;
#line 354
      hash %= 199U;
#line 356
      dc = directories_contents[hash];
      {
#line 356
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 356
        if (! ((unsigned long )dc != (unsigned long )((struct directory_contents *)0))) {
#line 356
          goto while_break___1;
        }
#line 360
        if (dc->dev == st.st_dev) {
#line 360
          if (dc->ino == st.st_ino) {
#line 369
            goto while_break___1;
          }
        }
#line 356
        dc = dc->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 371
      if ((unsigned long )dc == (unsigned long )((struct directory_contents *)0)) {
        {
#line 375
        tmp___1 = xmalloc(sizeof(struct directory_contents ));
#line 375
        dc = (struct directory_contents *)tmp___1;
#line 379
        dc->dev = st.st_dev;
#line 407
        dc->ino = st.st_ino;
#line 410
        dc->next = directories_contents[hash];
#line 411
        directories_contents[hash] = dc;
#line 413
        dc->dirstream = opendir((char const   *)name___0);
        }
#line 414
        if ((unsigned long )dc->dirstream == (unsigned long )((DIR *)0)) {
#line 418
          dc->files = (struct dirfile **)0;
        } else {
          {
#line 423
          tmp___2 = xmalloc(sizeof(struct dirfile *) * 107UL);
#line 423
          dc->files = (struct dirfile **)tmp___2;
#line 425
          memset((void *)((char *)dc->files), 0, sizeof(struct dirfile *) * 107UL);
#line 429
          open_directories ++;
          }
#line 430
          if (open_directories == 10U) {
            {
#line 433
            dir_contents_file_exists_p(dc, (char *)0);
            }
          }
        }
      }
#line 438
      dir->contents = dc;
    }
  }
#line 442
  return (dir);
}
}
#line 448 "/home/khheo/testset/make-3.76.1/dir.c"
static int dir_contents_file_exists_p(struct directory_contents *dir , char *filename ) 
{ 
  register unsigned int hash ;
  register char *p ;
  register struct dirfile *df ;
  register struct dirent *d ;
  int tmp ;
  register unsigned int newhash ;
  unsigned int len ;
  register unsigned int i ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 462
  if ((unsigned long )dir == (unsigned long )((struct directory_contents *)0)) {
#line 465
    return (0);
  } else
#line 462
  if ((unsigned long )dir->files == (unsigned long )((struct dirfile **)0)) {
#line 465
    return (0);
  }
#line 479
  hash = 0U;
#line 480
  if ((unsigned long )filename != (unsigned long )((char *)0)) {
#line 482
    if ((int )*filename == 0) {
#line 485
      return (1);
    }
#line 488
    p = filename;
    {
#line 488
    while (1) {
      while_continue: /* CIL Label */ ;
#line 488
      if (! ((int )*p != 0)) {
#line 488
        goto while_break;
      }
#line 489
      hash += (unsigned int )*p;
#line 489
      hash = (hash << 7) + (hash >> 20);
#line 488
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 490
    hash %= 107U;
#line 494
    df = *(dir->files + hash);
    {
#line 494
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 494
      if (! ((unsigned long )df != (unsigned long )((struct dirfile *)0))) {
#line 494
        goto while_break___0;
      }
#line 496
      if ((unsigned long )df->name == (unsigned long )filename) {
#line 498
        return (! df->impossible);
      } else
#line 496
      if ((int )*(df->name) == (int )*filename) {
#line 496
        if ((int )*(df->name) == 0) {
#line 498
          return (! df->impossible);
        } else {
          {
#line 496
          tmp = strcmp((char const   *)(df->name + 1), (char const   *)(filename + 1));
          }
#line 496
          if (! tmp) {
#line 498
            return (! df->impossible);
          }
        }
      }
#line 494
      df = df->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 506
  if ((unsigned long )dir->dirstream == (unsigned long )((DIR *)0)) {
#line 532
    return (0);
  }
  {
#line 535
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 535
    d = readdir(dir->dirstream);
    }
#line 535
    if (! ((unsigned long )d != (unsigned long )((struct dirent *)0))) {
#line 535
      goto while_break___1;
    }
#line 538
    newhash = 0U;
#line 542
    if (! (d->d_ino != 0UL)) {
#line 543
      goto while_continue___1;
    }
    {
#line 545
    tmp___0 = strlen((char const   *)(d->d_name));
#line 545
    len = (unsigned int )tmp___0;
#line 546
    i = 0U;
    }
    {
#line 546
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 546
      if (! (i < len)) {
#line 546
        goto while_break___2;
      }
#line 547
      newhash += (unsigned int )d->d_name[i];
#line 547
      newhash = (newhash << 7) + (newhash >> 20);
#line 546
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 548
    newhash %= 107U;
#line 568
    tmp___1 = xmalloc(sizeof(struct dirfile ));
#line 568
    df = (struct dirfile *)tmp___1;
#line 569
    df->next = *(dir->files + newhash);
#line 570
    *(dir->files + newhash) = df;
#line 571
    df->name = savestring(d->d_name, len);
#line 572
    df->impossible = (char)0;
    }
#line 577
    if ((unsigned long )filename != (unsigned long )((char *)0)) {
#line 577
      if (newhash == hash) {
#line 577
        if ((unsigned long )(d->d_name) == (unsigned long )filename) {
#line 580
          return (1);
        } else
#line 577
        if ((int )d->d_name[0] == (int )*filename) {
#line 577
          if ((int )d->d_name[0] == 0) {
#line 580
            return (1);
          } else {
            {
#line 577
            tmp___2 = strcmp((char const   *)(d->d_name + 1), (char const   *)(filename + 1));
            }
#line 577
            if (! tmp___2) {
#line 580
              return (1);
            }
          }
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 586
  if ((unsigned long )d == (unsigned long )((struct dirent *)0)) {
    {
#line 588
    open_directories --;
#line 589
    closedir(dir->dirstream);
#line 590
    dir->dirstream = (DIR *)0;
    }
  }
#line 592
  return (0);
}
}
#line 599 "/home/khheo/testset/make-3.76.1/dir.c"
int dir_file_exists_p(char *dirname , char *filename ) 
{ 
  struct directory *tmp ;
  int tmp___0 ;

  {
  {
#line 604
  tmp = find_directory(dirname);
#line 604
  tmp___0 = dir_contents_file_exists_p(tmp->contents, filename);
  }
#line 604
  return (tmp___0);
}
}
#line 610 "/home/khheo/testset/make-3.76.1/dir.c"
int file_exists_p(char *name___0 ) 
{ 
  char *dirend ;
  char *dirname ;
  time_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 618
  tmp___0 = ar_name(name___0);
  }
#line 618
  if (tmp___0) {
    {
#line 619
    tmp = ar_member_date(name___0);
    }
#line 619
    return (tmp != -1L);
  }
  {
#line 628
  dirend = strrchr((char const   *)name___0, '/');
  }
#line 639
  if ((unsigned long )dirend == (unsigned long )((char *)0)) {
    {
#line 641
    tmp___1 = dir_file_exists_p((char *)".", name___0);
    }
#line 641
    return (tmp___1);
  }
#line 647
  if ((unsigned long )dirend == (unsigned long )name___0) {
#line 648
    dirname = (char *)"/";
  } else {
    {
#line 651
    tmp___2 = __builtin_alloca((unsigned long )((dirend - name___0) + 1L));
#line 651
    dirname = (char *)tmp___2;
#line 652
    memmove((void *)dirname, (void const   *)name___0, (size_t )(dirend - name___0));
#line 653
    *(dirname + (dirend - name___0)) = (char )'\000';
    }
  }
  {
#line 655
  tmp___3 = dir_file_exists_p(dirname, dirend + 1);
  }
#line 655
  return (tmp___3);
}
}
#line 662 "/home/khheo/testset/make-3.76.1/dir.c"
void file_impossible(char *filename ) 
{ 
  char *dirend ;
  register char *p ;
  register unsigned int hash ;
  register struct directory *dir ;
  register struct dirfile *new ;
  char *dirname ;
  void *tmp ;
  char *tmp___0 ;
  ino_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 667
  p = filename;
#line 678
  dirend = strrchr((char const   *)p, '/');
  }
#line 689
  if ((unsigned long )dirend == (unsigned long )((char *)0)) {
    {
#line 693
    dir = find_directory((char *)".");
    }
  } else {
#line 699
    if ((unsigned long )dirend == (unsigned long )p) {
#line 700
      dirname = (char *)"/";
    } else {
      {
#line 703
      tmp = __builtin_alloca((unsigned long )((dirend - p) + 1L));
#line 703
      dirname = (char *)tmp;
#line 704
      memmove((void *)dirname, (void const   *)p, (size_t )(dirend - p));
#line 705
      *(dirname + (dirend - p)) = (char )'\000';
      }
    }
    {
#line 707
    dir = find_directory(dirname);
#line 708
    p = dirend + 1;
#line 708
    filename = p;
    }
  }
#line 711
  hash = 0U;
  {
#line 711
  while (1) {
    while_continue: /* CIL Label */ ;
#line 711
    if (! ((int )*p != 0)) {
#line 711
      goto while_break;
    }
#line 712
    hash += (unsigned int )*p;
#line 712
    hash = (hash << 7) + (hash >> 20);
#line 711
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 713
  hash %= 107U;
#line 715
  if ((unsigned long )dir->contents == (unsigned long )((struct directory_contents *)0)) {
    {
#line 719
    tmp___0 = xmalloc(sizeof(struct directory_contents ));
#line 719
    dir->contents = (struct directory_contents *)tmp___0;
#line 730
    tmp___1 = (ino_t )0;
#line 730
    (dir->contents)->ino = tmp___1;
#line 730
    (dir->contents)->dev = tmp___1;
#line 733
    (dir->contents)->files = (struct dirfile **)0;
#line 734
    (dir->contents)->dirstream = (DIR *)0;
    }
  }
#line 737
  if ((unsigned long )(dir->contents)->files == (unsigned long )((struct dirfile **)0)) {
    {
#line 740
    tmp___2 = xmalloc(sizeof(struct dirfile ) * 107UL);
#line 740
    (dir->contents)->files = (struct dirfile **)tmp___2;
#line 742
    memset((void *)((char *)(dir->contents)->files), 0, sizeof(struct dirfile ) * 107UL);
    }
  }
  {
#line 748
  tmp___3 = xmalloc(sizeof(struct dirfile ));
#line 748
  new = (struct dirfile *)tmp___3;
#line 749
  new->next = *((dir->contents)->files + hash);
#line 750
  *((dir->contents)->files + hash) = new;
#line 751
  tmp___4 = strlen((char const   *)filename);
#line 751
  new->name = savestring(filename, tmp___4);
#line 752
  new->impossible = (char)1;
  }
#line 753
  return;
}
}
#line 757 "/home/khheo/testset/make-3.76.1/dir.c"
int file_impossible_p(char *filename ) 
{ 
  char *dirend ;
  register char *p ;
  register unsigned int hash ;
  register struct directory_contents *dir ;
  register struct dirfile *next ;
  struct directory *tmp ;
  char *dirname ;
  void *tmp___0 ;
  struct directory *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 762
  p = filename;
#line 772
  dirend = strrchr((char const   *)filename, '/');
  }
#line 783
  if ((unsigned long )dirend == (unsigned long )((char *)0)) {
    {
#line 787
    tmp = find_directory((char *)".");
#line 787
    dir = tmp->contents;
    }
  } else {
#line 793
    if ((unsigned long )dirend == (unsigned long )filename) {
#line 794
      dirname = (char *)"/";
    } else {
      {
#line 797
      tmp___0 = __builtin_alloca((unsigned long )((dirend - filename) + 1L));
#line 797
      dirname = (char *)tmp___0;
#line 798
      memmove((void *)dirname, (void const   *)p, (size_t )(dirend - p));
#line 799
      *(dirname + (dirend - p)) = (char )'\000';
      }
    }
    {
#line 801
    tmp___1 = find_directory(dirname);
#line 801
    dir = tmp___1->contents;
#line 802
    filename = dirend + 1;
#line 802
    p = filename;
    }
  }
#line 805
  if ((unsigned long )dir == (unsigned long )((struct directory_contents *)0)) {
#line 807
    return (0);
  } else
#line 805
  if ((unsigned long )dir->files == (unsigned long )((struct dirfile **)0)) {
#line 807
    return (0);
  }
#line 819
  hash = 0U;
  {
#line 819
  while (1) {
    while_continue: /* CIL Label */ ;
#line 819
    if (! ((int )*p != 0)) {
#line 819
      goto while_break;
    }
#line 820
    hash += (unsigned int )*p;
#line 820
    hash = (hash << 7) + (hash >> 20);
#line 819
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 821
  hash %= 107U;
#line 823
  next = *(dir->files + hash);
  {
#line 823
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 823
    if (! ((unsigned long )next != (unsigned long )((struct dirfile *)0))) {
#line 823
      goto while_break___0;
    }
#line 824
    if ((unsigned long )filename == (unsigned long )next->name) {
#line 825
      return ((int )next->impossible);
    } else
#line 824
    if ((int )*filename == (int )*(next->name)) {
#line 824
      if ((int )*filename == 0) {
#line 825
        return ((int )next->impossible);
      } else {
        {
#line 824
        tmp___2 = strcmp((char const   *)(filename + 1), (char const   *)(next->name + 1));
        }
#line 824
        if (! tmp___2) {
#line 825
          return ((int )next->impossible);
        }
      }
    }
#line 823
    next = next->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 827
  return (0);
}
}
#line 833 "/home/khheo/testset/make-3.76.1/dir.c"
char *dir_name(char *dir ) 
{ 
  struct directory *tmp ;

  {
  {
#line 837
  tmp = find_directory(dir);
  }
#line 837
  return (tmp->name);
}
}
#line 842 "/home/khheo/testset/make-3.76.1/dir.c"
void print_dir_data_base(void) 
{ 
  register unsigned int i ;
  register unsigned int dirs___0 ;
  register unsigned int files___0 ;
  register unsigned int impossible ;
  register struct directory *dir ;
  register unsigned int f ;
  register unsigned int im ;
  register unsigned int j ;
  register struct dirfile *df ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 848
  puts("\n# Directories\n");
#line 850
  impossible = 0U;
#line 850
  files___0 = impossible;
#line 850
  dirs___0 = files___0;
#line 851
  i = 0U;
  }
  {
#line 851
  while (1) {
    while_continue: /* CIL Label */ ;
#line 851
    if (! (i < 199U)) {
#line 851
      goto while_break;
    }
#line 852
    dir = directories[i];
    {
#line 852
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 852
      if (! ((unsigned long )dir != (unsigned long )((struct directory *)0))) {
#line 852
        goto while_break___0;
      }
#line 854
      dirs___0 ++;
#line 855
      if ((unsigned long )dir->contents == (unsigned long )((struct directory_contents *)0)) {
        {
#line 856
        printf((char const   */* __restrict  */)"# %s: could not be stat\'d.\n", dir->name);
        }
      } else
#line 857
      if ((unsigned long )(dir->contents)->files == (unsigned long )((struct dirfile **)0)) {
        {
#line 868
        printf((char const   */* __restrict  */)"# %s (device %ld, inode %ld): could not be opened.\n",
               dir->name, (long )(dir->contents)->dev, (long )(dir->contents)->ino);
        }
      } else {
#line 875
        f = 0U;
#line 875
        im = 0U;
#line 878
        j = 0U;
        {
#line 878
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 878
          if (! (j < 107U)) {
#line 878
            goto while_break___1;
          }
#line 879
          df = *((dir->contents)->files + j);
          {
#line 879
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 879
            if (! ((unsigned long )df != (unsigned long )((struct dirfile *)0))) {
#line 879
              goto while_break___2;
            }
#line 880
            if (df->impossible) {
#line 881
              im ++;
            } else {
#line 883
              f ++;
            }
#line 879
            df = df->next;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 878
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 894
        printf((char const   */* __restrict  */)"# %s (device %d, inode %d): ", dir->name,
               (dir->contents)->dev, (dir->contents)->ino);
        }
#line 898
        if (f == 0U) {
          {
#line 899
          fputs((char const   */* __restrict  */)"No", (FILE */* __restrict  */)stdout);
          }
        } else {
          {
#line 901
          printf((char const   */* __restrict  */)"%u", f);
          }
        }
        {
#line 902
        fputs((char const   */* __restrict  */)" files, ", (FILE */* __restrict  */)stdout);
        }
#line 903
        if (im == 0U) {
          {
#line 904
          fputs((char const   */* __restrict  */)"no", (FILE */* __restrict  */)stdout);
          }
        } else {
          {
#line 906
          printf((char const   */* __restrict  */)"%u", im);
          }
        }
        {
#line 907
        fputs((char const   */* __restrict  */)" impossibilities", (FILE */* __restrict  */)stdout);
        }
#line 908
        if ((unsigned long )(dir->contents)->dirstream == (unsigned long )((DIR *)0)) {
          {
#line 909
          puts(".");
          }
        } else {
          {
#line 911
          puts(" so far.");
          }
        }
#line 912
        files___0 += f;
#line 913
        impossible += im;
      }
#line 852
      dir = dir->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 851
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 917
  fputs((char const   */* __restrict  */)"\n# ", (FILE */* __restrict  */)stdout);
  }
#line 918
  if (files___0 == 0U) {
    {
#line 919
    fputs((char const   */* __restrict  */)"No", (FILE */* __restrict  */)stdout);
    }
  } else {
    {
#line 921
    printf((char const   */* __restrict  */)"%u", files___0);
    }
  }
  {
#line 922
  fputs((char const   */* __restrict  */)" files, ", (FILE */* __restrict  */)stdout);
  }
#line 923
  if (impossible == 0U) {
    {
#line 924
    fputs((char const   */* __restrict  */)"no", (FILE */* __restrict  */)stdout);
    }
  } else {
    {
#line 926
    printf((char const   */* __restrict  */)"%u", impossible);
    }
  }
  {
#line 927
  printf((char const   */* __restrict  */)" impossibilities in %u directories.\n",
         dirs___0);
  }
#line 928
  return;
}
}
#line 945
static void *open_dirstream(char const   *directory ) ;
#line 946
static struct dirent *read_dirstream(void *stream ) ;
#line 948 "/home/khheo/testset/make-3.76.1/dir.c"
static void *open_dirstream(char const   *directory ) 
{ 
  struct dirstream *new ;
  struct directory *dir ;
  struct directory *tmp ;
  char *tmp___0 ;

  {
  {
#line 953
  tmp = find_directory((char *)directory);
#line 953
  dir = tmp;
  }
#line 955
  if ((unsigned long )dir->contents == (unsigned long )((struct directory_contents *)0)) {
#line 958
    return ((void *)0);
  } else
#line 955
  if ((unsigned long )(dir->contents)->files == (unsigned long )((struct dirfile **)0)) {
#line 958
    return ((void *)0);
  }
  {
#line 963
  dir_contents_file_exists_p(dir->contents, (char *)0);
#line 965
  tmp___0 = xmalloc(sizeof(struct dirstream ));
#line 965
  new = (struct dirstream *)tmp___0;
#line 966
  new->contents = dir->contents;
#line 967
  new->bucket = 0U;
#line 968
  new->elt = *((new->contents)->files + 0);
  }
#line 970
  return ((void *)new);
}
}
#line 979 "/home/khheo/testset/make-3.76.1/dir.c"
static char *buf  ;
#line 980 "/home/khheo/testset/make-3.76.1/dir.c"
static unsigned int bufsz  ;
#line 973 "/home/khheo/testset/make-3.76.1/dir.c"
static struct dirent *read_dirstream(void *stream ) 
{ 
  struct dirstream *ds ;
  register struct dirfile *df ;
  struct dirent *d ;
  unsigned int len ;
  size_t tmp ;

  {
#line 977
  ds = (struct dirstream *)stream;
  {
#line 982
  while (1) {
    while_continue: /* CIL Label */ ;
#line 982
    if (! (ds->bucket < 107U)) {
#line 982
      goto while_break;
    }
    {
#line 984
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 984
      df = ds->elt;
#line 984
      if (! ((unsigned long )df != (unsigned long )((struct dirfile *)0))) {
#line 984
        goto while_break___0;
      }
#line 986
      ds->elt = df->next;
#line 987
      if (! df->impossible) {
        {
#line 992
        tmp = strlen((char const   *)df->name);
#line 992
        len = (unsigned int )(tmp + 1UL);
        }
#line 993
        if ((sizeof(*d) - sizeof(d->d_name)) + (unsigned long )len > (unsigned long )bufsz) {
#line 995
          if ((unsigned long )buf != (unsigned long )((char *)0)) {
            {
#line 996
            free((void *)buf);
            }
          }
#line 997
          bufsz *= 2U;
#line 998
          if ((sizeof(*d) - sizeof(d->d_name)) + (unsigned long )len > (unsigned long )bufsz) {
#line 999
            bufsz = (unsigned int )((sizeof(*d) - sizeof(d->d_name)) + (unsigned long )len);
          }
          {
#line 1000
          buf = xmalloc(bufsz);
          }
        }
        {
#line 1002
        d = (struct dirent *)buf;
#line 1003
        d->d_ino = (__ino_t )1;
#line 1007
        memcpy((void */* __restrict  */)(d->d_name), (void const   */* __restrict  */)df->name,
               (size_t )len);
        }
#line 1008
        return (d);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1011
    (ds->bucket) ++;
#line 1011
    if (ds->bucket == 107U) {
#line 1012
      goto while_break;
    }
#line 1013
    ds->elt = *((ds->contents)->files + ds->bucket);
  }
  while_break: /* CIL Label */ ;
  }
#line 1016
  return ((struct dirent *)0);
}
}
#line 1019 "/home/khheo/testset/make-3.76.1/dir.c"
void dir_setup_glob(glob_t *gl ) 
{ 


  {
#line 1026
  gl->gl_opendir = & open_dirstream;
#line 1027
  gl->gl_readdir = & read_dirstream;
#line 1028
  gl->gl_closedir = (void (*)(void * ))(& free);
#line 1029
  gl->gl_stat = (int (*)(char const   * , struct stat * ))(& stat);
#line 1032
  return;
}
}
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 534 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 951 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) getloadavg)(double *loadavg ,
                                                                                                 int nelem ) ;
#line 564 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strsignal)(int __sig ) ;
#line 418 "/home/khheo/testset/make-3.76.1/make.h"
double max_load_average ;
#line 430
int handling_fatal_signal ;
#line 49 "/home/khheo/testset/make-3.76.1/job.h"
struct child *children ;
#line 51
void new_job(struct file *file ) ;
#line 64
void exec_command(char **argv , char **envp ) ;
#line 67
unsigned int job_slots_used ;
#line 69
void block_sigs(void) ;
#line 71
void unblock_sigs(void) ;
#line 41 "/home/khheo/testset/make-3.76.1/commands.h"
void delete_child_targets(struct child *child ) ;
#line 42 "/home/khheo/testset/make-3.76.1/job.c"
char default_shell[8]  = 
#line 42 "/home/khheo/testset/make-3.76.1/job.c"
  {      (char )'/',      (char )'b',      (char )'i',      (char )'n', 
        (char )'/',      (char )'s',      (char )'h',      (char )'\000'};
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 125
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 175 "/home/khheo/testset/make-3.76.1/job.c"
void child_handler(int sig ) ;
#line 176
static void free_child(struct child *child ) ;
#line 177
static void start_job_command(struct child *child ) ;
#line 178
static int load_too_high(void) ;
#line 179
static int job_next_command(struct child *child ) ;
#line 180
static int start_waiting_job(struct child *c ) ;
#line 187 "/home/khheo/testset/make-3.76.1/job.c"
struct child *children  =    (struct child *)0;
#line 191 "/home/khheo/testset/make-3.76.1/job.c"
unsigned int job_slots_used  =    0U;
#line 195 "/home/khheo/testset/make-3.76.1/job.c"
static int good_stdin_used  =    0;
#line 199 "/home/khheo/testset/make-3.76.1/job.c"
static struct child *waiting_jobs  =    (struct child *)0;
#line 203 "/home/khheo/testset/make-3.76.1/job.c"
int unixy_shell  =    1;
#line 219 "/home/khheo/testset/make-3.76.1/job.c"
static void child_error(char *target_name , int exit_code , int exit_sig , int coredump ,
                        int ignored ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 225
  if (ignored) {
#line 225
    if (silent_flag) {
#line 226
      return;
    }
  }
#line 232
  if (exit_sig == 0) {
#line 233
    if (ignored) {
#line 233
      tmp = "[%s] Error %d (ignored)";
    } else {
#line 233
      tmp = "*** [%s] Error %d";
    }
    {
#line 233
    error(tmp, target_name, exit_code);
    }
  } else {
#line 237
    if (coredump) {
#line 237
      tmp___0 = " (core dumped)";
    } else {
#line 237
      tmp___0 = "";
    }
    {
#line 237
    tmp___1 = strsignal(exit_sig);
#line 237
    error("*** [%s] %s%s", target_name, tmp___1, tmp___0);
    }
  }
#line 241
  return;
}
}
#line 243 "/home/khheo/testset/make-3.76.1/job.c"
static unsigned int dead_children  =    0U;
#line 267 "/home/khheo/testset/make-3.76.1/job.c"
void child_handler(int sig ) 
{ 
  char *__cil_tmp2 ;

  {
#line 271
  dead_children ++;
#line 273
  if (debug_flag) {
    {
#line 274
    printf((char const   */* __restrict  */)"Got a SIGCHLD; %d unreaped children.\n",
           dead_children);
    }
  }
#line 275
  return;
}
}
#line 514 "/home/khheo/testset/make-3.76.1/job.c"
static int delete_on_error  =    -1;
#line 285 "/home/khheo/testset/make-3.76.1/job.c"
void reap_children(int block , int err ) 
{ 
  int status ;
  int remote ;
  register int pid ;
  int exit_code ;
  int exit_sig ;
  int coredump ;
  register struct child *lastc ;
  register struct child *c ;
  int child_failed ;
  int any_remote ;
  int any_local ;
  char const   *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  union __anonunion_57 __constr_expr_0 ;
  union __anonunion_59 __constr_expr_2 ;
  union __anonunion_60 __constr_expr_3 ;
  union __anonunion_61 __constr_expr_4 ;
  int tmp___2 ;
  char buf___0[100] ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  struct file *f ;
  struct file *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  void *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;

  {
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    if ((unsigned long )children != (unsigned long )((struct child *)0)) {
#line 291
      goto _L___1;
    } else
#line 291
    if (shell_function_pid != 0) {
      _L___1: /* CIL Label */ 
#line 291
      if (! block) {
#line 291
        if (! (dead_children > 0U)) {
#line 291
          goto while_break;
        }
      }
    } else {
#line 291
      goto while_break;
    }
#line 294
    remote = 0;
#line 301
    if (err) {
#line 301
      if (dead_children == 0U) {
        {
#line 304
        fflush(stdout);
#line 305
        error("*** Waiting for unfinished jobs....");
        }
      }
    }
#line 320
    if (dead_children > 0U) {
#line 321
      dead_children --;
    }
#line 323
    any_remote = 0;
#line 324
    any_local = shell_function_pid != 0;
#line 325
    c = children;
    {
#line 325
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 325
      if (! ((unsigned long )c != (unsigned long )((struct child *)0))) {
#line 325
        goto while_break___0;
      }
#line 327
      any_remote = (int )((unsigned int )any_remote | c->remote);
#line 328
      any_local |= ! c->remote;
#line 329
      if (debug_flag) {
#line 330
        if (c->remote) {
#line 330
          tmp = " (remote)";
        } else {
#line 330
          tmp = "";
        }
        {
#line 330
        printf((char const   */* __restrict  */)"Live child 0x%08lx PID %d%s\n", (unsigned long )c,
               c->pid, tmp);
        }
      }
#line 325
      c = c->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 339
    if (any_remote) {
      {
#line 340
      pid = remote_status(& exit_code, & exit_sig, & coredump, 0);
      }
    } else {
#line 342
      pid = 0;
    }
#line 344
    if (pid < 0) {
      remote_status_lose: 
      {
#line 348
      tmp___0 = __errno_location();
      }
#line 348
      if (*tmp___0 == 4) {
#line 349
        goto while_continue;
      }
      {
#line 351
      pfatal_with_name("remote_status");
      }
    } else
#line 353
    if (pid == 0) {
#line 358
      if (any_local) {
#line 365
        if (! block) {
          {
#line 366
          pid = waitpid(-1, & status, 1);
          }
        } else {
          {
#line 369
          pid = wait((union wait *)(& status));
          }
        }
      } else {
#line 373
        pid = 0;
      }
#line 375
      if (pid < 0) {
        {
#line 378
        tmp___1 = __errno_location();
        }
#line 378
        if (*tmp___1 == 4) {
#line 379
          goto while_continue;
        }
        {
#line 381
        pfatal_with_name("wait");
        }
      } else
#line 383
      if (pid == 0) {
#line 386
        if (block) {
#line 386
          if (any_remote) {
            {
#line 389
            pid = remote_status(& exit_code, & exit_sig, & coredump, 1);
            }
#line 390
            if (pid < 0) {
#line 391
              goto remote_status_lose;
            } else
#line 392
            if (pid == 0) {
#line 394
              goto while_break;
            } else {
#line 397
              remote = 1;
            }
          } else {
#line 400
            goto while_break;
          }
        } else {
#line 400
          goto while_break;
        }
      } else {
#line 405
        __constr_expr_0.__in = status;
#line 405
        exit_code = (__constr_expr_0.__i & 65280) >> 8;
#line 406
        __constr_expr_3.__in = status;
#line 406
        if ((int )((signed char )((__constr_expr_3.__i & 127) + 1)) >> 1 > 0) {
#line 406
          __constr_expr_2.__in = status;
#line 406
          exit_sig = __constr_expr_2.__i & 127;
        } else {
#line 406
          exit_sig = 0;
        }
#line 407
        __constr_expr_4.__in = status;
#line 407
        coredump = __constr_expr_4.__i & 128;
      }
    } else {
#line 466
      remote = 1;
    }
#line 469
    if (! remote) {
#line 469
      if (pid == shell_function_pid) {
#line 472
        if (exit_sig == 0) {
#line 472
          if (exit_code == 127) {
#line 473
            shell_function_completed = -1;
          } else {
#line 475
            shell_function_completed = 1;
          }
        } else {
#line 475
          shell_function_completed = 1;
        }
#line 476
        goto while_break;
      }
    }
#line 479
    if (exit_sig != 0) {
#line 479
      tmp___2 = 1;
    } else
#line 479
    if (exit_code != 0) {
#line 479
      tmp___2 = 1;
    } else {
#line 479
      tmp___2 = 0;
    }
#line 479
    child_failed = tmp___2;
#line 482
    lastc = (struct child *)0;
#line 483
    c = children;
    {
#line 483
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 483
      if (! ((unsigned long )c != (unsigned long )((struct child *)0))) {
#line 483
        goto while_break___1;
      }
#line 484
      if (c->remote == (unsigned int )remote) {
#line 484
        if (c->pid == pid) {
#line 485
          goto while_break___1;
        }
      }
#line 483
      lastc = c;
#line 483
      c = c->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 487
    if ((unsigned long )c == (unsigned long )((struct child *)0)) {
#line 491
      if (remote) {
#line 491
        tmp___3 = " remote";
      } else {
#line 491
        tmp___3 = "";
      }
      {
#line 491
      sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"Unknown%s job %d",
              tmp___3, pid);
      }
#line 492
      if (child_failed) {
        {
#line 493
        child_error(buf___0, exit_code, exit_sig, coredump, ignore_errors_flag);
        }
      } else {
        {
#line 496
        error("%s finished.", buf___0);
        }
      }
    } else {
#line 500
      if (debug_flag) {
#line 501
        if (c->remote) {
#line 501
          tmp___4 = " (remote)";
        } else {
#line 501
          tmp___4 = "";
        }
#line 501
        if (child_failed) {
#line 501
          tmp___5 = "losing";
        } else {
#line 501
          tmp___5 = "winning";
        }
        {
#line 501
        printf((char const   */* __restrict  */)"Reaping %s child 0x%08lx PID %d%s\n",
               tmp___5, (unsigned long )c, c->pid, tmp___4);
        }
      }
#line 507
      if (c->good_stdin) {
#line 508
        good_stdin_used = 0;
      }
#line 510
      if (child_failed) {
#line 510
        if (! c->noerror) {
#line 510
          if (! ignore_errors_flag) {
            {
#line 515
            child_error((c->file)->name, exit_code, exit_sig, coredump, 0);
#line 516
            (c->file)->update_status = (short)2;
            }
#line 517
            if (delete_on_error == -1) {
              {
#line 519
              tmp___6 = lookup_file(".DELETE_ON_ERROR");
#line 519
              f = tmp___6;
              }
#line 520
              if ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 520
                if (f->is_target) {
#line 520
                  tmp___7 = 1;
                } else {
#line 520
                  tmp___7 = 0;
                }
              } else {
#line 520
                tmp___7 = 0;
              }
#line 520
              delete_on_error = tmp___7;
            }
#line 522
            if (exit_sig != 0) {
              {
#line 523
              delete_child_targets(c);
              }
            } else
#line 522
            if (delete_on_error) {
              {
#line 523
              delete_child_targets(c);
              }
            }
          } else {
#line 510
            goto _L___0;
          }
        } else {
#line 510
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 527
        if (child_failed) {
          {
#line 530
          child_error((c->file)->name, exit_code, exit_sig, coredump, 1);
#line 532
          child_failed = 0;
          }
        }
        {
#line 536
        tmp___9 = job_next_command(c);
        }
#line 536
        if (tmp___9) {
#line 538
          if (handling_fatal_signal) {
#line 544
            (c->file)->update_status = (short)2;
          } else {
            {
#line 552
            tmp___8 = start_remote_job_p();
#line 552
            c->remote = (unsigned int )tmp___8;
#line 553
            start_job_command(c);
#line 558
            unblock_sigs();
            }
#line 559
            if ((unsigned int )(c->file)->command_state == 2U) {
#line 562
              goto while_continue;
            }
          }
#line 565
          if ((int )(c->file)->update_status != 0) {
            {
#line 567
            delete_child_targets(c);
            }
          }
        } else {
#line 573
          (c->file)->update_status = (short)0;
        }
      }
#line 582
      if (! handling_fatal_signal) {
        {
#line 586
        notice_finished_file(c->file);
        }
      }
#line 588
      if (debug_flag) {
#line 589
        if (c->remote) {
#line 589
          tmp___10 = " (remote)";
        } else {
#line 589
          tmp___10 = "";
        }
        {
#line 589
        printf((char const   */* __restrict  */)"Removing child 0x%08lx PID %d%s from chain.\n",
               (unsigned long )c, c->pid, tmp___10);
        }
      }
      {
#line 598
      block_sigs();
      }
#line 601
      if ((unsigned long )lastc == (unsigned long )((struct child *)0)) {
#line 602
        children = c->next;
      } else {
#line 604
        lastc->next = c->next;
      }
#line 605
      if (! handling_fatal_signal) {
        {
#line 606
        free_child(c);
        }
      }
#line 609
      if (job_slots_used > 0U) {
#line 610
        job_slots_used --;
      }
      {
#line 612
      unblock_sigs();
      }
#line 616
      if (! err) {
#line 616
        if (child_failed) {
#line 616
          if (! keep_going_flag) {
#line 616
            if (! handling_fatal_signal) {
              {
#line 619
              die(2);
              }
            }
          }
        }
      }
    }
#line 623
    block = 0;
  }
  while_break: /* CIL Label */ ;
  }
#line 625
  return;
}
}
#line 630 "/home/khheo/testset/make-3.76.1/job.c"
static void free_child(struct child *child ) 
{ 
  register unsigned int i ;
  register char **ep ;
  char **tmp ;

  {
#line 634
  if ((unsigned long )child->command_lines != (unsigned long )((char **)0)) {
#line 637
    i = 0U;
    {
#line 637
    while (1) {
      while_continue: /* CIL Label */ ;
#line 637
      if (! (i < ((child->file)->cmds)->ncommand_lines)) {
#line 637
        goto while_break;
      }
      {
#line 638
      free((void *)*(child->command_lines + i));
#line 637
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 639
    free((void *)((char *)child->command_lines));
    }
  }
#line 642
  if ((unsigned long )child->environment != (unsigned long )((char **)0)) {
#line 644
    ep = child->environment;
    {
#line 645
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 645
      if (! ((unsigned long )*ep != (unsigned long )((char *)0))) {
#line 645
        goto while_break___0;
      }
      {
#line 646
      tmp = ep;
#line 646
      ep ++;
#line 646
      free((void *)*tmp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 647
    free((void *)((char *)child->environment));
    }
  }
  {
#line 650
  free((void *)((char *)child));
  }
#line 651
  return;
}
}
#line 654
sigset_t fatal_signal_set ;
#line 657 "/home/khheo/testset/make-3.76.1/job.c"
void block_sigs(void) 
{ 


  {
  {
#line 661
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& fatal_signal_set), (sigset_t */* __restrict  */)((sigset_t *)0));
  }
#line 667
  return;
}
}
#line 670 "/home/khheo/testset/make-3.76.1/job.c"
void unblock_sigs(void) 
{ 
  sigset_t empty ;

  {
  {
#line 674
  sigemptyset(& empty);
#line 675
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& empty), (sigset_t */* __restrict  */)((sigset_t *)0));
  }
#line 676
  return;
}
}
#line 691 "/home/khheo/testset/make-3.76.1/job.c"
static int bad_stdin  =    -1;
#line 686 "/home/khheo/testset/make-3.76.1/job.c"
static void start_job_command(struct child *child ) 
{ 
  register char *p ;
  int flags ;
  char **argv ;
  unsigned short const   **tmp ;
  char *end ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int pd[2] ;
  int tmp___6 ;
  int is_remote ;
  int id ;
  int used_stdin ;
  int tmp___7 ;
  int tmp___8 ;
  char **parent_environ ;
  int tmp___9 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 703
  flags = (child->file)->command_flags | (int )*(((child->file)->cmds)->lines_flags + (child->command_line - 1U));
#line 706
  p = child->command_ptr;
#line 707
  child->noerror = (unsigned int )(flags & 4);
  {
#line 709
  while (1) {
    while_continue: /* CIL Label */ ;
#line 709
    if (! ((int )*p != 0)) {
#line 709
      goto while_break;
    }
#line 711
    if ((int )*p == 64) {
#line 712
      flags |= 2;
    } else
#line 713
    if ((int )*p == 43) {
#line 714
      flags |= 1;
    } else
#line 715
    if ((int )*p == 45) {
#line 716
      child->noerror = 1U;
    } else {
      {
#line 717
      tmp = __ctype_b_loc();
      }
#line 717
      if (! ((int const   )*(*tmp + (int )*p) & 1)) {
#line 717
        if ((int )*p != 43) {
#line 718
          goto while_break;
        }
      }
    }
#line 719
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 725
  if (question_flag) {
#line 725
    if (! (flags & 1)) {
      {
#line 727
      (child->file)->update_status = (short)1;
#line 728
      notice_finished_file(child->file);
      }
#line 729
      return;
    }
  }
  {
#line 734
  p = next_token(p);
#line 739
  end = (char *)0;
#line 743
  argv = construct_command_argv(p, & end, child->file);
  }
#line 745
  if ((unsigned long )end == (unsigned long )((void *)0)) {
#line 746
    child->command_ptr = (char *)((void *)0);
  } else {
#line 749
    tmp___0 = end;
#line 749
    end ++;
#line 749
    *tmp___0 = (char )'\000';
#line 750
    child->command_ptr = end;
  }
#line 754
  if (touch_flag) {
#line 754
    if (! (flags & 1)) {
      {
#line 759
      free((void *)*(argv + 0));
#line 760
      free((void *)((char *)argv));
#line 762
      argv = (char **)0;
      }
    }
  }
#line 765
  if ((unsigned long )argv == (unsigned long )((char **)0)) {
    next_command: 
    {
#line 769
    tmp___1 = job_next_command(child);
    }
#line 769
    if (tmp___1) {
      {
#line 770
      start_job_command(child);
      }
    } else {
      {
#line 774
      (child->file)->update_status = (short)0;
#line 775
      notice_finished_file(child->file);
      }
    }
#line 777
    return;
  }
#line 784
  if (just_print_flag) {
#line 784
    tmp___2 = "%s";
  } else
#line 784
  if (! (flags & 2)) {
#line 784
    if (! silent_flag) {
#line 784
      tmp___2 = "%s";
    } else {
#line 784
      tmp___2 = (char const   *)((char *)0);
    }
  } else {
#line 784
    tmp___2 = (char const   *)((char *)0);
  }
  {
#line 784
  message(0, tmp___2, p);
  }
#line 791
  if (*(argv + 0)) {
    {
#line 791
    tmp___3 = strcmp((char const   *)*(argv + 0), "/bin/sh");
    }
#line 791
    if (! tmp___3) {
#line 791
      if (*(argv + 1)) {
        {
#line 791
        tmp___4 = strcmp((char const   *)*(argv + 1), "-c");
        }
#line 791
        if (! tmp___4) {
#line 791
          if (*(argv + 2)) {
            {
#line 791
            tmp___5 = strcmp((char const   *)*(argv + 2), ":");
            }
#line 791
            if (! tmp___5) {
#line 791
              if ((unsigned long )*(argv + 3) == (unsigned long )((void *)0)) {
                {
#line 801
                set_command_state(child->file, 2);
                }
#line 802
                goto next_command;
              }
            }
          }
        }
      }
    }
  }
#line 813
  commands_started ++;
#line 817
  if (just_print_flag) {
#line 817
    if (! (flags & 1)) {
      {
#line 820
      free((void *)*(argv + 0));
#line 821
      free((void *)((char *)argv));
      }
#line 823
      goto next_command;
    }
  }
  {
#line 828
  fflush(stdout);
#line 829
  fflush(stderr);
  }
#line 836
  if (bad_stdin == -1) {
    {
#line 841
    tmp___6 = pipe((int *)(pd));
    }
#line 841
    if (tmp___6 == 0) {
      {
#line 844
      close(pd[1]);
#line 846
      bad_stdin = pd[0];
      }
    }
  }
#line 866
  child->good_stdin = (unsigned int )(! good_stdin_used);
#line 867
  if (child->good_stdin) {
#line 868
    good_stdin_used = 1;
  }
#line 872
  child->deleted = 0U;
#line 876
  if ((unsigned long )child->environment == (unsigned long )((char **)0)) {
    {
#line 877
    child->environment = target_environment(child->file);
    }
  }
#line 884
  if (child->remote) {
#line 887
    if (child->good_stdin) {
#line 887
      tmp___7 = 0;
    } else {
#line 887
      tmp___7 = bad_stdin;
    }
    {
#line 887
    tmp___8 = start_remote_job(argv, child->environment, tmp___7, & is_remote, & id,
                               & used_stdin);
    }
#line 887
    if (tmp___8) {
#line 890
      goto error;
    } else {
#line 893
      if (child->good_stdin) {
#line 893
        if (! used_stdin) {
#line 895
          child->good_stdin = 0U;
#line 896
          good_stdin_used = 0;
        }
      }
#line 898
      child->remote = (unsigned int )is_remote;
#line 899
      child->pid = id;
    }
  } else {
    {
#line 909
    block_sigs();
#line 911
    child->remote = 0U;
#line 923
    parent_environ = environ;
#line 924
    child->pid = vfork();
#line 925
    environ = parent_environ;
    }
#line 926
    if (child->pid == 0) {
      {
#line 929
      unblock_sigs();
      }
#line 930
      if (child->good_stdin) {
#line 930
        tmp___9 = 0;
      } else {
#line 930
        tmp___9 = bad_stdin;
      }
      {
#line 930
      child_execute_job(tmp___9, 1, argv, child->environment);
      }
    } else
#line 933
    if (child->pid < 0) {
      {
#line 936
      unblock_sigs();
#line 937
      perror_with_name("vfork", "");
      }
#line 938
      goto error;
    }
  }
  {
#line 1041
  set_command_state(child->file, 2);
#line 1045
  free((void *)*(argv + 0));
#line 1046
  free((void *)((char *)argv));
  }
#line 1049
  return;
  error: 
  {
#line 1052
  (child->file)->update_status = (short)2;
#line 1053
  notice_finished_file(child->file);
  }
#line 1054
  return;
}
}
#line 1061 "/home/khheo/testset/make-3.76.1/job.c"
static int start_waiting_job(struct child *c ) 
{ 
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 1069
  tmp = start_remote_job_p();
#line 1069
  c->remote = (unsigned int )tmp;
  }
#line 1073
  if (! c->remote) {
#line 1073
    if (job_slots_used > 0U) {
      {
#line 1073
      tmp___0 = load_too_high();
      }
#line 1073
      if (tmp___0) {
        {
#line 1077
        set_command_state(c->file, 2);
#line 1078
        c->next = waiting_jobs;
#line 1079
        waiting_jobs = c;
        }
#line 1080
        return (0);
      }
    }
  }
  {
#line 1084
  start_job_command(c);
  }
  {
#line 1088
  if ((unsigned int )(c->file)->command_state == 2U) {
#line 1088
    goto case_2;
  }
#line 1100
  if ((unsigned int )(c->file)->command_state == 0U) {
#line 1100
    goto case_0;
  }
#line 1105
  if ((unsigned int )(c->file)->command_state == 3U) {
#line 1105
    goto case_3;
  }
#line 1110
  goto switch_default;
  case_2: /* CIL Label */ 
#line 1089
  c->next = children;
#line 1090
  if (debug_flag) {
#line 1091
    if (c->remote) {
#line 1091
      tmp___1 = " (remote)";
    } else {
#line 1091
      tmp___1 = "";
    }
    {
#line 1091
    printf((char const   */* __restrict  */)"Putting child 0x%08lx PID %05d%s on the chain.\n",
           (unsigned long )c, c->pid, tmp___1);
    }
  }
  {
#line 1094
  children = c;
#line 1096
  job_slots_used ++;
#line 1097
  unblock_sigs();
  }
#line 1098
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1102
  (c->file)->update_status = (short)0;
  case_3: /* CIL Label */ 
  {
#line 1106
  notice_finished_file(c->file);
#line 1107
  free_child(c);
  }
#line 1108
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1111
  if (! ((unsigned int )(c->file)->command_state == 3U)) {
    {
#line 1111
    __assert_fail("c->file->command_state == cs_finished", "/home/khheo/testset/make-3.76.1/job.c",
                  1111U, "start_waiting_job");
    }
  }
#line 1112
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1115
  return (1);
}
}
#line 1120 "/home/khheo/testset/make-3.76.1/job.c"
void new_job(struct file *file ) 
{ 
  register struct commands *cmds ;
  register struct child *c ;
  char **lines ;
  register unsigned int i ;
  char *tmp ;
  char *in ;
  char *out ;
  char *ref___0 ;
  char openparen ;
  char closeparen ;
  int tmp___0 ;
  int count ;
  char *p ;
  char *tmp___1 ;
  char *tmp___2 ;
  int quoted ;
  char *tmp___3 ;
  char *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 1124
  cmds = file->cmds;
#line 1131
  start_waiting_jobs();
#line 1134
  reap_children(0, 0);
#line 1137
  chop_commands(cmds);
  }
#line 1139
  if (job_slots != 0U) {
    {
#line 1141
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1141
      if (! (job_slots_used == job_slots)) {
#line 1141
        goto while_break;
      }
      {
#line 1142
      reap_children(1, 0);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1145
  tmp = xmalloc((unsigned long )cmds->ncommand_lines * sizeof(char *));
#line 1145
  lines = (char **)tmp;
#line 1146
  i = 0U;
  }
  {
#line 1146
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1146
    if (! (i < cmds->ncommand_lines)) {
#line 1146
      goto while_break___0;
    }
#line 1162
    out = *(cmds->command_lines + i);
#line 1162
    in = out;
    {
#line 1163
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1163
      ref___0 = strchr((char const   *)in, '$');
      }
#line 1163
      if (! ((unsigned long )ref___0 != (unsigned long )((char *)0))) {
#line 1163
        goto while_break___1;
      }
#line 1165
      ref___0 ++;
#line 1167
      if ((unsigned long )out != (unsigned long )in) {
        {
#line 1171
        memmove((void *)out, (void const   *)in, (size_t )(ref___0 - in));
        }
      }
#line 1174
      out += ref___0 - in;
#line 1175
      in = ref___0;
#line 1177
      if ((int )*ref___0 == 40) {
#line 1177
        goto _L___1;
      } else
#line 1177
      if ((int )*ref___0 == 123) {
        _L___1: /* CIL Label */ 
#line 1179
        openparen = *ref___0;
#line 1180
        if ((int )openparen == 40) {
#line 1180
          tmp___0 = ')';
        } else {
#line 1180
          tmp___0 = '}';
        }
#line 1180
        closeparen = (char )tmp___0;
#line 1184
        tmp___1 = out;
#line 1184
        out ++;
#line 1184
        tmp___2 = in;
#line 1184
        in ++;
#line 1184
        *tmp___1 = *tmp___2;
#line 1187
        count = 0;
        {
#line 1188
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1188
          if (! ((int )*in != 0)) {
#line 1188
            goto while_break___2;
          }
#line 1190
          if ((int )*in == (int )closeparen) {
#line 1190
            count --;
#line 1190
            if (count < 0) {
#line 1191
              goto while_break___2;
            } else {
#line 1190
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 1192
          if ((int )*in == 92) {
#line 1192
            if ((int )*(in + 1) == 10) {
#line 1198
              quoted = 0;
#line 1199
              p = in - 1;
              {
#line 1199
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 1199
                if ((unsigned long )p > (unsigned long )ref___0) {
#line 1199
                  if (! ((int )*p == 92)) {
#line 1199
                    goto while_break___3;
                  }
                } else {
#line 1199
                  goto while_break___3;
                }
#line 1200
                quoted = ! quoted;
#line 1199
                p --;
              }
              while_break___3: /* CIL Label */ ;
              }
#line 1202
              if (quoted) {
#line 1208
                tmp___3 = out;
#line 1208
                out ++;
#line 1208
                tmp___4 = in;
#line 1208
                in ++;
#line 1208
                *tmp___3 = *tmp___4;
              } else {
                {
#line 1213
                in = next_token(in + 2);
                }
                {
#line 1217
                while (1) {
                  while_continue___4: /* CIL Label */ ;
#line 1217
                  if ((unsigned long )out > (unsigned long )ref___0) {
                    {
#line 1217
                    tmp___5 = __ctype_b_loc();
                    }
#line 1217
                    if (! ((int const   )*(*tmp___5 + (int )*(out + -1)) & 1)) {
#line 1217
                      goto while_break___4;
                    }
                  } else {
#line 1217
                    goto while_break___4;
                  }
#line 1218
                  out --;
                }
                while_break___4: /* CIL Label */ ;
                }
#line 1221
                tmp___6 = out;
#line 1221
                out ++;
#line 1221
                *tmp___6 = (char )' ';
              }
            } else {
#line 1192
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 1226
            if ((int )*in == (int )openparen) {
#line 1227
              count ++;
            }
#line 1229
            tmp___7 = out;
#line 1229
            out ++;
#line 1229
            tmp___8 = in;
#line 1229
            in ++;
#line 1229
            *tmp___7 = *tmp___8;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1237
    if ((unsigned long )out != (unsigned long )in) {
      {
#line 1238
      strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)in);
      }
    }
    {
#line 1241
    *(lines + i) = allocated_variable_expand_for_file(*(cmds->command_lines + i),
                                                      file);
#line 1146
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1248
  tmp___9 = xmalloc(sizeof(struct child ));
#line 1248
  c = (struct child *)tmp___9;
#line 1249
  c->file = file;
#line 1250
  c->command_lines = lines;
#line 1251
  c->command_line = 0U;
#line 1252
  c->command_ptr = (char *)0;
#line 1253
  c->environment = (char **)0;
#line 1256
  job_next_command(c);
#line 1260
  start_waiting_job(c);
  }
#line 1262
  if (job_slots == 1U) {
    {
#line 1265
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1265
      if (! ((unsigned int )file->command_state == 2U)) {
#line 1265
        goto while_break___5;
      }
      {
#line 1266
      reap_children(1, 0);
      }
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 1268
  return;
}
}
#line 1274 "/home/khheo/testset/make-3.76.1/job.c"
static int job_next_command(struct child *child ) 
{ 
  unsigned int tmp ;

  {
  {
#line 1278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1278
    if (! ((unsigned long )child->command_ptr == (unsigned long )((char *)0))) {
#line 1278
      if (! ((int )*(child->command_ptr) == 0)) {
#line 1278
        goto while_break;
      }
    }
#line 1281
    if (child->command_line == ((child->file)->cmds)->ncommand_lines) {
#line 1284
      child->command_ptr = (char *)0;
#line 1285
      return (0);
    } else {
#line 1289
      tmp = child->command_line;
#line 1289
      (child->command_line) ++;
#line 1289
      child->command_ptr = *(child->command_lines + tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1291
  return (1);
}
}
#line 1308 "/home/khheo/testset/make-3.76.1/job.c"
static int lossage  =    -1;
#line 1294 "/home/khheo/testset/make-3.76.1/job.c"
static int load_too_high(void) 
{ 
  double load ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 1302
  if (max_load_average < (double )0) {
#line 1303
    return (0);
  }
  {
#line 1305
  make_access();
#line 1306
  tmp___2 = getloadavg(& load, 1);
  }
#line 1306
  if (tmp___2 != 1) {
#line 1310
    if (lossage == -1) {
#line 1310
      goto _L;
    } else {
      {
#line 1310
      tmp___0 = __errno_location();
      }
#line 1310
      if (*tmp___0 != lossage) {
        _L: /* CIL Label */ 
        {
#line 1312
        tmp = __errno_location();
        }
#line 1312
        if (*tmp == 0) {
          {
#line 1314
          error("cannot enforce load limits on this operating system");
          }
        } else {
          {
#line 1316
          perror_with_name("cannot enforce load limit: ", "getloadavg");
          }
        }
      }
    }
    {
#line 1318
    tmp___1 = __errno_location();
#line 1318
    lossage = *tmp___1;
#line 1319
    load = (double )0;
    }
  }
  {
#line 1321
  user_access();
  }
#line 1323
  return (load >= max_load_average);
}
}
#line 1329 "/home/khheo/testset/make-3.76.1/job.c"
void start_waiting_jobs(void) 
{ 
  struct child *job ;
  int tmp ;

  {
#line 1334
  if ((unsigned long )waiting_jobs == (unsigned long )((struct child *)0)) {
#line 1335
    return;
  }
  {
#line 1337
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1340
    reap_children(0, 0);
#line 1343
    job = waiting_jobs;
#line 1344
    waiting_jobs = job->next;
#line 1337
    tmp = start_waiting_job(job);
    }
#line 1337
    if (tmp) {
#line 1337
      if (! ((unsigned long )waiting_jobs != (unsigned long )((struct child *)0))) {
#line 1337
        goto while_break;
      }
    } else {
#line 1337
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1351
  return;
}
}
#line 1573 "/home/khheo/testset/make-3.76.1/job.c"
void child_execute_job(int stdin_fd , int stdout_fd , char **argv , char **envp ) 
{ 


  {
#line 1578
  if (stdin_fd != 0) {
    {
#line 1579
    dup2(stdin_fd, 0);
    }
  }
#line 1580
  if (stdout_fd != 1) {
    {
#line 1581
    dup2(stdout_fd, 1);
    }
  }
#line 1582
  if (stdin_fd != 0) {
    {
#line 1583
    close(stdin_fd);
    }
  }
#line 1584
  if (stdout_fd != 1) {
    {
#line 1585
    close(stdout_fd);
    }
  }
  {
#line 1588
  exec_command(argv, envp);
  }
#line 1589
  return;
}
}
#line 1598 "/home/khheo/testset/make-3.76.1/job.c"
void exec_command(char **argv , char **envp ) 
{ 
  int *tmp ;
  char *shell ;
  char **new_argv ;
  int argc ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 1664
  child_access();
#line 1667
  environ = envp;
#line 1668
  execvp((char const   *)*(argv + 0), (char * const  *)argv);
#line 1670
  tmp = __errno_location();
  }
  {
#line 1672
  if (*tmp == 2) {
#line 1672
    goto case_2;
  }
#line 1675
  if (*tmp == 8) {
#line 1675
    goto case_8;
  }
#line 1708
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 1673
  error("%s: Command not found", *(argv + 0));
  }
#line 1674
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1683
  shell = getenv("SHELL");
  }
#line 1684
  if ((unsigned long )shell == (unsigned long )((char *)0)) {
#line 1685
    shell = default_shell;
  }
#line 1687
  argc = 1;
  {
#line 1688
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1688
    if (! ((unsigned long )*(argv + argc) != (unsigned long )((char *)0))) {
#line 1688
      goto while_break;
    }
#line 1689
    argc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1691
  tmp___0 = __builtin_alloca((unsigned long )((1 + argc) + 1) * sizeof(char *));
#line 1691
  new_argv = (char **)tmp___0;
#line 1692
  *(new_argv + 0) = shell;
#line 1693
  *(new_argv + 1) = *(argv + 0);
  }
  {
#line 1694
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1694
    if (! (argc > 0)) {
#line 1694
      goto while_break___0;
    }
#line 1696
    *(new_argv + (1 + argc)) = *(argv + argc);
#line 1697
    argc --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1700
  execvp((char const   *)shell, (char * const  *)new_argv);
#line 1701
  tmp___1 = __errno_location();
  }
#line 1701
  if (*tmp___1 == 2) {
    {
#line 1702
    error("%s: Shell program not found", shell);
    }
  } else {
    {
#line 1704
    perror_with_name("execvp: ", shell);
    }
  }
#line 1705
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1709
  perror_with_name("execvp: ", *(argv + 0));
  }
#line 1710
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1713
  _exit(127);
  }
}
}
#line 1817
static char **construct_command_argv_internal(char *line , char **restp , char *shell ,
                                              char *ifs ) ;
#line 1817 "/home/khheo/testset/make-3.76.1/job.c"
static char sh_chars[19]  = 
#line 1817
  {      (char )'#',      (char )';',      (char )'\"',      (char )'*', 
        (char )'?',      (char )'[',      (char )']',      (char )'&', 
        (char )'|',      (char )'<',      (char )'>',      (char )'(', 
        (char )')',      (char )'{',      (char )'}',      (char )'$', 
        (char )'`',      (char )'^',      (char )'\000'};
#line 1818 "/home/khheo/testset/make-3.76.1/job.c"
static char *sh_cmds[25]  = 
#line 1818
  {      (char *)"cd",      (char *)"eval",      (char *)"exec",      (char *)"exit", 
        (char *)"login",      (char *)"logout",      (char *)"set",      (char *)"umask", 
        (char *)"wait",      (char *)"while",      (char *)"for",      (char *)"case", 
        (char *)"if",      (char *)":",      (char *)".",      (char *)"break", 
        (char *)"continue",      (char *)"export",      (char *)"read",      (char *)"readonly", 
        (char *)"shift",      (char *)"times",      (char *)"trap",      (char *)"switch", 
        (char *)0};
#line 2187 "/home/khheo/testset/make-3.76.1/job.c"
static char minus_c[5]  = {      (char )' ',      (char )'-',      (char )'c',      (char )' ', 
        (char )'\000'};
#line 1745 "/home/khheo/testset/make-3.76.1/job.c"
static char **construct_command_argv_internal(char *line , char **restp , char *shell ,
                                              char *ifs ) 
{ 
  register int i ;
  register char *p ;
  register char *ap ;
  char *end ;
  int instring ;
  int word_has_equals ;
  int seen_nonequals ;
  int last_argument_was_empty ;
  char **new_argv ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  register int j ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  register int j___0 ;
  int tmp___15 ;
  unsigned int shell_len ;
  size_t tmp___16 ;
  unsigned int line_len ;
  size_t tmp___17 ;
  char *new_line ;
  void *tmp___18 ;
  size_t tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  unsigned short const   **tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *__cil_tmp46 ;

  {
#line 1831
  new_argv = (char **)0;
#line 1844
  if ((unsigned long )restp != (unsigned long )((void *)0)) {
#line 1845
    *restp = (char *)((void *)0);
  }
  {
#line 1848
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1848
    tmp = __ctype_b_loc();
    }
#line 1848
    if (! ((int const   )*(*tmp + (int )*line) & 1)) {
#line 1848
      goto while_break;
    }
#line 1849
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1850
  if ((int )*line == 0) {
#line 1851
    return ((char **)0);
  }
#line 1854
  if ((unsigned long )shell == (unsigned long )((char *)0)) {
#line 1855
    shell = default_shell;
  } else {
    {
#line 1892
    tmp___0 = strcmp((char const   *)shell, (char const   *)(default_shell));
    }
#line 1892
    if (tmp___0) {
#line 1893
      goto slow;
    }
  }
#line 1897
  if ((unsigned long )ifs != (unsigned long )((char *)0)) {
#line 1898
    ap = ifs;
    {
#line 1898
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1898
      if (! ((int )*ap != 0)) {
#line 1898
        goto while_break___0;
      }
#line 1899
      if ((int )*ap != 32) {
#line 1899
        if ((int )*ap != 9) {
#line 1899
          if ((int )*ap != 10) {
#line 1900
            goto slow;
          }
        }
      }
#line 1898
      ap ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1902
  tmp___1 = strlen((char const   *)line);
#line 1902
  i = (int )(tmp___1 + 1UL);
#line 1905
  tmp___2 = xmalloc((unsigned long )i * sizeof(char *));
#line 1905
  new_argv = (char **)tmp___2;
#line 1908
  tmp___4 = xmalloc(i);
#line 1908
  tmp___3 = tmp___4;
#line 1908
  *(new_argv + 0) = tmp___3;
#line 1908
  ap = tmp___3;
#line 1909
  end = ap + i;
#line 1912
  i = 0;
#line 1913
  last_argument_was_empty = 0;
#line 1913
  seen_nonequals = last_argument_was_empty;
#line 1913
  word_has_equals = seen_nonequals;
#line 1913
  instring = word_has_equals;
#line 1914
  p = line;
  }
  {
#line 1914
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1914
    if (! ((int )*p != 0)) {
#line 1914
      goto while_break___1;
    }
#line 1916
    if ((unsigned long )ap > (unsigned long )end) {
      {
#line 1917
      abort();
      }
    }
#line 1919
    if (instring) {
      string_char: 
#line 1924
      if ((int )*p == instring) {
#line 1926
        instring = 0;
#line 1927
        if ((unsigned long )ap == (unsigned long )*(new_argv + 0)) {
#line 1928
          last_argument_was_empty = 1;
        } else
#line 1927
        if ((int )*(ap - 1) == 0) {
#line 1928
          last_argument_was_empty = 1;
        }
      } else
#line 1930
      if ((int )*p == 92) {
#line 1930
        if ((int )*(p + 1) == 10) {
#line 1931
          goto swallow_escaped_newline;
        } else {
#line 1930
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1932
      if ((int )*p == 10) {
#line 1932
        if ((unsigned long )restp != (unsigned long )((void *)0)) {
#line 1935
          *restp = p;
#line 1936
          goto end_of_line;
        } else {
#line 1932
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1942
      if (instring == 34) {
        {
#line 1942
        tmp___6 = strchr("\\$`", (int )*p);
        }
#line 1942
        if ((unsigned long )tmp___6 != (unsigned long )((char *)0)) {
#line 1942
          if (unixy_shell) {
#line 1943
            goto slow;
          } else {
#line 1945
            tmp___5 = ap;
#line 1945
            ap ++;
#line 1945
            *tmp___5 = *p;
          }
        } else {
#line 1945
          tmp___5 = ap;
#line 1945
          ap ++;
#line 1945
          *tmp___5 = *p;
        }
      } else {
#line 1945
        tmp___5 = ap;
#line 1945
        ap ++;
#line 1945
        *tmp___5 = *p;
      }
    } else {
      {
#line 1947
      tmp___14 = strchr((char const   *)(sh_chars), (int )*p);
      }
#line 1947
      if ((unsigned long )tmp___14 != (unsigned long )((char *)0)) {
#line 1949
        goto slow;
      } else {
        {
#line 1959
        if ((int )*p == 61) {
#line 1959
          goto case_61;
        }
#line 1970
        if ((int )*p == 92) {
#line 1970
          goto case_92;
        }
#line 2006
        if ((int )*p == 34) {
#line 2006
          goto case_34;
        }
#line 2006
        if ((int )*p == 39) {
#line 2006
          goto case_34;
        }
#line 2010
        if ((int )*p == 10) {
#line 2010
          goto case_10;
        }
#line 2023
        if ((int )*p == 9) {
#line 2023
          goto end_of_arg;
        }
#line 2023
        if ((int )*p == 32) {
#line 2023
          goto end_of_arg;
        }
#line 2057
        goto switch_default;
        case_61: /* CIL Label */ 
#line 1964
        if (! seen_nonequals) {
#line 1964
          if (unixy_shell) {
#line 1965
            goto slow;
          }
        }
#line 1966
        word_has_equals = 1;
#line 1967
        tmp___7 = ap;
#line 1967
        ap ++;
#line 1967
        *tmp___7 = (char )'=';
#line 1968
        goto switch_break;
        case_92: /* CIL Label */ 
#line 1972
        if ((int )*(p + 1) == 10) {
          swallow_escaped_newline: 
#line 1978
          p += 2;
#line 1984
          if ((int )*p == 9) {
            {
#line 1985
            strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)(p + 1));
            }
          }
#line 1987
          if (instring) {
#line 1988
            goto string_char;
          } else
#line 1991
          if ((unsigned long )ap != (unsigned long )*(new_argv + i)) {
#line 1995
            goto end_of_arg;
          } else {
            {
#line 1997
            tmp___8 = next_token(p);
#line 1997
            p = tmp___8 - 1;
            }
          }
        } else
#line 2000
        if ((int )*(p + 1) != 0) {
#line 2002
          tmp___9 = ap;
#line 2002
          ap ++;
#line 2002
          p ++;
#line 2002
          *tmp___9 = *p;
        }
#line 2003
        goto switch_break;
        case_34: /* CIL Label */ 
        case_39: /* CIL Label */ 
#line 2007
        instring = (int )*p;
#line 2008
        goto switch_break;
        case_10: /* CIL Label */ 
#line 2011
        if ((unsigned long )restp != (unsigned long )((void *)0)) {
#line 2014
          *restp = p;
#line 2015
          goto end_of_line;
        } else {
#line 2019
          tmp___10 = ap;
#line 2019
          ap ++;
#line 2019
          *tmp___10 = (char )'\n';
        }
#line 2020
        goto switch_break;
        end_of_arg: 
        case_9: /* CIL Label */ 
        case_32: /* CIL Label */ 
#line 2027
        tmp___11 = ap;
#line 2027
        ap ++;
#line 2027
        *tmp___11 = (char )'\000';
#line 2028
        i ++;
#line 2028
        *(new_argv + i) = ap;
#line 2029
        last_argument_was_empty = 0;
#line 2033
        seen_nonequals |= ! word_has_equals;
#line 2034
        if (word_has_equals) {
#line 2034
          if (! seen_nonequals) {
#line 2037
            goto slow;
          }
        }
#line 2038
        word_has_equals = 0;
#line 2043
        if (i == 1) {
#line 2046
          j = 0;
          {
#line 2046
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2046
            if (! ((unsigned long )sh_cmds[j] != (unsigned long )((char *)0))) {
#line 2046
              goto while_break___2;
            }
#line 2047
            if ((unsigned long )sh_cmds[j] == (unsigned long )*(new_argv + 0)) {
#line 2048
              goto slow;
            } else
#line 2047
            if ((int )*(sh_cmds[j]) == (int )*(*(new_argv + 0))) {
#line 2047
              if ((int )*(sh_cmds[j]) == 0) {
#line 2048
                goto slow;
              } else {
                {
#line 2047
                tmp___12 = strcmp((char const   *)(sh_cmds[j] + 1), (char const   *)(*(new_argv + 0) + 1));
                }
#line 2047
                if (! tmp___12) {
#line 2048
                  goto slow;
                }
              }
            }
#line 2046
            j ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
        {
#line 2052
        p = next_token(p);
#line 2054
        p --;
        }
#line 2055
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 2058
        tmp___13 = ap;
#line 2058
        ap ++;
#line 2058
        *tmp___13 = *p;
#line 2059
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
#line 1914
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  end_of_line: 
#line 2064
  if (instring) {
#line 2066
    goto slow;
  }
#line 2070
  *ap = (char )'\000';
#line 2071
  if ((int )*(*(new_argv + i) + 0) != 0) {
#line 2072
    i ++;
  } else
#line 2071
  if (last_argument_was_empty) {
#line 2072
    i ++;
  }
#line 2073
  *(new_argv + i) = (char *)0;
#line 2075
  if (i == 1) {
#line 2078
    j___0 = 0;
    {
#line 2078
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2078
      if (! ((unsigned long )sh_cmds[j___0] != (unsigned long )((char *)0))) {
#line 2078
        goto while_break___3;
      }
#line 2079
      if ((unsigned long )sh_cmds[j___0] == (unsigned long )*(new_argv + 0)) {
#line 2080
        goto slow;
      } else
#line 2079
      if ((int )*(sh_cmds[j___0]) == (int )*(*(new_argv + 0))) {
#line 2079
        if ((int )*(sh_cmds[j___0]) == 0) {
#line 2080
          goto slow;
        } else {
          {
#line 2079
          tmp___15 = strcmp((char const   *)(sh_cmds[j___0] + 1), (char const   *)(*(new_argv + 0) + 1));
          }
#line 2079
          if (! tmp___15) {
#line 2080
            goto slow;
          }
        }
      }
#line 2078
      j___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 2083
  if ((unsigned long )*(new_argv + 0) == (unsigned long )((char *)0)) {
#line 2085
    return ((char **)0);
  } else {
#line 2087
    return (new_argv);
  }
  slow: ;
#line 2092
  if ((unsigned long )new_argv != (unsigned long )((char **)0)) {
    {
#line 2095
    free((void *)*(new_argv + 0));
#line 2096
    free((void *)new_argv);
    }
  }
  {
#line 2186
  tmp___16 = strlen((char const   *)shell);
#line 2186
  shell_len = (unsigned int )tmp___16;
#line 2188
  tmp___17 = strlen((char const   *)line);
#line 2188
  line_len = (unsigned int )tmp___17;
#line 2190
  tmp___18 = __builtin_alloca((((unsigned long )shell_len + (sizeof(minus_c) - 1UL)) + (unsigned long )(line_len * 2U)) + 1UL);
#line 2190
  new_line = (char *)tmp___18;
#line 2193
  ap = new_line;
#line 2194
  memmove((void *)ap, (void const   *)shell, (size_t )shell_len);
#line 2195
  ap += shell_len;
#line 2196
  memmove((void *)ap, (void const   *)(minus_c), sizeof(minus_c) - 1UL);
#line 2197
  ap += sizeof(minus_c) - 1UL;
#line 2198
  p = line;
  }
  {
#line 2198
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2198
    if (! ((int )*p != 0)) {
#line 2198
      goto while_break___4;
    }
#line 2200
    if ((unsigned long )restp != (unsigned long )((void *)0)) {
#line 2200
      if ((int )*p == 10) {
#line 2202
        *restp = p;
#line 2203
        goto while_break___4;
      } else {
#line 2200
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 2205
    if ((int )*p == 92) {
#line 2205
      if ((int )*(p + 1) == 10) {
#line 2210
        p += 2;
#line 2216
        if ((int )*p == 9) {
          {
#line 2217
          tmp___19 = strlen((char const   *)p);
#line 2217
          memmove((void *)p, (void const   *)(p + 1), tmp___19);
          }
        }
        {
#line 2219
        p = next_token(p);
#line 2220
        p --;
        }
#line 2221
        if (unixy_shell) {
#line 2222
          tmp___20 = ap;
#line 2222
          ap ++;
#line 2222
          *tmp___20 = (char )'\\';
        }
#line 2223
        tmp___21 = ap;
#line 2223
        ap ++;
#line 2223
        *tmp___21 = (char )' ';
#line 2224
        goto __Cont;
      }
    }
#line 2228
    if (unixy_shell) {
#line 2228
      if ((int )*p == 92) {
#line 2232
        tmp___22 = ap;
#line 2232
        ap ++;
#line 2232
        *tmp___22 = (char )'\\';
      } else
#line 2228
      if ((int )*p == 39) {
#line 2232
        tmp___22 = ap;
#line 2232
        ap ++;
#line 2232
        *tmp___22 = (char )'\\';
      } else
#line 2228
      if ((int )*p == 34) {
#line 2232
        tmp___22 = ap;
#line 2232
        ap ++;
#line 2232
        *tmp___22 = (char )'\\';
      } else {
        {
#line 2228
        tmp___23 = __ctype_b_loc();
        }
#line 2228
        if ((int const   )*(*tmp___23 + (int )*p) & 8192) {
#line 2232
          tmp___22 = ap;
#line 2232
          ap ++;
#line 2232
          *tmp___22 = (char )'\\';
        } else {
          {
#line 2228
          tmp___24 = strchr((char const   *)(sh_chars), (int )*p);
          }
#line 2228
          if ((unsigned long )tmp___24 != (unsigned long )((char *)0)) {
#line 2232
            tmp___22 = ap;
#line 2232
            ap ++;
#line 2232
            *tmp___22 = (char )'\\';
          }
        }
      }
    }
#line 2242
    tmp___25 = ap;
#line 2242
    ap ++;
#line 2242
    *tmp___25 = *p;
    __Cont: /* CIL Label */ 
#line 2198
    p ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2244
  if ((unsigned long )ap == (unsigned long )(((new_line + shell_len) + sizeof(minus_c)) - 1)) {
#line 2246
    return ((char **)0);
  }
#line 2247
  *ap = (char )'\000';
#line 2249
  if (unixy_shell) {
    {
#line 2250
    new_argv = construct_command_argv_internal(new_line, (char **)((void *)0), (char *)0,
                                               (char *)0);
    }
  }
#line 2269
  return (new_argv);
}
}
#line 2285 "/home/khheo/testset/make-3.76.1/job.c"
char **construct_command_argv(char *line , char **restp , struct file *file ) 
{ 
  char *shell ;
  char *ifs ;
  char **argv ;
  int save ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 2295
  save = warn_undefined_variables_flag;
#line 2296
  warn_undefined_variables_flag = 0;
#line 2298
  shell = allocated_variable_expand_for_file((char *)"$(SHELL)", file);
#line 2309
  ifs = allocated_variable_expand_for_file((char *)"$(IFS)", file);
#line 2311
  warn_undefined_variables_flag = save;
#line 2314
  argv = construct_command_argv_internal(line, restp, shell, ifs);
#line 2316
  free((void *)shell);
#line 2317
  free((void *)ifs);
  }
#line 2319
  return (argv);
}
}
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 34 "/home/khheo/testset/make-3.76.1/commands.c"
static void set_file_variables(struct file *file ) 
{ 
  register char *p ;
  char *at ;
  char *percent ;
  char *star ;
  char *less ;
  unsigned int len ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  register struct dep *d ;
  char *name___0 ;
  unsigned int len___0 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  struct file *tmp___7 ;
  unsigned int slen ;
  char *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  register unsigned int qmark_len ;
  register unsigned int plus_len ;
  char *caret_value ;
  char *plus_value ;
  register char *cp ;
  char *qmark_value ;
  register char *qp ;
  register struct dep *d___0 ;
  unsigned int len___1 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  void *tmp___15 ;
  char *c ;
  char *tmp___16 ;
  char *tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  void *tmp___23 ;
  char *c___0 ;
  char *tmp___24 ;
  char *tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;

  {
  {
#line 45
  tmp___2 = ar_name(file->name);
  }
#line 45
  if (tmp___2) {
    {
#line 48
    p = strchr((char const   *)file->name, '(');
#line 49
    tmp = __builtin_alloca((unsigned long )((p - file->name) + 1L));
#line 49
    at = (char *)tmp;
#line 50
    memmove((void *)at, (void const   *)file->name, (size_t )(p - file->name));
#line 51
    *(at + (p - file->name)) = (char )'\000';
#line 52
    tmp___0 = strlen((char const   *)(p + 1));
#line 52
    len = (unsigned int )tmp___0;
#line 53
    tmp___1 = __builtin_alloca((unsigned long )len);
#line 53
    percent = (char *)tmp___1;
#line 54
    memmove((void *)percent, (void const   *)(p + 1), (size_t )(len - 1U));
#line 55
    *(percent + (len - 1U)) = (char )'\000';
    }
  } else {
#line 60
    at = file->name;
#line 61
    percent = (char *)"";
  }
#line 65
  if ((unsigned long )file->stem == (unsigned long )((char *)0)) {
    {
#line 75
    tmp___6 = ar_name(file->name);
    }
#line 75
    if (tmp___6) {
      {
#line 77
      tmp___3 = strchr((char const   *)file->name, '(');
#line 77
      name___0 = tmp___3 + 1;
#line 78
      tmp___4 = strlen((char const   *)name___0);
#line 78
      len___0 = (unsigned int )(tmp___4 - 1UL);
      }
    } else {
      {
#line 83
      name___0 = file->name;
#line 84
      tmp___5 = strlen((char const   *)name___0);
#line 84
      len___0 = (unsigned int )tmp___5;
      }
    }
    {
#line 87
    tmp___7 = enter_file(".SUFFIXES");
#line 87
    d = tmp___7->deps;
    }
    {
#line 87
    while (1) {
      while_continue: /* CIL Label */ ;
#line 87
      if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 87
        goto while_break;
      }
#line 89
      if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 89
        tmp___8 = (d->file)->name;
      } else {
#line 89
        tmp___8 = d->name;
      }
      {
#line 89
      tmp___9 = strlen((char const   *)tmp___8);
#line 89
      slen = (unsigned int )tmp___9;
      }
#line 90
      if (len___0 > slen) {
#line 90
        if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 90
          tmp___10 = (d->file)->name;
        } else {
#line 90
          tmp___10 = d->name;
        }
        {
#line 90
        tmp___11 = strncmp((char const   *)tmp___10, (char const   *)(name___0 + (len___0 - slen)),
                           (size_t )slen);
        }
#line 90
        if (! tmp___11) {
          {
#line 92
          file->stem = savestring(name___0, len___0 - slen);
          }
#line 93
          goto while_break;
        }
      }
#line 87
      d = d->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 96
    if ((unsigned long )d == (unsigned long )((struct dep *)0)) {
#line 97
      file->stem = (char *)"";
    }
  }
#line 99
  star = file->stem;
#line 102
  if ((unsigned long )file->deps != (unsigned long )((struct dep *)0)) {
#line 102
    if ((unsigned long )(file->deps)->name == (unsigned long )((char *)0)) {
#line 102
      tmp___12 = ((file->deps)->file)->name;
    } else {
#line 102
      tmp___12 = (file->deps)->name;
    }
#line 102
    less = tmp___12;
  } else {
#line 102
    less = (char *)"";
  }
#line 104
  if ((unsigned long )file->cmds == (unsigned long )default_file->cmds) {
#line 107
    less = at;
  }
  {
#line 114
  define_variable_for_file((char *)"<", 1U, less, (enum variable_origin )6, 0, file);
#line 115
  define_variable_for_file((char *)"*", 1U, star, (enum variable_origin )6, 0, file);
#line 116
  define_variable_for_file((char *)"@", 1U, at, (enum variable_origin )6, 0, file);
#line 117
  define_variable_for_file((char *)"%", 1U, percent, (enum variable_origin )6, 0,
                           file);
#line 133
  plus_len = 0U;
#line 134
  d___0 = file->deps;
  }
  {
#line 134
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 134
    if (! ((unsigned long )d___0 != (unsigned long )((struct dep *)0))) {
#line 134
      goto while_break___0;
    }
#line 135
    if ((unsigned long )d___0->name == (unsigned long )((char *)0)) {
#line 135
      tmp___13 = (d___0->file)->name;
    } else {
#line 135
      tmp___13 = d___0->name;
    }
    {
#line 135
    tmp___14 = strlen((char const   *)tmp___13);
#line 135
    plus_len = (unsigned int )((size_t )plus_len + (tmp___14 + 1UL));
#line 134
    d___0 = d___0->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 137
  if (plus_len == 0U) {
#line 137
    len___1 = 1U;
  } else {
#line 137
    len___1 = plus_len;
  }
  {
#line 138
  tmp___15 = __builtin_alloca((unsigned long )len___1);
#line 138
  plus_value = (char *)tmp___15;
#line 138
  cp = plus_value;
#line 140
  qmark_len = plus_len;
#line 141
  d___0 = file->deps;
  }
  {
#line 141
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 141
    if (! ((unsigned long )d___0 != (unsigned long )((struct dep *)0))) {
#line 141
      goto while_break___1;
    }
#line 143
    if ((unsigned long )d___0->name == (unsigned long )((char *)0)) {
#line 143
      tmp___16 = (d___0->file)->name;
    } else {
#line 143
      tmp___16 = d___0->name;
    }
    {
#line 143
    c = tmp___16;
#line 146
    tmp___20 = ar_name(c);
    }
#line 146
    if (tmp___20) {
      {
#line 148
      tmp___17 = strchr((char const   *)c, '(');
#line 148
      c = tmp___17 + 1;
#line 149
      tmp___18 = strlen((char const   *)c);
#line 149
      len___1 = (unsigned int )(tmp___18 - 1UL);
      }
    } else {
      {
#line 153
      tmp___19 = strlen((char const   *)c);
#line 153
      len___1 = (unsigned int )tmp___19;
      }
    }
    {
#line 155
    memmove((void *)cp, (void const   *)c, (size_t )len___1);
#line 156
    cp += len___1;
#line 160
    tmp___21 = cp;
#line 160
    cp ++;
#line 160
    *tmp___21 = (char )' ';
    }
#line 162
    if (! d___0->changed) {
#line 163
      qmark_len -= len___1 + 1U;
    }
#line 141
    d___0 = d___0->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 168
  if ((unsigned long )cp > (unsigned long )plus_value) {
#line 168
    tmp___22 = -1;
  } else {
#line 168
    tmp___22 = 0;
  }
  {
#line 168
  *(cp + tmp___22) = (char )'\000';
#line 169
  define_variable_for_file((char *)"+", 1U, plus_value, (enum variable_origin )6,
                           0, file);
#line 175
  uniquize_deps(file->deps);
#line 179
  caret_value = plus_value;
#line 179
  cp = caret_value;
  }
#line 180
  if (qmark_len == 0U) {
#line 180
    len___1 = 1U;
  } else {
#line 180
    len___1 = qmark_len;
  }
  {
#line 181
  tmp___23 = __builtin_alloca((unsigned long )len___1);
#line 181
  qmark_value = (char *)tmp___23;
#line 181
  qp = qmark_value;
#line 183
  d___0 = file->deps;
  }
  {
#line 183
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 183
    if (! ((unsigned long )d___0 != (unsigned long )((struct dep *)0))) {
#line 183
      goto while_break___2;
    }
#line 185
    if ((unsigned long )d___0->name == (unsigned long )((char *)0)) {
#line 185
      tmp___24 = (d___0->file)->name;
    } else {
#line 185
      tmp___24 = d___0->name;
    }
    {
#line 185
    c___0 = tmp___24;
#line 188
    tmp___28 = ar_name(c___0);
    }
#line 188
    if (tmp___28) {
      {
#line 190
      tmp___25 = strchr((char const   *)c___0, '(');
#line 190
      c___0 = tmp___25 + 1;
#line 191
      tmp___26 = strlen((char const   *)c___0);
#line 191
      len___1 = (unsigned int )(tmp___26 - 1UL);
      }
    } else {
      {
#line 195
      tmp___27 = strlen((char const   *)c___0);
#line 195
      len___1 = (unsigned int )tmp___27;
      }
    }
    {
#line 197
    memmove((void *)cp, (void const   *)c___0, (size_t )len___1);
#line 198
    cp += len___1;
#line 202
    tmp___29 = cp;
#line 202
    cp ++;
#line 202
    *tmp___29 = (char )' ';
    }
#line 204
    if (d___0->changed) {
      {
#line 206
      memmove((void *)qp, (void const   *)c___0, (size_t )len___1);
#line 207
      qp += len___1;
#line 211
      tmp___30 = qp;
#line 211
      qp ++;
#line 211
      *tmp___30 = (char )' ';
      }
    }
#line 183
    d___0 = d___0->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 218
  if ((unsigned long )cp > (unsigned long )caret_value) {
#line 218
    tmp___31 = -1;
  } else {
#line 218
    tmp___31 = 0;
  }
  {
#line 218
  *(cp + tmp___31) = (char )'\000';
#line 219
  define_variable_for_file((char *)"^", 1U, caret_value, (enum variable_origin )6,
                           0, file);
  }
#line 221
  if ((unsigned long )qp > (unsigned long )qmark_value) {
#line 221
    tmp___32 = -1;
  } else {
#line 221
    tmp___32 = 0;
  }
  {
#line 221
  *(qp + tmp___32) = (char )'\000';
#line 222
  define_variable_for_file((char *)"?", 1U, qmark_value, (enum variable_origin )6,
                           0, file);
  }
#line 226
  return;
}
}
#line 231 "/home/khheo/testset/make-3.76.1/commands.c"
void chop_commands(struct commands *cmds ) 
{ 
  register char *p ;
  unsigned int nlines ;
  unsigned int idx ;
  char **lines ;
  char *tmp ;
  char *end ;
  size_t tmp___0 ;
  int backslash ;
  register char *b ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int flags ;
  unsigned short const   **tmp___5 ;
  unsigned int len ;
  size_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 235
  if ((unsigned long )cmds != (unsigned long )((struct commands *)0)) {
#line 235
    if ((unsigned long )cmds->command_lines == (unsigned long )((char **)0)) {
      {
#line 244
      nlines = 5U;
#line 245
      tmp = xmalloc(5UL * sizeof(char *));
#line 245
      lines = (char **)tmp;
#line 246
      idx = 0U;
#line 247
      p = cmds->commands;
      }
      {
#line 248
      while (1) {
        while_continue: /* CIL Label */ ;
#line 248
        if (! ((int )*p != 0)) {
#line 248
          goto while_break;
        }
#line 250
        end = p;
        find_end: 
        {
#line 252
        end = strchr((char const   *)end, '\n');
        }
#line 253
        if ((unsigned long )end == (unsigned long )((char *)0)) {
          {
#line 254
          tmp___0 = strlen((char const   *)p);
#line 254
          end = p + tmp___0;
          }
        } else
#line 255
        if ((unsigned long )end > (unsigned long )p) {
#line 255
          if ((int )*(end + -1) == 92) {
#line 257
            backslash = 1;
#line 259
            b = end - 2;
            {
#line 259
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 259
              if ((unsigned long )b >= (unsigned long )p) {
#line 259
                if (! ((int )*b == 92)) {
#line 259
                  goto while_break___0;
                }
              } else {
#line 259
                goto while_break___0;
              }
#line 260
              backslash = ! backslash;
#line 259
              b --;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 261
            if (backslash) {
#line 263
              end ++;
#line 264
              goto find_end;
            }
          }
        }
#line 268
        if (idx == nlines) {
          {
#line 270
          nlines += 2U;
#line 271
          tmp___1 = xrealloc((char *)lines, (unsigned long )nlines * sizeof(char *));
#line 271
          lines = (char **)tmp___1;
          }
        }
        {
#line 274
        tmp___2 = idx;
#line 274
        idx ++;
#line 274
        *(lines + tmp___2) = savestring(p, end - p);
#line 275
        p = end;
        }
#line 276
        if ((int )*p != 0) {
#line 277
          p ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 280
      if (idx != nlines) {
        {
#line 282
        nlines = idx;
#line 283
        tmp___3 = xrealloc((char *)lines, (unsigned long )nlines * sizeof(char *));
#line 283
        lines = (char **)tmp___3;
        }
      }
      {
#line 287
      cmds->ncommand_lines = nlines;
#line 288
      cmds->command_lines = lines;
#line 290
      cmds->any_recurse = 0;
#line 291
      tmp___4 = xmalloc(nlines);
#line 291
      cmds->lines_flags = tmp___4;
#line 292
      idx = 0U;
      }
      {
#line 292
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 292
        if (! (idx < nlines)) {
#line 292
          goto while_break___1;
        }
#line 294
        flags = 0;
#line 296
        p = *(lines + idx);
        {
#line 296
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 296
          tmp___5 = __ctype_b_loc();
          }
#line 296
          if (! ((int const   )*(*tmp___5 + (int )*p) & 1)) {
#line 296
            if (! ((int )*p == 45)) {
#line 296
              if (! ((int )*p == 64)) {
#line 296
                if (! ((int )*p == 43)) {
#line 296
                  goto while_break___2;
                }
              }
            }
          }
          {
#line 301
          if ((int )*p == 43) {
#line 301
            goto case_43;
          }
#line 304
          if ((int )*p == 64) {
#line 304
            goto case_64;
          }
#line 307
          if ((int )*p == 45) {
#line 307
            goto case_45;
          }
#line 299
          goto switch_break;
          case_43: /* CIL Label */ 
#line 302
          flags |= 1;
#line 303
          goto switch_break;
          case_64: /* CIL Label */ 
#line 305
          flags |= 2;
#line 306
          goto switch_break;
          case_45: /* CIL Label */ 
#line 308
          flags |= 4;
#line 309
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 296
          p ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 311
        if (! (flags & 1)) {
          {
#line 313
          tmp___6 = strlen((char const   *)p);
#line 313
          len = (unsigned int )tmp___6;
#line 314
          tmp___7 = sindex(p, len, "$(MAKE)", 7);
          }
#line 314
          if ((unsigned long )tmp___7 != (unsigned long )((char *)0)) {
#line 316
            flags |= 1;
          } else {
            {
#line 314
            tmp___8 = sindex(p, len, "${MAKE}", 7);
            }
#line 314
            if ((unsigned long )tmp___8 != (unsigned long )((char *)0)) {
#line 316
              flags |= 1;
            }
          }
        }
#line 319
        *(cmds->lines_flags + idx) = (char )flags;
#line 320
        cmds->any_recurse |= flags & 1;
#line 292
        idx ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 323
  return;
}
}
#line 329 "/home/khheo/testset/make-3.76.1/commands.c"
void execute_file_commands(struct file *file ) 
{ 
  register char *p ;
  unsigned short const   **tmp ;

  {
#line 338
  p = (file->cmds)->commands;
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (! ((int )*p != 0)) {
#line 338
      goto while_break;
    }
    {
#line 339
    tmp = __ctype_b_loc();
    }
#line 339
    if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 339
      if ((int )*p != 45) {
#line 339
        if ((int )*p != 64) {
#line 340
          goto while_break;
        }
      }
    }
#line 338
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 341
  if ((int )*p == 0) {
    {
#line 346
    file->update_status = (short)0;
#line 347
    notice_finished_file(file);
    }
#line 348
    return;
  }
  {
#line 353
  initialize_file_variables(file);
#line 355
  set_file_variables(file);
#line 358
  new_job(file);
  }
#line 359
  return;
}
}
#line 364 "/home/khheo/testset/make-3.76.1/commands.c"
int handling_fatal_signal  =    0;
#line 368 "/home/khheo/testset/make-3.76.1/commands.c"
void fatal_error_signal(int sig ) 
{ 
  register struct child *c ;
  register struct child *c___0 ;
  __pid_t tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 391
  handling_fatal_signal = 1;
#line 395
  signal(sig, (void (*)(int  ))0);
  }
#line 400
  if (sig == 15) {
#line 403
    c = children;
    {
#line 403
    while (1) {
      while_continue: /* CIL Label */ ;
#line 403
      if (! ((unsigned long )c != (unsigned long )((struct child *)0))) {
#line 403
        goto while_break;
      }
#line 404
      if (! c->remote) {
        {
#line 405
        kill(c->pid, 15);
        }
      }
#line 403
      c = c->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 411
  if (sig == 15) {
#line 411
    goto _L;
  } else
#line 411
  if (sig == 2) {
#line 411
    goto _L;
  } else
#line 411
  if (sig == 1) {
#line 411
    goto _L;
  } else
#line 411
  if (sig == 3) {
    _L: /* CIL Label */ 
#line 424
    c___0 = children;
    {
#line 424
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 424
      if (! ((unsigned long )c___0 != (unsigned long )((struct child *)0))) {
#line 424
        goto while_break___0;
      }
#line 425
      if (c___0->remote) {
        {
#line 426
        remote_kill(c___0->pid, sig);
        }
      }
#line 424
      c___0 = c___0->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 428
    c___0 = children;
    {
#line 428
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 428
      if (! ((unsigned long )c___0 != (unsigned long )((struct child *)0))) {
#line 428
        goto while_break___1;
      }
      {
#line 429
      delete_child_targets(c___0);
#line 428
      c___0 = c___0->next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 433
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 433
      if (! (job_slots_used > 0U)) {
#line 433
        goto while_break___2;
      }
      {
#line 434
      reap_children(1, 0);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 438
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 438
      if (! (job_slots_used > 0U)) {
#line 438
        goto while_break___3;
      }
      {
#line 439
      reap_children(1, 1);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 443
  remove_intermediates(1);
  }
#line 446
  if (sig == 3) {
    {
#line 449
    exit(1);
    }
  }
  {
#line 454
  tmp = getpid();
#line 454
  tmp___0 = kill(tmp, sig);
  }
#line 454
  if (tmp___0 < 0) {
    {
#line 455
    pfatal_with_name("kill");
    }
  }
#line 458
  return;
}
}
#line 463 "/home/khheo/testset/make-3.76.1/commands.c"
static void delete_target(struct file *file , char *on_behalf_of ) 
{ 
  struct stat st ;
  time_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 470
  if (file->precious) {
#line 471
    return;
  } else
#line 470
  if (file->phony) {
#line 471
    return;
  }
  {
#line 474
  tmp___0 = ar_name(file->name);
  }
#line 474
  if (tmp___0) {
    {
#line 476
    tmp = ar_member_date(file->name);
    }
#line 476
    if (tmp != file->last_mtime) {
#line 478
      if (on_behalf_of) {
        {
#line 479
        error("*** [%s] Archive member `%s\' may be bogus; not deleted", on_behalf_of,
              file->name);
        }
      } else {
        {
#line 482
        error("*** Archive member `%s\' may be bogus; not deleted", file->name);
        }
      }
    }
#line 485
    return;
  }
  {
#line 489
  tmp___3 = stat((char const   */* __restrict  */)file->name, (struct stat */* __restrict  */)(& st));
  }
#line 489
  if (tmp___3 == 0) {
#line 489
    if ((st.st_mode & 61440U) == 32768U) {
#line 489
      if (st.st_mtim.tv_sec != file->last_mtime) {
#line 493
        if (on_behalf_of) {
          {
#line 494
          error("*** [%s] Deleting file `%s\'", on_behalf_of, file->name);
          }
        } else {
          {
#line 496
          error("*** Deleting file `%s\'", file->name);
          }
        }
        {
#line 497
        tmp___1 = unlink((char const   *)file->name);
        }
#line 497
        if (tmp___1 < 0) {
          {
#line 497
          tmp___2 = __errno_location();
          }
#line 497
          if (*tmp___2 != 2) {
            {
#line 499
            perror_with_name("unlink: ", file->name);
            }
          }
        }
      }
    }
  }
#line 501
  return;
}
}
#line 507 "/home/khheo/testset/make-3.76.1/commands.c"
void delete_child_targets(struct child *child ) 
{ 
  struct dep *d ;

  {
#line 513
  if (child->deleted) {
#line 514
    return;
  }
  {
#line 517
  delete_target(child->file, (char *)0);
#line 520
  d = (child->file)->also_make;
  }
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 520
      goto while_break;
    }
    {
#line 521
    delete_target(d->file, (child->file)->name);
#line 520
    d = d->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 523
  child->deleted = 1U;
#line 524
  return;
}
}
#line 528 "/home/khheo/testset/make-3.76.1/commands.c"
void print_commands(struct commands *cmds ) 
{ 
  register char *s ;
  char *end ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 534
  fputs((char const   */* __restrict  */)"#  commands to execute", (FILE */* __restrict  */)stdout);
  }
#line 536
  if ((unsigned long )cmds->filename == (unsigned long )((char *)0)) {
    {
#line 537
    puts(" (built-in):");
    }
  } else {
    {
#line 539
    printf((char const   */* __restrict  */)" (from `%s\', line %u):\n", cmds->filename,
           cmds->lineno);
    }
  }
#line 541
  s = cmds->commands;
  {
#line 542
  while (1) {
    while_continue: /* CIL Label */ ;
#line 542
    if (! ((int )*s != 0)) {
#line 542
      goto while_break;
    }
    {
#line 546
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 546
      tmp = __ctype_b_loc();
      }
#line 546
      if (! ((int const   )*(*tmp + (int )*s) & 8192)) {
#line 546
        goto while_break___0;
      }
#line 547
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 549
    end = strchr((char const   *)s, '\n');
    }
#line 550
    if ((unsigned long )end == (unsigned long )((char *)0)) {
      {
#line 551
      tmp___0 = strlen((char const   *)s);
#line 551
      end = s + tmp___0;
      }
    }
    {
#line 553
    printf((char const   */* __restrict  */)"\t%.*s\n", (int )(end - s), s);
#line 555
    s = end;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 221 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 347
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setlinebuf)(FILE *__stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 35 "./getopt.h"
extern char *optarg ;
#line 49
extern int optind ;
#line 54
extern int opterr ;
#line 110
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 606
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) mktemp)(char *__template ) ;
#line 409 "/home/khheo/testset/make-3.76.1/make.h"
int just_print_flag  ;
#line 409 "/home/khheo/testset/make-3.76.1/make.h"
int silent_flag  ;
#line 409 "/home/khheo/testset/make-3.76.1/make.h"
int keep_going_flag  ;
#line 410
int print_data_base_flag ;
#line 410 "/home/khheo/testset/make-3.76.1/make.h"
int touch_flag  ;
#line 411
int print_version_flag ;
#line 412
int print_directory_flag ;
#line 412 "/home/khheo/testset/make-3.76.1/make.h"
int warn_undefined_variables_flag  ;
#line 413 "/home/khheo/testset/make-3.76.1/make.h"
int posix_pedantic  ;
#line 414 "/home/khheo/testset/make-3.76.1/make.h"
int clock_skew_detected  ;
#line 423 "/home/khheo/testset/make-3.76.1/make.h"
char *program  ;
#line 424 "/home/khheo/testset/make-3.76.1/make.h"
char *starting_directory  ;
#line 425 "/home/khheo/testset/make-3.76.1/make.h"
unsigned int makelevel  ;
#line 89 "/home/khheo/testset/make-3.76.1/filedef.h"
struct file *default_goal_file  ;
#line 89 "/home/khheo/testset/make-3.76.1/filedef.h"
struct file *default_file  ;
#line 63 "/home/khheo/testset/make-3.76.1/main.c"
static void print_data_base(void) ;
#line 64
static void print_version(void) ;
#line 65
static void decode_switches(int argc , char **argv , int env ) ;
#line 66
static void decode_env_switches(char *envar , unsigned int len ) ;
#line 67
static void define_makeflags(int all , int makefile ) ;
#line 68
static char *quote_as_word(char *out , char *in , int double_dollars ) ;
#line 130 "/home/khheo/testset/make-3.76.1/main.c"
int debug_flag  =    0;
#line 140 "/home/khheo/testset/make-3.76.1/main.c"
int env_overrides  =    0;
#line 145 "/home/khheo/testset/make-3.76.1/main.c"
int ignore_errors_flag  =    0;
#line 150 "/home/khheo/testset/make-3.76.1/main.c"
int print_data_base_flag  =    0;
#line 155 "/home/khheo/testset/make-3.76.1/main.c"
int question_flag  =    0;
#line 159 "/home/khheo/testset/make-3.76.1/main.c"
int no_builtin_rules_flag  =    0;
#line 164 "/home/khheo/testset/make-3.76.1/main.c"
int default_keep_going_flag  =    0;
#line 168 "/home/khheo/testset/make-3.76.1/main.c"
int print_directory_flag  =    0;
#line 173 "/home/khheo/testset/make-3.76.1/main.c"
int inhibit_print_directory_flag  =    0;
#line 177 "/home/khheo/testset/make-3.76.1/main.c"
int print_version_flag  =    0;
#line 181 "/home/khheo/testset/make-3.76.1/main.c"
static struct stringlist *makefiles  =    (struct stringlist *)0;
#line 186 "/home/khheo/testset/make-3.76.1/main.c"
unsigned int job_slots  =    1U;
#line 187 "/home/khheo/testset/make-3.76.1/main.c"
unsigned int default_job_slots  =    1U;
#line 191 "/home/khheo/testset/make-3.76.1/main.c"
static unsigned int inf_jobs  =    0U;
#line 198 "/home/khheo/testset/make-3.76.1/main.c"
double max_load_average  =    - 1.0;
#line 199 "/home/khheo/testset/make-3.76.1/main.c"
double default_load_average  =    - 1.0;
#line 207 "/home/khheo/testset/make-3.76.1/main.c"
static struct stringlist *directories___0  =    (struct stringlist *)0;
#line 211 "/home/khheo/testset/make-3.76.1/main.c"
static struct stringlist *include_directories___0  =    (struct stringlist *)0;
#line 215 "/home/khheo/testset/make-3.76.1/main.c"
static struct stringlist *old_files  =    (struct stringlist *)0;
#line 219 "/home/khheo/testset/make-3.76.1/main.c"
static struct stringlist *new_files  =    (struct stringlist *)0;
#line 223 "/home/khheo/testset/make-3.76.1/main.c"
static int print_usage_flag  =    0;
#line 232 "/home/khheo/testset/make-3.76.1/main.c"
static struct command_switch  const  switches[26]  = 
#line 232
  {      {(char )'b', (enum __anonenum_type_57 )5, (char *)0, 0U, 0U, 0U, (char *)0, (char *)0,
      (char *)0, (char *)0, (char *)"Ignored for compatibility"}, 
        {(char )'C', (enum __anonenum_type_57 )2, (char *)(& directories___0), 0U, 0U,
      0U, (char *)0, (char *)0, (char *)"directory", (char *)"DIRECTORY", (char *)"Change to DIRECTORY before doing anything"}, 
        {(char )'d',
      (enum __anonenum_type_57 )0, (char *)(& debug_flag), 1U, 1U, 0U, (char *)0,
      (char *)0, (char *)"debug", (char *)0, (char *)"Print lots of debugging information"}, 
        {(char )'e',
      (enum __anonenum_type_57 )0, (char *)(& env_overrides), 1U, 1U, 0U, (char *)0,
      (char *)0, (char *)"environment-overrides", (char *)0, (char *)"Environment variables override makefiles"}, 
        {(char )'f',
      (enum __anonenum_type_57 )2, (char *)(& makefiles), 0U, 0U, 0U, (char *)0, (char *)0,
      (char *)"file", (char *)"FILE", (char *)"Read FILE as a makefile"}, 
        {(char )'h', (enum __anonenum_type_57 )0, (char *)(& print_usage_flag), 0U, 0U,
      0U, (char *)0, (char *)0, (char *)"help", (char *)0, (char *)"Print this message and exit"}, 
        {(char )'i',
      (enum __anonenum_type_57 )0, (char *)(& ignore_errors_flag), 1U, 1U, 0U, (char *)0,
      (char *)0, (char *)"ignore-errors", (char *)0, (char *)"Ignore errors from commands"}, 
        {(char )'I',
      (enum __anonenum_type_57 )2, (char *)(& include_directories___0), 1U, 1U, 0U,
      (char *)0, (char *)0, (char *)"include-dir", (char *)"DIRECTORY", (char *)"Search DIRECTORY for included makefiles"}, 
        {(char )'j',
      (enum __anonenum_type_57 )3, (char *)(& job_slots), 1U, 1U, 0U, (char *)(& inf_jobs),
      (char *)(& default_job_slots), (char *)"jobs", (char *)"N", (char *)"Allow N jobs at once; infinite jobs with no arg"}, 
        {(char )'k',
      (enum __anonenum_type_57 )0, (char *)(& keep_going_flag), 1U, 1U, 0U, (char *)0,
      (char *)(& default_keep_going_flag), (char *)"keep-going", (char *)0, (char *)"Keep going when some targets can\'t be made"}, 
        {(char )'l',
      (enum __anonenum_type_57 )4, (char *)(& max_load_average), 1U, 1U, 0U, (char *)(& default_load_average),
      (char *)(& default_load_average), (char *)"load-average", (char *)"N", (char *)"Don\'t start multiple jobs unless load is below N"}, 
        {(char )'m',
      (enum __anonenum_type_57 )5, (char *)0, 0U, 0U, 0U, (char *)0, (char *)0, (char *)0,
      (char *)0, (char *)"-b"}, 
        {(char )'n', (enum __anonenum_type_57 )0, (char *)(& just_print_flag), 1U, 1U,
      1U, (char *)0, (char *)0, (char *)"just-print", (char *)0, (char *)"Don\'t actually run any commands; just print them"}, 
        {(char )'o',
      (enum __anonenum_type_57 )2, (char *)(& old_files), 0U, 0U, 0U, (char *)0, (char *)0,
      (char *)"old-file", (char *)"FILE", (char *)"Consider FILE to be very old and don\'t remake it"}, 
        {(char )'p',
      (enum __anonenum_type_57 )0, (char *)(& print_data_base_flag), 1U, 1U, 0U, (char *)0,
      (char *)0, (char *)"print-data-base", (char *)0, (char *)"Print make\'s internal database"}, 
        {(char )'q',
      (enum __anonenum_type_57 )0, (char *)(& question_flag), 1U, 1U, 1U, (char *)0,
      (char *)0, (char *)"question", (char *)0, (char *)"Run no commands; exit status says if up to date"}, 
        {(char )'r',
      (enum __anonenum_type_57 )0, (char *)(& no_builtin_rules_flag), 1U, 1U, 0U,
      (char *)0, (char *)0, (char *)"no-builtin-rules", (char *)0, (char *)"Disable the built-in implicit rules"}, 
        {(char )'s',
      (enum __anonenum_type_57 )0, (char *)(& silent_flag), 1U, 1U, 0U, (char *)0,
      (char *)0, (char *)"silent", (char *)0, (char *)"Don\'t echo commands"}, 
        {(char )'S', (enum __anonenum_type_57 )1, (char *)(& keep_going_flag), 1U, 1U,
      0U, (char *)0, (char *)(& default_keep_going_flag), (char *)"no-keep-going",
      (char *)0, (char *)"Turns off -k"}, 
        {(char )'t', (enum __anonenum_type_57 )0, (char *)(& touch_flag), 1U, 1U, 1U,
      (char *)0, (char *)0, (char *)"touch", (char *)0, (char *)"Touch targets instead of remaking them"}, 
        {(char )'v',
      (enum __anonenum_type_57 )0, (char *)(& print_version_flag), 1U, 1U, 0U, (char *)0,
      (char *)0, (char *)"version", (char *)0, (char *)"Print the version number of make and exit"}, 
        {(char )'w',
      (enum __anonenum_type_57 )0, (char *)(& print_directory_flag), 1U, 1U, 0U, (char *)0,
      (char *)0, (char *)"print-directory", (char *)0, (char *)"Print the current directory"}, 
        {(char)2,
      (enum __anonenum_type_57 )0, (char *)(& inhibit_print_directory_flag), 1U, 1U,
      0U, (char *)0, (char *)0, (char *)"no-print-directory", (char *)0, (char *)"Turn off -w, even if it was turned on implicitly"}, 
        {(char )'W',
      (enum __anonenum_type_57 )2, (char *)(& new_files), 0U, 0U, 0U, (char *)0, (char *)0,
      (char *)"what-if", (char *)"FILE", (char *)"Consider FILE to be infinitely new"}, 
        {(char)3,
      (enum __anonenum_type_57 )0, (char *)(& warn_undefined_variables_flag), 1U,
      1U, 0U, (char *)0, (char *)0, (char *)"warn-undefined-variables", (char *)0,
      (char *)"Warn when an undefined variable is referenced"}, 
        {(char )'\000', 0U, (char *)0, 0U, 0U, 0U, (char *)0, (char *)0, (char *)0, (char *)0,
      (char *)0}};
#line 330 "/home/khheo/testset/make-3.76.1/main.c"
static struct option long_option_aliases[9]  = 
#line 330
  {      {"quiet", 0, (int *)0, 's'}, 
        {"stop", 0, (int *)0, 'S'}, 
        {"new-file", 1, (int *)0, 'W'}, 
        {"assume-new", 1, (int *)0, 'W'}, 
        {"assume-old", 1, (int *)0, 'o'}, 
        {"max-load", 2, (int *)0, 'l'}, 
        {"dry-run", 0, (int *)0, 'n'}, 
        {"recon", 0, (int *)0, 'n'}, 
        {"makefile", 1, (int *)0, 'f'}};
#line 351 "/home/khheo/testset/make-3.76.1/main.c"
static struct dep *goals  ;
#line 351 "/home/khheo/testset/make-3.76.1/main.c"
static struct dep *lastgoal  ;
#line 361 "/home/khheo/testset/make-3.76.1/main.c"
static struct command_variable *command_variables  ;
#line 369 "/home/khheo/testset/make-3.76.1/main.c"
char *directory_before_chdir  ;
#line 405 "/home/khheo/testset/make-3.76.1/main.c"
sigset_t fatal_signal_set  ;
#line 412 "/home/khheo/testset/make-3.76.1/main.c"
static struct file *enter_command_line_file(char *name___0 ) 
{ 
  char *expanded ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  struct file *tmp___2 ;
  char *__cil_tmp7 ;

  {
#line 416
  if ((int )*(name___0 + 0) == 0) {
    {
#line 417
    fatal("empty string invalid as file name");
    }
  }
#line 419
  if ((int )*(name___0 + 0) == 126) {
    {
#line 421
    tmp = tilde_expand(name___0);
#line 421
    expanded = tmp;
    }
#line 422
    if ((unsigned long )expanded != (unsigned long )((char *)0)) {
#line 423
      name___0 = expanded;
    }
  }
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 429
    if ((int )*(name___0 + 0) == 46) {
#line 429
      if ((int )*(name___0 + 1) == 47) {
#line 429
        if (! ((int )*(name___0 + 2) != 0)) {
#line 429
          goto while_break;
        }
      } else {
#line 429
        goto while_break;
      }
    } else {
#line 429
      goto while_break;
    }
#line 431
    name___0 += 2;
    {
#line 432
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 432
      if (! ((int )*name___0 == 47)) {
#line 432
        goto while_break___0;
      }
#line 434
      name___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 437
  if ((int )*name___0 == 0) {
    {
#line 441
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 442
      name___0 --;
#line 441
      if (! ((int )*(name___0 + 0) != 46)) {
#line 441
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 444
    *(name___0 + 2) = (char )'\000';
  }
  {
#line 447
  tmp___0 = strlen((char const   *)name___0);
#line 447
  tmp___1 = savestring(name___0, tmp___0);
#line 447
  tmp___2 = enter_file(tmp___1);
  }
#line 447
  return (tmp___2);
}
}
#line 452 "/home/khheo/testset/make-3.76.1/main.c"
static void debug_signal_handler(int sig ) 
{ 


  {
#line 456
  debug_flag = ! debug_flag;
#line 457
  return;
}
}
#line 1029
int main(int argc , char **argv , char **envp ) ;
#line 1029 "/home/khheo/testset/make-3.76.1/main.c"
static char name[14]  = 
#line 1029
  {      (char )'/',      (char )'t',      (char )'m',      (char )'p', 
        (char )'/',      (char )'G',      (char )'m',      (char )'X', 
        (char )'X',      (char )'X',      (char )'X',      (char )'X', 
        (char )'X',      (char )'\000'};
#line 550 "/home/khheo/testset/make-3.76.1/main.c"
int main(int argc , char **argv , char **envp ) 
{ 
  register struct file *f ;
  register unsigned int i ;
  char **p ;
  struct dep *read_makefiles___0 ;
  char current_directory[4096] ;
  __sighandler_t tmp ;
  __sighandler_t tmp___0 ;
  __sighandler_t tmp___1 ;
  __sighandler_t tmp___2 ;
  __sighandler_t tmp___3 ;
  __sighandler_t tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  register char *ep ;
  struct variable *tmp___7 ;
  char *tmp___8 ;
  struct command_variable *cv ;
  struct variable *v ;
  unsigned int len ;
  char *value ;
  char *p___0 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *dir ;
  char *expanded ;
  char *tmp___15 ;
  int tmp___16 ;
  struct variable *v___0 ;
  struct variable *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  register unsigned int i___0 ;
  FILE *outfile ;
  char buf___0[2048] ;
  unsigned int n ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  int tmp___23 ;
  char *temp ;
  void *tmp___24 ;
  char *tmp___25 ;
  char **tmp___26 ;
  time_t *makefile_mtimes ;
  unsigned int mm_idx ;
  char **nargv ;
  int nargc ;
  register struct dep *d ;
  register struct dep *last ;
  register struct file *f___0 ;
  char *tmp___27 ;
  char *tmp___28 ;
  unsigned int tmp___29 ;
  time_t tmp___30 ;
  int tmp___31 ;
  int any_remade ;
  int any_failed ;
  register unsigned int i___1 ;
  struct dep *d___0 ;
  time_t tmp___32 ;
  time_t tmp___33 ;
  time_t mtime ;
  time_t tmp___34 ;
  int tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  register unsigned int i___2 ;
  register unsigned int j ;
  char *p___1 ;
  int tmp___38 ;
  register unsigned int i___3 ;
  struct dep *d___1 ;
  char *tmp___39 ;
  int tmp___40 ;
  char *tmp___41 ;
  char bad ;
  int tmp___42 ;
  char *sgi_loses ;
  void *tmp___43 ;
  int tmp___44 ;
  char **p___2 ;
  int status ;
  char *tmp___45 ;
  int tmp___46 ;
  void *__cil_tmp92 ;
  void *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;

  {
  {
#line 572
  default_goal_file = (struct file *)0;
#line 573
  reading_filename = (char *)0;
#line 574
  reading_lineno_ptr = (unsigned int *)0;
#line 593
  sigemptyset(& fatal_signal_set);
#line 611
  tmp = signal(1, & fatal_error_signal);
  }
#line 611
  if ((unsigned long )tmp == (unsigned long )((void (*)(int  ))1)) {
    {
#line 611
    signal(1, (void (*)(int  ))1);
    }
  } else {
    {
#line 611
    sigaddset(& fatal_signal_set, 1);
    }
  }
  {
#line 614
  tmp___0 = signal(3, & fatal_error_signal);
  }
#line 614
  if ((unsigned long )tmp___0 == (unsigned long )((void (*)(int  ))1)) {
    {
#line 614
    signal(3, (void (*)(int  ))1);
    }
  } else {
    {
#line 614
    sigaddset(& fatal_signal_set, 3);
    }
  }
  {
#line 616
  tmp___1 = signal(2, & fatal_error_signal);
  }
#line 616
  if ((unsigned long )tmp___1 == (unsigned long )((void (*)(int  ))1)) {
    {
#line 616
    signal(2, (void (*)(int  ))1);
    }
  } else {
    {
#line 616
    sigaddset(& fatal_signal_set, 2);
    }
  }
  {
#line 617
  tmp___2 = signal(15, & fatal_error_signal);
  }
#line 617
  if ((unsigned long )tmp___2 == (unsigned long )((void (*)(int  ))1)) {
    {
#line 617
    signal(15, (void (*)(int  ))1);
    }
  } else {
    {
#line 617
    sigaddset(& fatal_signal_set, 15);
    }
  }
  {
#line 623
  tmp___3 = signal(24, & fatal_error_signal);
  }
#line 623
  if ((unsigned long )tmp___3 == (unsigned long )((void (*)(int  ))1)) {
    {
#line 623
    signal(24, (void (*)(int  ))1);
    }
  } else {
    {
#line 623
    sigaddset(& fatal_signal_set, 24);
    }
  }
  {
#line 626
  tmp___4 = signal(25, & fatal_error_signal);
  }
#line 626
  if ((unsigned long )tmp___4 == (unsigned long )((void (*)(int  ))1)) {
    {
#line 626
    signal(25, (void (*)(int  ))1);
    }
  } else {
    {
#line 626
    sigaddset(& fatal_signal_set, 25);
    }
  }
  {
#line 634
  setlinebuf(stdout);
  }
#line 646
  if ((unsigned long )*(argv + 0) == (unsigned long )((char *)0)) {
#line 647
    *(argv + 0) = (char *)"";
  }
#line 648
  if ((int )*(*(argv + 0) + 0) == 0) {
#line 649
    program = (char *)"make";
  } else {
    {
#line 655
    program = strrchr((char const   *)*(argv + 0), '/');
    }
#line 671
    if ((unsigned long )program == (unsigned long )((char *)0)) {
#line 672
      program = *(argv + 0);
    } else {
#line 674
      program ++;
    }
  }
  {
#line 678
  user_access();
#line 685
  tmp___6 = getcwd(current_directory, (size_t )4096);
  }
#line 685
  if ((unsigned long )tmp___6 == (unsigned long )((char *)0)) {
    {
#line 689
    perror_with_name("getcwd: ", "");
#line 693
    current_directory[0] = (char )'\000';
#line 694
    directory_before_chdir = (char *)0;
    }
  } else {
    {
#line 697
    tmp___5 = strlen((char const   *)(current_directory));
#line 697
    directory_before_chdir = savestring(current_directory, tmp___5);
    }
  }
#line 709
  i = 0U;
  {
#line 709
  while (1) {
    while_continue: /* CIL Label */ ;
#line 709
    if (! ((unsigned long )*(envp + i) != (unsigned long )((char *)0))) {
#line 709
      goto while_break;
    }
#line 711
    ep = *(envp + i);
    {
#line 712
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 712
      if (! ((int )*ep != 61)) {
#line 712
        goto while_break___0;
      }
#line 713
      ep ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 723
    tmp___7 = define_variable(*(envp + i), (unsigned int )(ep - *(envp + i)), ep + 1,
                              (enum variable_origin )1, 1);
#line 723
    tmp___7->export = (enum __anonenum_export_56 )0;
#line 709
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 772
  decode_env_switches((char *)"MAKEFLAGS", 9U);
#line 779
  decode_switches(argc, argv, 0);
  }
#line 791
  if (print_version_flag) {
    {
#line 792
    print_version();
    }
  } else
#line 791
  if (print_data_base_flag) {
    {
#line 792
    print_version();
    }
  } else
#line 791
  if (debug_flag) {
    {
#line 792
    print_version();
    }
  }
#line 795
  if (print_version_flag) {
    {
#line 796
    die(0);
    }
  }
#line 816
  if ((int )current_directory[0] != 0) {
#line 816
    if ((unsigned long )*(argv + 0) != (unsigned long )((char *)0)) {
#line 816
      if ((int )*(*(argv + 0) + 0) != 47) {
        {
#line 816
        tmp___8 = strchr((char const   *)*(argv + 0), '/');
        }
#line 816
        if ((unsigned long )tmp___8 != (unsigned long )((char *)0)) {
          {
#line 818
          *(argv + 0) = concat(current_directory, "/", *(argv + 0));
          }
        }
      }
    }
  }
  {
#line 824
  define_variable((char *)"MAKE_COMMAND", 12U, *(argv + 0), (enum variable_origin )0,
                  0);
#line 825
  define_variable((char *)"MAKE", 4U, (char *)"$(MAKE_COMMAND)", (enum variable_origin )0,
                  1);
  }
#line 827
  if ((unsigned long )command_variables != (unsigned long )((struct command_variable *)0)) {
#line 831
    len = 0U;
#line 836
    cv = command_variables;
    {
#line 836
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 836
      if (! ((unsigned long )cv != (unsigned long )((struct command_variable *)0))) {
#line 836
        goto while_break___1;
      }
      {
#line 838
      v = cv->variable;
#line 839
      tmp___9 = strlen((char const   *)v->name);
#line 839
      len = (unsigned int )((size_t )len + 2UL * tmp___9);
      }
#line 840
      if (! v->recursive) {
#line 841
        len ++;
      }
      {
#line 842
      len ++;
#line 843
      tmp___10 = strlen((char const   *)v->value);
#line 843
      len = (unsigned int )((size_t )len + 2UL * tmp___10);
#line 836
      cv = cv->next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 847
    tmp___11 = __builtin_alloca((unsigned long )len);
#line 847
    value = (char *)tmp___11;
#line 847
    p___0 = value;
#line 848
    cv = command_variables;
    }
    {
#line 848
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 848
      if (! ((unsigned long )cv != (unsigned long )((struct command_variable *)0))) {
#line 848
        goto while_break___2;
      }
      {
#line 850
      v = cv->variable;
#line 851
      p___0 = quote_as_word(p___0, v->name, 0);
      }
#line 852
      if (! v->recursive) {
#line 853
        tmp___12 = p___0;
#line 853
        p___0 ++;
#line 853
        *tmp___12 = (char )':';
      }
      {
#line 854
      tmp___13 = p___0;
#line 854
      p___0 ++;
#line 854
      *tmp___13 = (char )'=';
#line 855
      p___0 = quote_as_word(p___0, v->value, 0);
#line 856
      tmp___14 = p___0;
#line 856
      p___0 ++;
#line 856
      *tmp___14 = (char )' ';
#line 848
      cv = cv->next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 858
    *(p___0 + -1) = (char )'\000';
#line 862
    define_variable((char *)"-*-command-variables-*-", 23U, value, (enum variable_origin )6,
                    0);
#line 871
    define_variable((char *)"MAKEOVERRIDES", 13U, (char *)"${-*-command-variables-*-}",
                    (enum variable_origin )1, 1);
    }
  }
#line 876
  if ((unsigned long )directories___0 != (unsigned long )((struct stringlist *)0)) {
#line 877
    i = 0U;
    {
#line 877
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 877
      if (! ((unsigned long )*(directories___0->list + i) != (unsigned long )((char *)0))) {
#line 877
        goto while_break___3;
      }
#line 879
      dir = *(directories___0->list + i);
#line 880
      if ((int )*(dir + 0) == 126) {
        {
#line 882
        tmp___15 = tilde_expand(dir);
#line 882
        expanded = tmp___15;
        }
#line 883
        if ((unsigned long )expanded != (unsigned long )((char *)0)) {
#line 884
          dir = expanded;
        }
      }
      {
#line 886
      tmp___16 = chdir((char const   *)dir);
      }
#line 886
      if (tmp___16 < 0) {
        {
#line 887
        pfatal_with_name(dir);
        }
      }
#line 888
      if ((unsigned long )dir != (unsigned long )*(directories___0->list + i)) {
        {
#line 889
        free((void *)dir);
        }
      }
#line 877
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 967
  tmp___17 = lookup_variable((char *)"MAKELEVEL", 9U);
#line 967
  v___0 = tmp___17;
  }
#line 968
  if ((unsigned long )v___0 != (unsigned long )((struct variable *)0)) {
#line 968
    if ((int )*(v___0->value) != 0) {
#line 968
      if ((int )*(v___0->value) != 45) {
        {
#line 969
        tmp___18 = atoi((char const   *)v___0->value);
#line 969
        makelevel = (unsigned int )tmp___18;
        }
      } else {
#line 971
        makelevel = 0U;
      }
    } else {
#line 971
      makelevel = 0U;
    }
  } else {
#line 971
    makelevel = 0U;
  }
#line 975
  if (! silent_flag) {
#line 975
    if ((unsigned long )directories___0 != (unsigned long )((struct stringlist *)0)) {
#line 976
      print_directory_flag = 1;
    } else
#line 975
    if (makelevel > 0U) {
#line 976
      print_directory_flag = 1;
    }
  }
#line 979
  if (inhibit_print_directory_flag) {
#line 980
    print_directory_flag = 0;
  }
#line 984
  if ((unsigned long )include_directories___0 == (unsigned long )((struct stringlist *)0)) {
#line 984
    tmp___19 = (char **)0;
  } else {
#line 984
    tmp___19 = include_directories___0->list;
  }
  {
#line 984
  construct_include_path(tmp___19);
  }
#line 988
  if ((unsigned long )directories___0 == (unsigned long )((struct stringlist *)0)) {
#line 990
    starting_directory = current_directory;
  } else {
    {
#line 996
    tmp___20 = getcwd(current_directory, (size_t )4096);
    }
#line 996
    if ((unsigned long )tmp___20 == (unsigned long )((char *)0)) {
      {
#line 1000
      perror_with_name("getcwd: ", "");
#line 1004
      starting_directory = (char *)0;
      }
    } else {
#line 1007
      starting_directory = current_directory;
    }
  }
#line 1012
  if ((unsigned long )makefiles != (unsigned long )((struct stringlist *)0)) {
#line 1015
    i___0 = 0U;
    {
#line 1015
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1015
      if (! (i___0 < makefiles->idx)) {
#line 1015
        goto while_break___4;
      }
#line 1016
      if ((int )*(*(makefiles->list + i___0) + 0) == 45) {
#line 1016
        if ((int )*(*(makefiles->list + i___0) + 1) == 0) {
          {
#line 1031
          mktemp(name);
#line 1037
          outfile = fopen((char const   */* __restrict  */)(name), (char const   */* __restrict  */)"w");
          }
#line 1038
          if ((unsigned long )outfile == (unsigned long )((FILE *)0)) {
            {
#line 1039
            pfatal_with_name("fopen (temporary file)");
            }
          }
          {
#line 1040
          while (1) {
            while_continue___5: /* CIL Label */ ;
            {
#line 1040
            tmp___23 = feof(stdin);
            }
#line 1040
            if (tmp___23) {
#line 1040
              goto while_break___5;
            }
            {
#line 1043
            tmp___21 = fread((void */* __restrict  */)(buf___0), (size_t )1, sizeof(buf___0),
                             (FILE */* __restrict  */)stdin);
#line 1043
            n = (unsigned int )tmp___21;
            }
#line 1044
            if (n > 0U) {
              {
#line 1044
              tmp___22 = fwrite((void const   */* __restrict  */)(buf___0), (size_t )1,
                                (size_t )n, (FILE */* __restrict  */)outfile);
              }
#line 1044
              if (tmp___22 != (size_t )n) {
                {
#line 1045
                pfatal_with_name("fwrite (temporary file)");
                }
              }
            }
          }
          while_break___5: /* CIL Label */ ;
          }
          {
#line 1049
          fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%s:;\n",
                  name);
#line 1050
          fclose(outfile);
#line 1057
          tmp___24 = __builtin_alloca(sizeof(name));
#line 1057
          temp = (char *)tmp___24;
#line 1058
          memmove((void *)temp, (void const   *)(name), sizeof(name));
#line 1059
          *(makefiles->list + i___0) = temp;
#line 1063
          tmp___25 = savestring(name, sizeof(name) - 1UL);
#line 1063
          f = enter_file(tmp___25);
#line 1064
          f->updated = 1U;
#line 1065
          f->update_status = (short)0;
#line 1066
          f->command_state = (enum __anonenum_command_state_55 )3;
#line 1068
          f->intermediate = 1U;
#line 1070
          f->dontcare = 1U;
          }
        }
      }
#line 1015
      i___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 1078
  signal(17, & child_handler);
#line 1081
  signal(17, & child_handler);
#line 1086
  signal(10, & debug_signal_handler);
#line 1091
  set_default_suffixes();
#line 1099
  install_default_suffix_rules();
#line 1103
  define_automatic_variables();
#line 1108
  define_makeflags(0, 0);
#line 1158
  define_default_variables();
#line 1162
  default_file = enter_file(".DEFAULT");
  }
#line 1164
  if ((unsigned long )makefiles == (unsigned long )((struct stringlist *)0)) {
#line 1164
    tmp___26 = (char **)0;
  } else {
#line 1164
    tmp___26 = makefiles->list;
  }
  {
#line 1164
  read_makefiles___0 = read_all_makefiles(tmp___26);
#line 1190
  decode_env_switches((char *)"MAKEFLAGS", 9U);
#line 1197
  define_makeflags(1, 0);
#line 1202
  snap_deps();
#line 1209
  convert_to_pattern();
#line 1216
  install_default_implicit_rules();
#line 1220
  count_implicit_rule_limits();
#line 1224
  build_vpath_lists();
  }
#line 1230
  if ((unsigned long )old_files != (unsigned long )((struct stringlist *)0)) {
#line 1231
    p = old_files->list;
    {
#line 1231
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1231
      if (! ((unsigned long )*p != (unsigned long )((char *)0))) {
#line 1231
        goto while_break___6;
      }
      {
#line 1233
      f = enter_command_line_file(*p);
#line 1234
      f->last_mtime = (time_t )1;
#line 1235
      f->updated = 1U;
#line 1236
      f->update_status = (short)0;
#line 1237
      f->command_state = (enum __anonenum_command_state_55 )3;
#line 1231
      p ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 1240
  if ((unsigned long )new_files != (unsigned long )((struct stringlist *)0)) {
#line 1242
    p = new_files->list;
    {
#line 1242
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1242
      if (! ((unsigned long )*p != (unsigned long )((char *)0))) {
#line 1242
        goto while_break___7;
      }
      {
#line 1244
      f = enter_command_line_file(*p);
#line 1245
      f->last_mtime = -1L - (-1L << (sizeof(time_t ) * 8UL - 1UL));
#line 1242
      p ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  {
#line 1250
  remote_setup();
  }
#line 1252
  if ((unsigned long )read_makefiles___0 != (unsigned long )((struct dep *)0)) {
#line 1256
    makefile_mtimes = (time_t *)0;
#line 1257
    mm_idx = 0U;
#line 1258
    nargv = argv;
#line 1259
    nargc = argc;
#line 1261
    if (debug_flag) {
      {
#line 1262
      puts("Updating makefiles....");
      }
    }
#line 1268
    last = (struct dep *)0;
#line 1269
    d = read_makefiles___0;
    {
#line 1270
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1270
      if (! ((unsigned long )d != (unsigned long )((struct dep *)0))) {
#line 1270
        goto while_break___8;
      }
#line 1272
      f___0 = d->file;
#line 1273
      if (f___0->double_colon) {
#line 1274
        f___0 = f___0->double_colon;
        {
#line 1274
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 1274
          if (! ((unsigned long )f___0 != (unsigned long )((void *)0))) {
#line 1274
            goto while_break___9;
          }
#line 1276
          if ((unsigned long )f___0->deps == (unsigned long )((struct dep *)0)) {
#line 1276
            if ((unsigned long )f___0->cmds != (unsigned long )((struct commands *)0)) {
#line 1286
              if (debug_flag) {
                {
#line 1287
                printf((char const   */* __restrict  */)"Makefile `%s\' might loop; not remaking it.\n",
                       f___0->name);
                }
              }
#line 1290
              if ((unsigned long )last == (unsigned long )((struct dep *)0)) {
#line 1291
                read_makefiles___0 = d->next;
              } else {
#line 1293
                last->next = d->next;
              }
              {
#line 1296
              free((void *)((char *)d));
              }
#line 1298
              if ((unsigned long )last == (unsigned long )((struct dep *)0)) {
#line 1298
                d = (struct dep *)0;
              } else {
#line 1298
                d = last->next;
              }
#line 1300
              goto while_break___9;
            }
          }
#line 1274
          f___0 = f___0->prev;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
#line 1303
      if ((unsigned long )f___0 == (unsigned long )((void *)0)) {
#line 1303
        goto _L;
      } else
#line 1303
      if (! f___0->double_colon) {
        _L: /* CIL Label */ 
#line 1305
        if ((unsigned long )makefile_mtimes == (unsigned long )((time_t *)0)) {
          {
#line 1306
          tmp___27 = xmalloc(sizeof(time_t ));
#line 1306
          makefile_mtimes = (time_t *)tmp___27;
          }
        } else {
          {
#line 1308
          tmp___28 = xrealloc((char *)makefile_mtimes, (unsigned long )(mm_idx + 1U) * sizeof(time_t ));
#line 1308
          makefile_mtimes = (time_t *)tmp___28;
          }
        }
#line 1311
        tmp___29 = mm_idx;
#line 1311
        mm_idx ++;
#line 1311
        if ((d->file)->last_mtime != 0L) {
#line 1311
          *(makefile_mtimes + tmp___29) = (d->file)->last_mtime;
        } else {
          {
#line 1311
          tmp___30 = f_mtime(d->file, 0);
#line 1311
          *(makefile_mtimes + tmp___29) = tmp___30;
          }
        }
#line 1312
        last = d;
#line 1313
        d = d->next;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 1319
    define_makeflags(1, 1);
#line 1321
    tmp___31 = update_goal_chain(read_makefiles___0, 1);
    }
    {
#line 1329
    if (tmp___31 == -1) {
#line 1329
      goto case_neg_1;
    }
#line 1333
    if (tmp___31 == 2) {
#line 1333
      goto case_2;
    }
#line 1392
    if (tmp___31 == 0) {
#line 1392
      goto re_exec;
    }
#line 1324
    goto switch_default;
    switch_default: /* CIL Label */ 
    {
#line 1326
    __assert_fail("0", "/home/khheo/testset/make-3.76.1/main.c", 1326U, "main");
    }
#line 1327
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 1331
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1337
    any_remade = 0;
#line 1340
    any_failed = 0;
#line 1344
    i___1 = 0U;
#line 1344
    d___0 = read_makefiles___0;
    {
#line 1344
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 1344
      if (! ((unsigned long )d___0 != (unsigned long )((struct dep *)0))) {
#line 1344
        goto while_break___10;
      }
#line 1345
      if ((d___0->file)->updated) {
#line 1348
        if ((int )(d___0->file)->update_status == 0) {
#line 1351
          if ((d___0->file)->last_mtime != 0L) {
#line 1351
            tmp___33 = (d___0->file)->last_mtime;
          } else {
            {
#line 1351
            tmp___32 = f_mtime(d___0->file, 0);
#line 1351
            tmp___33 = tmp___32;
            }
          }
#line 1351
          any_remade |= tmp___33 != *(makefile_mtimes + i___1);
        } else
#line 1354
        if (! (d___0->changed & (1 << 2))) {
          {
#line 1359
          error("Failed to remake makefile `%s\'.", (d___0->file)->name);
          }
#line 1361
          if ((d___0->file)->last_mtime != 0L) {
#line 1361
            mtime = (d___0->file)->last_mtime;
          } else {
            {
#line 1361
            tmp___34 = f_mtime(d___0->file, 0);
#line 1361
            mtime = tmp___34;
            }
          }
#line 1362
          if (mtime != -1L) {
#line 1362
            if (mtime != *(makefile_mtimes + i___1)) {
#line 1362
              tmp___35 = 1;
            } else {
#line 1362
              tmp___35 = 0;
            }
          } else {
#line 1362
            tmp___35 = 0;
          }
#line 1362
          any_remade |= tmp___35;
        }
      } else
#line 1368
      if (! (d___0->changed & (1 << 2))) {
#line 1371
        if (d___0->changed & (1 << 1)) {
#line 1374
          if ((unsigned long )d___0->name == (unsigned long )((char *)0)) {
#line 1374
            tmp___36 = (d___0->file)->name;
          } else {
#line 1374
            tmp___36 = d___0->name;
          }
          {
#line 1374
          error("Included makefile `%s\' was not found.", tmp___36);
          }
        } else {
#line 1379
          if ((unsigned long )d___0->name == (unsigned long )((char *)0)) {
#line 1379
            tmp___37 = (d___0->file)->name;
          } else {
#line 1379
            tmp___37 = d___0->name;
          }
          {
#line 1379
          error("Makefile `%s\' was not found", tmp___37);
#line 1380
          any_failed = 1;
          }
        }
      }
#line 1344
      i___1 ++;
#line 1344
      d___0 = d___0->next;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 1384
    if (! any_remade) {
#line 1386
      if (any_failed) {
        {
#line 1387
        die(2);
        }
      } else {
#line 1389
        goto switch_break;
      }
    }
    re_exec: 
    case_0: /* CIL Label */ 
    {
#line 1396
    remove_intermediates(0);
    }
#line 1398
    if (print_data_base_flag) {
      {
#line 1399
      print_data_base();
      }
    }
    {
#line 1401
    log_working_directory(0);
    }
#line 1403
    if ((unsigned long )makefiles != (unsigned long )((struct stringlist *)0)) {
#line 1406
      j = 0U;
#line 1407
      i___2 = 1U;
      {
#line 1407
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 1407
        if (! (i___2 < (unsigned int )argc)) {
#line 1407
          goto while_break___11;
        }
        {
#line 1408
        tmp___38 = strncmp((char const   *)*(argv + i___2), "-f", (size_t )2);
        }
#line 1408
        if (! tmp___38) {
#line 1410
          p___1 = *(argv + i___2) + 2;
#line 1411
          if ((int )*p___1 == 0) {
#line 1412
            i___2 ++;
#line 1412
            *(argv + i___2) = *(makefiles->list + j);
          } else {
            {
#line 1414
            *(argv + i___2) = concat("-f", *(makefiles->list + j), "");
            }
          }
#line 1415
          j ++;
        }
#line 1407
        i___2 ++;
      }
      while_break___11: /* CIL Label */ ;
      }
    }
#line 1424
    i___3 = (unsigned int )(argc + 1);
#line 1424
    d___1 = read_makefiles___0;
    {
#line 1424
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 1424
      if (! ((unsigned long )d___1 != (unsigned long )((struct dep *)0))) {
#line 1424
        goto while_break___12;
      }
#line 1425
      i___3 += (unsigned int )((d___1->file)->updated != 0U);
#line 1424
      d___1 = d___1->next;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 1427
    tmp___39 = xmalloc((unsigned long )i___3 * sizeof(char *));
#line 1427
    nargv = (char **)tmp___39;
#line 1428
    memmove((void *)nargv, (void const   *)argv, (unsigned long )argc * sizeof(char *));
#line 1430
    i___3 = 0U;
#line 1430
    d___1 = read_makefiles___0;
    }
    {
#line 1430
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 1430
      if (! ((unsigned long )d___1 != (unsigned long )((struct dep *)0))) {
#line 1430
        goto while_break___13;
      }
#line 1432
      if ((d___1->file)->updated) {
#line 1433
        tmp___40 = nargc;
#line 1433
        nargc ++;
#line 1433
        if ((unsigned long )d___1->name == (unsigned long )((char *)0)) {
#line 1433
          tmp___41 = (d___1->file)->name;
        } else {
#line 1433
          tmp___41 = d___1->name;
        }
        {
#line 1433
        *(nargv + tmp___40) = concat("-o", tmp___41, "");
        }
      }
#line 1430
      i___3 ++;
#line 1430
      d___1 = d___1->next;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 1435
    *(nargv + nargc) = (char *)0;
#line 1438
    if ((unsigned long )directories___0 != (unsigned long )((struct stringlist *)0)) {
#line 1438
      if (directories___0->idx > 0U) {
#line 1441
        if ((unsigned long )directory_before_chdir != (unsigned long )((char *)0)) {
          {
#line 1443
          tmp___42 = chdir((char const   *)directory_before_chdir);
          }
#line 1443
          if (tmp___42 < 0) {
            {
#line 1445
            perror_with_name("chdir", "");
#line 1446
            bad = (char)1;
            }
          } else {
#line 1449
            bad = (char)0;
          }
        } else {
#line 1452
          bad = (char)1;
        }
#line 1453
        if (bad) {
          {
#line 1454
          fatal("Couldn\'t change back to original directory.");
          }
        }
      }
    }
#line 1458
    p = environ;
    {
#line 1458
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 1458
      if (! ((unsigned long )*p != (unsigned long )((char *)0))) {
#line 1458
        goto while_break___14;
      }
      {
#line 1459
      tmp___44 = strncmp((char const   *)*p, "MAKELEVEL=", (size_t )10);
      }
#line 1459
      if (! tmp___44) {
        {
#line 1465
        tmp___43 = __builtin_alloca(40UL);
#line 1465
        sgi_loses = (char *)tmp___43;
#line 1466
        *p = sgi_loses;
#line 1467
        sprintf((char */* __restrict  */)*p, (char const   */* __restrict  */)"MAKELEVEL=%u",
                makelevel);
        }
#line 1468
        goto while_break___14;
      }
#line 1458
      p ++;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 1485
    if (debug_flag) {
      {
#line 1488
      fputs((char const   */* __restrict  */)"Re-executing:", (FILE */* __restrict  */)stdout);
#line 1489
      p___2 = nargv;
      }
      {
#line 1489
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 1489
        if (! ((unsigned long )*p___2 != (unsigned long )((char *)0))) {
#line 1489
          goto while_break___15;
        }
        {
#line 1490
        printf((char const   */* __restrict  */)" %s", *p___2);
#line 1489
        p___2 ++;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 1491
      puts("");
      }
    }
    {
#line 1494
    fflush(stdout);
#line 1495
    fflush(stderr);
#line 1498
    exec_command(nargv, environ);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 1508
  define_makeflags(1, 0);
  }
#line 1514
  if ((unsigned long )goals == (unsigned long )((struct dep *)0)) {
#line 1516
    if ((unsigned long )default_goal_file != (unsigned long )((struct file *)0)) {
      {
#line 1518
      tmp___45 = xmalloc(sizeof(struct dep ));
#line 1518
      goals = (struct dep *)tmp___45;
#line 1519
      goals->next = (struct dep *)0;
#line 1520
      goals->name = (char *)0;
#line 1521
      goals->file = default_goal_file;
      }
    }
  } else {
#line 1525
    lastgoal->next = (struct dep *)0;
  }
#line 1527
  if ((unsigned long )goals != (unsigned long )((struct dep *)0)) {
#line 1531
    if (debug_flag) {
      {
#line 1532
      puts("Updating goal targets....");
      }
    }
    {
#line 1534
    tmp___46 = update_goal_chain(goals, 0);
    }
    {
#line 1538
    if (tmp___46 == 0) {
#line 1538
      goto case_0___0;
    }
#line 1538
    if (tmp___46 == -1) {
#line 1538
      goto case_0___0;
    }
#line 1542
    if (tmp___46 == 2) {
#line 1542
      goto case_2___0;
    }
#line 1547
    if (tmp___46 == 1) {
#line 1547
      goto case_1;
    }
#line 1551
    goto switch_default___0;
    case_0___0: /* CIL Label */ 
    case_neg_1___0: /* CIL Label */ 
#line 1540
    status = 0;
#line 1541
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 1545
    status = 2;
#line 1546
    goto switch_break___0;
    case_1: /* CIL Label */ 
#line 1549
    status = 1;
#line 1550
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 1552
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
  } else
#line 1557
  if ((unsigned long )read_makefiles___0 == (unsigned long )((struct dep *)0)) {
    {
#line 1558
    fatal("No targets specified and no makefile found");
    }
  } else {
    {
#line 1560
    fatal("No targets");
    }
  }
#line 1564
  if (clock_skew_detected) {
    {
#line 1565
    error("*** Warning:  Clock skew detected.  Your build may be incomplete.");
    }
  }
  {
#line 1568
  die(status);
  }
#line 1571
  return (0);
}
}
#line 1576 "/home/khheo/testset/make-3.76.1/main.c"
static char options[1UL + (sizeof(switches) / sizeof(switches[0])) * 3UL]  ;
#line 1577 "/home/khheo/testset/make-3.76.1/main.c"
static struct option long_options[sizeof(switches) / sizeof(switches[0]) + sizeof(long_option_aliases) / sizeof(long_option_aliases[0])]  ;
#line 1582 "/home/khheo/testset/make-3.76.1/main.c"
static void init_switches(void) 
{ 
  register char *p ;
  register int c ;
  register unsigned int i ;
  char *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned int tmp___6 ;
  char *__cil_tmp12 ;

  {
#line 1589
  if ((int )options[0] != 0) {
#line 1591
    return;
  }
#line 1593
  p = options;
#line 1597
  tmp = p;
#line 1597
  p ++;
#line 1597
  *tmp = (char )'-';
#line 1599
  i = 0U;
  {
#line 1599
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1599
    if (! ((int const   )switches[i].c != 0)) {
#line 1599
      goto while_break;
    }
#line 1601
    if ((unsigned long )switches[i].long_name == (unsigned long )((char */* const  */)0)) {
#line 1601
      long_options[i].name = "";
    } else {
#line 1601
      long_options[i].name = (char const   *)switches[i].long_name;
    }
    {
#line 1603
    long_options[i].flag = (int *)0;
#line 1604
    long_options[i].val = (int )switches[i].c;
#line 1605
    tmp___1 = __ctype_b_loc();
    }
#line 1605
    if ((int const   )*(*tmp___1 + (int )switches[i].c) & 8) {
#line 1606
      tmp___0 = p;
#line 1606
      p ++;
#line 1606
      *tmp___0 = (char )switches[i].c;
    }
    {
#line 1611
    if ((unsigned int const   )switches[i].type == 5U) {
#line 1611
      goto case_5;
    }
#line 1611
    if ((unsigned int const   )switches[i].type == 1U) {
#line 1611
      goto case_5;
    }
#line 1611
    if ((unsigned int const   )switches[i].type == 0U) {
#line 1611
      goto case_5;
    }
#line 1617
    if ((unsigned int const   )switches[i].type == 4U) {
#line 1617
      goto case_4;
    }
#line 1617
    if ((unsigned int const   )switches[i].type == 3U) {
#line 1617
      goto case_4;
    }
#line 1617
    if ((unsigned int const   )switches[i].type == 2U) {
#line 1617
      goto case_4;
    }
#line 1607
    goto switch_break;
    case_5: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1612
    long_options[i].has_arg = 0;
#line 1613
    goto switch_break;
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 1618
    tmp___3 = __ctype_b_loc();
    }
#line 1618
    if ((int const   )*(*tmp___3 + (int )switches[i].c) & 8) {
#line 1619
      tmp___2 = p;
#line 1619
      p ++;
#line 1619
      *tmp___2 = (char )':';
    }
#line 1620
    if ((unsigned long )switches[i].noarg_value != (unsigned long )((char */* const  */)0)) {
      {
#line 1622
      tmp___5 = __ctype_b_loc();
      }
#line 1622
      if ((int const   )*(*tmp___5 + (int )switches[i].c) & 8) {
#line 1623
        tmp___4 = p;
#line 1623
        p ++;
#line 1623
        *tmp___4 = (char )':';
      }
#line 1624
      long_options[i].has_arg = 2;
    } else {
#line 1627
      long_options[i].has_arg = 1;
    }
#line 1628
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1599
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1631
  *p = (char )'\000';
#line 1632
  c = 0;
  {
#line 1632
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1632
    if (! ((unsigned long )c < sizeof(long_option_aliases) / sizeof(long_option_aliases[0]))) {
#line 1632
      goto while_break___0;
    }
#line 1635
    tmp___6 = i;
#line 1635
    i ++;
#line 1635
    long_options[tmp___6] = long_option_aliases[c];
#line 1632
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1636
  long_options[i].name = (char const   *)0;
#line 1637
  return;
}
}
#line 1639 "/home/khheo/testset/make-3.76.1/main.c"
static void handle_non_switch_argument(char *arg , int env ) 
{ 
  struct variable *v ;
  struct command_variable *cv ;
  char *tmp ;
  struct file *f ;
  struct file *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  struct variable *v___0 ;
  char *value ;
  unsigned int oldlen ;
  unsigned int newlen ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 1646
  if ((int )*(arg + 0) == 45) {
#line 1646
    if ((int )*(arg + 1) == 0) {
#line 1648
      return;
    }
  }
  {
#line 1649
  v = try_variable_definition((char *)0, 0U, arg, (enum variable_origin )4);
  }
#line 1650
  if ((unsigned long )v != (unsigned long )((struct variable *)0)) {
    {
#line 1654
    tmp = xmalloc(sizeof(*cv));
#line 1654
    cv = (struct command_variable *)tmp;
#line 1656
    cv->variable = v;
#line 1657
    cv->next = command_variables;
#line 1658
    command_variables = cv;
    }
  } else
#line 1660
  if (! env) {
    {
#line 1665
    tmp___0 = enter_command_line_file(arg);
#line 1665
    f = tmp___0;
#line 1666
    f->cmd_target = 1U;
    }
#line 1668
    if ((unsigned long )goals == (unsigned long )((struct dep *)0)) {
      {
#line 1670
      tmp___1 = xmalloc(sizeof(struct dep ));
#line 1670
      goals = (struct dep *)tmp___1;
#line 1671
      lastgoal = goals;
      }
    } else {
      {
#line 1675
      tmp___2 = xmalloc(sizeof(struct dep ));
#line 1675
      lastgoal->next = (struct dep *)tmp___2;
#line 1677
      lastgoal = lastgoal->next;
      }
    }
    {
#line 1679
    lastgoal->name = (char *)0;
#line 1680
    lastgoal->file = f;
#line 1687
    v___0 = lookup_variable((char *)"MAKECMDGOALS", 12U);
    }
#line 1688
    if ((unsigned long )v___0 == (unsigned long )((struct variable *)0)) {
#line 1689
      value = f->name;
    } else {
      {
#line 1695
      tmp___3 = strlen((char const   *)v___0->value);
#line 1695
      oldlen = (unsigned int )tmp___3;
#line 1696
      tmp___4 = strlen((char const   *)f->name);
#line 1696
      newlen = (unsigned int )tmp___4;
#line 1697
      tmp___5 = __builtin_alloca((unsigned long )(((oldlen + 1U) + newlen) + 1U));
#line 1697
      value = (char *)tmp___5;
#line 1698
      memmove((void *)value, (void const   *)v___0->value, (size_t )oldlen);
#line 1699
      *(value + oldlen) = (char )' ';
#line 1700
      memmove((void *)(value + (oldlen + 1U)), (void const   *)f->name, (size_t )(newlen + 1U));
      }
    }
    {
#line 1702
    define_variable((char *)"MAKECMDGOALS", 12U, value, (enum variable_origin )0,
                    0);
    }
  }
#line 1705
  return;
}
}
#line 1710 "/home/khheo/testset/make-3.76.1/main.c"
static void decode_switches(int argc , char **argv , int env ) 
{ 
  int bad ;
  register struct command_switch  const  *cs ;
  register struct stringlist *sl ;
  register int c ;
  int doit ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  int i ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  double tmp___9 ;
  int tmp___10 ;
  FILE *usageto ;
  char buf___0[1024] ;
  char shortarg[50] ;
  char longarg[50] ;
  char *p ;
  size_t tmp___11 ;
  unsigned short const   **tmp___12 ;
  unsigned int i___0 ;
  char const   *tmp___14 ;
  unsigned short const   **tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  struct command_switch  const  *ncs ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  int tmp___20 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;

  {
  {
#line 1716
  bad = 0;
#line 1724
  init_switches();
#line 1728
  opterr = ! env;
#line 1730
  optind = 0;
  }
  {
#line 1732
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1732
    if (! (optind < argc)) {
#line 1732
      goto while_break;
    }
    {
#line 1735
    c = getopt_long(argc, (char * const  *)argv, (char const   *)(options), (struct option  const  *)(long_options),
                    (int *)0);
    }
#line 1736
    if (c == -1) {
#line 1738
      goto while_break;
    } else
#line 1739
    if (c == 1) {
      {
#line 1741
      handle_non_switch_argument(optarg, env);
      }
    } else
#line 1742
    if (c == 63) {
#line 1746
      bad = 1;
    } else {
#line 1748
      cs = switches;
      {
#line 1748
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1748
        if (! ((int const   )cs->c != 0)) {
#line 1748
          goto while_break___0;
        }
#line 1749
        if ((int const   )cs->c == (int const   )c) {
#line 1755
          if (! env) {
#line 1755
            tmp = 1;
          } else
#line 1755
          if (cs->env) {
#line 1755
            tmp = 1;
          } else {
#line 1755
            tmp = 0;
          }
#line 1755
          doit = tmp;
          {
#line 1762
          if ((unsigned int const   )cs->type == 5U) {
#line 1762
            goto case_5;
          }
#line 1766
          if ((unsigned int const   )cs->type == 1U) {
#line 1766
            goto case_1;
          }
#line 1766
          if ((unsigned int const   )cs->type == 0U) {
#line 1766
            goto case_1;
          }
#line 1771
          if ((unsigned int const   )cs->type == 2U) {
#line 1771
            goto case_2;
          }
#line 1799
          if ((unsigned int const   )cs->type == 3U) {
#line 1799
            goto case_3;
          }
#line 1827
          if ((unsigned int const   )cs->type == 4U) {
#line 1827
            goto case_4;
          }
#line 1759
          goto switch_default;
          switch_default: /* CIL Label */ 
          {
#line 1760
          abort();
          }
          case_5: /* CIL Label */ 
#line 1763
          goto switch_break;
          case_1: /* CIL Label */ 
          case_0: /* CIL Label */ 
#line 1767
          if (doit) {
#line 1768
            *((int *)cs->value_ptr) = (unsigned int const   )cs->type == 0U;
          }
#line 1769
          goto switch_break;
          case_2: /* CIL Label */ 
#line 1772
          if (! doit) {
#line 1773
            goto switch_break;
          }
#line 1775
          if ((unsigned long )optarg == (unsigned long )((char *)0)) {
#line 1776
            optarg = (char *)cs->noarg_value;
          }
#line 1778
          sl = *((struct stringlist **)cs->value_ptr);
#line 1779
          if ((unsigned long )sl == (unsigned long )((struct stringlist *)0)) {
            {
#line 1781
            tmp___0 = xmalloc(sizeof(struct stringlist ));
#line 1781
            sl = (struct stringlist *)tmp___0;
#line 1783
            sl->max = 5U;
#line 1784
            sl->idx = 0U;
#line 1785
            tmp___1 = xmalloc(5UL * sizeof(char *));
#line 1785
            sl->list = (char **)tmp___1;
#line 1786
            *((struct stringlist **)cs->value_ptr) = sl;
            }
          } else
#line 1788
          if (sl->idx == sl->max - 1U) {
            {
#line 1790
            sl->max += 5U;
#line 1791
            tmp___2 = xrealloc((char *)sl->list, (unsigned long )sl->max * sizeof(char *));
#line 1791
            sl->list = (char **)tmp___2;
            }
          }
#line 1795
          tmp___3 = sl->idx;
#line 1795
          (sl->idx) ++;
#line 1795
          *(sl->list + tmp___3) = optarg;
#line 1796
          *(sl->list + sl->idx) = (char *)0;
#line 1797
          goto switch_break;
          case_3: /* CIL Label */ 
#line 1800
          if ((unsigned long )optarg == (unsigned long )((char *)0)) {
#line 1800
            if (argc > optind) {
              {
#line 1800
              tmp___5 = __ctype_b_loc();
              }
#line 1800
              if ((int const   )*(*tmp___5 + (int )*(*(argv + optind) + 0)) & 2048) {
#line 1802
                tmp___4 = optind;
#line 1802
                optind ++;
#line 1802
                optarg = *(argv + tmp___4);
              }
            }
          }
#line 1804
          if (! doit) {
#line 1805
            goto switch_break;
          }
#line 1807
          if ((unsigned long )optarg != (unsigned long )((char *)0)) {
            {
#line 1809
            tmp___6 = atoi((char const   *)optarg);
#line 1809
            i = tmp___6;
            }
#line 1810
            if (i < 1) {
#line 1812
              if (doit) {
                {
#line 1813
                error("the `-%c\' option requires a positive integral argument", (int const   )cs->c);
                }
              }
#line 1816
              bad = 1;
            } else {
#line 1819
              *((unsigned int *)cs->value_ptr) = (unsigned int )i;
            }
          } else {
#line 1822
            *((unsigned int *)cs->value_ptr) = *((unsigned int *)cs->noarg_value);
          }
#line 1824
          goto switch_break;
          case_4: /* CIL Label */ 
#line 1828
          if ((unsigned long )optarg == (unsigned long )((char *)0)) {
#line 1828
            if (optind < argc) {
              {
#line 1828
              tmp___8 = __ctype_b_loc();
              }
#line 1828
              if ((int const   )*(*tmp___8 + (int )*(*(argv + optind) + 0)) & 2048) {
#line 1830
                tmp___7 = optind;
#line 1830
                optind ++;
#line 1830
                optarg = *(argv + tmp___7);
              } else
#line 1828
              if ((int )*(*(argv + optind) + 0) == 46) {
#line 1830
                tmp___7 = optind;
#line 1830
                optind ++;
#line 1830
                optarg = *(argv + tmp___7);
              }
            }
          }
#line 1832
          if (doit) {
#line 1833
            if ((unsigned long )optarg != (unsigned long )((char *)0)) {
              {
#line 1833
              tmp___9 = atof((char const   *)optarg);
#line 1833
              *((double *)cs->value_ptr) = tmp___9;
              }
            } else {
#line 1833
              *((double *)cs->value_ptr) = *((double *)cs->noarg_value);
            }
          }
#line 1837
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 1842
          goto while_break___0;
        }
#line 1748
        cs ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1850
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1850
    if (! (optind < argc)) {
#line 1850
      goto while_break___1;
    }
    {
#line 1851
    tmp___10 = optind;
#line 1851
    optind ++;
#line 1851
    handle_non_switch_argument(*(argv + tmp___10), env);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1854
  if (! env) {
#line 1854
    if (bad) {
#line 1854
      goto _L;
    } else
#line 1854
    if (print_usage_flag) {
      _L: /* CIL Label */ 
#line 1859
      if (print_version_flag) {
        {
#line 1860
        print_version();
        }
      }
#line 1862
      if (bad) {
#line 1862
        usageto = stderr;
      } else {
#line 1862
        usageto = stdout;
      }
      {
#line 1864
      fprintf((FILE */* __restrict  */)usageto, (char const   */* __restrict  */)"Usage: %s [options] [target] ...\n",
              program);
#line 1866
      fputs((char const   */* __restrict  */)"Options:\n", (FILE */* __restrict  */)usageto);
#line 1867
      cs = switches;
      }
      {
#line 1867
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1867
        if (! ((int const   )cs->c != 0)) {
#line 1867
          goto while_break___2;
        }
#line 1871
        if ((int )*(cs->description + 0) == 45) {
#line 1872
          goto __Cont;
        }
        {
#line 1876
        if (long_options[cs - switches].has_arg == 0) {
#line 1876
          goto case_0___0;
        }
#line 1879
        if (long_options[cs - switches].has_arg == 1) {
#line 1879
          goto case_1___0;
        }
#line 1883
        if (long_options[cs - switches].has_arg == 2) {
#line 1883
          goto case_2___0;
        }
#line 1874
        goto switch_break___0;
        case_0___0: /* CIL Label */ 
#line 1877
        longarg[0] = (char )'\000';
#line 1877
        shortarg[0] = longarg[0];
#line 1878
        goto switch_break___0;
        case_1___0: /* CIL Label */ 
        {
#line 1880
        sprintf((char */* __restrict  */)(longarg), (char const   */* __restrict  */)"=%s",
                cs->argdesc);
#line 1881
        sprintf((char */* __restrict  */)(shortarg), (char const   */* __restrict  */)" %s",
                cs->argdesc);
        }
#line 1882
        goto switch_break___0;
        case_2___0: /* CIL Label */ 
        {
#line 1884
        sprintf((char */* __restrict  */)(longarg), (char const   */* __restrict  */)"[=%s]",
                cs->argdesc);
#line 1885
        sprintf((char */* __restrict  */)(shortarg), (char const   */* __restrict  */)" [%s]",
                cs->argdesc);
        }
#line 1886
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
        {
#line 1889
        p = buf___0;
#line 1891
        tmp___12 = __ctype_b_loc();
        }
#line 1891
        if ((int const   )*(*tmp___12 + (int )cs->c) & 8) {
          {
#line 1893
          sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"  -%c%s",
                  (int const   )cs->c, shortarg);
#line 1894
          tmp___11 = strlen((char const   *)p);
#line 1894
          p += tmp___11;
          }
        }
#line 1896
        if ((unsigned long )cs->long_name != (unsigned long )((char */* const  */)0)) {
          {
#line 1899
          tmp___15 = __ctype_b_loc();
          }
#line 1899
          if ((int const   )*(*tmp___15 + (int )cs->c) & 8) {
#line 1899
            tmp___14 = ", ";
          } else {
#line 1899
            tmp___14 = "  ";
          }
          {
#line 1899
          sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%s--%s%s",
                  tmp___14, cs->long_name, longarg);
#line 1902
          tmp___16 = strlen((char const   *)p);
#line 1902
          p += tmp___16;
#line 1903
          i___0 = 0U;
          }
          {
#line 1903
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1903
            if (! ((unsigned long )i___0 < sizeof(long_option_aliases) / sizeof(long_option_aliases[0]))) {
#line 1903
              goto while_break___3;
            }
#line 1906
            if (long_option_aliases[i___0].val == (int )cs->c) {
              {
#line 1908
              sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)", --%s%s",
                      long_option_aliases[i___0].name, longarg);
#line 1910
              tmp___17 = strlen((char const   *)p);
#line 1910
              p += tmp___17;
              }
            }
#line 1903
            i___0 ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 1914
        ncs = cs;
        {
#line 1915
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1915
          ncs ++;
#line 1915
          if (! ((int const   )ncs->c != 0)) {
#line 1915
            goto while_break___4;
          }
#line 1916
          if ((int )*(ncs->description + 0) == 45) {
#line 1916
            if ((int )*(ncs->description + 1) == (int )cs->c) {
              {
#line 1922
              sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)", -%c%s",
                      (int const   )ncs->c, shortarg);
#line 1923
              tmp___18 = strlen((char const   *)p);
#line 1923
              p += tmp___18;
              }
#line 1924
              if ((unsigned long )ncs->long_name != (unsigned long )((char */* const  */)0)) {
                {
#line 1926
                sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)", --%s%s",
                        ncs->long_name, longarg);
#line 1927
                tmp___19 = strlen((char const   *)p);
#line 1927
                p += tmp___19;
                }
              }
            }
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1932
        if (p - buf___0 > 28L) {
          {
#line 1937
          fprintf((FILE */* __restrict  */)usageto, (char const   */* __restrict  */)"%s\n",
                  buf___0);
#line 1938
          buf___0[0] = (char )'\000';
          }
        }
        {
#line 1941
        fprintf((FILE */* __restrict  */)usageto, (char const   */* __restrict  */)"%*s%s.\n",
                -30, buf___0, cs->description);
        }
        __Cont: /* CIL Label */ 
#line 1867
        cs ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1946
      if (bad) {
#line 1946
        tmp___20 = 2;
      } else {
#line 1946
        tmp___20 = 0;
      }
      {
#line 1946
      die(tmp___20);
      }
    }
  }
#line 1948
  return;
}
}
#line 1955 "/home/khheo/testset/make-3.76.1/main.c"
static void decode_env_switches(char *envar , unsigned int len ) 
{ 
  char *varref ;
  void *tmp ;
  char *value ;
  char *p ;
  int argc ;
  char **argv ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 1960
  tmp = __builtin_alloca((unsigned long )((2U + len) + 2U));
#line 1960
  varref = (char *)tmp;
#line 1966
  *(varref + 0) = (char )'$';
#line 1967
  *(varref + 1) = (char )'(';
#line 1968
  memmove((void *)(varref + 2), (void const   *)envar, (size_t )len);
#line 1969
  *(varref + (2U + len)) = (char )')';
#line 1970
  *(varref + ((2U + len) + 1U)) = (char )'\000';
#line 1971
  value = variable_expand(varref);
#line 1974
  value = next_token(value);
#line 1975
  tmp___0 = strlen((char const   *)value);
#line 1975
  len = (unsigned int )tmp___0;
  }
#line 1976
  if (len == 0U) {
#line 1977
    return;
  }
  {
#line 1980
  tmp___1 = __builtin_alloca((unsigned long )((1U + len) + 1U) * sizeof(char *));
#line 1980
  argv = (char **)tmp___1;
#line 1985
  tmp___2 = xmalloc(2U * len);
#line 1985
  p = tmp___2;
#line 1989
  *(argv + 0) = (char *)0;
#line 1990
  argc = 1;
#line 1991
  *(argv + argc) = p;
  }
  {
#line 1992
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1992
    if (! ((int )*value != 0)) {
#line 1992
      goto while_break;
    }
#line 1994
    if ((int )*value == 92) {
#line 1995
      value ++;
    } else {
      {
#line 1996
      tmp___5 = __ctype_b_loc();
      }
#line 1996
      if ((int const   )*(*tmp___5 + (int )*value) & 1) {
#line 1999
        tmp___3 = p;
#line 1999
        p ++;
#line 1999
        *tmp___3 = (char )'\000';
#line 2000
        argc ++;
#line 2000
        *(argv + argc) = p;
        {
#line 2001
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 2002
          value ++;
#line 2001
          tmp___4 = __ctype_b_loc();
          }
#line 2001
          if (! ((int const   )*(*tmp___4 + (int )*value) & 1)) {
#line 2001
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 2004
        goto while_continue;
      }
    }
#line 2006
    tmp___6 = p;
#line 2006
    p ++;
#line 2006
    tmp___7 = value;
#line 2006
    value ++;
#line 2006
    *tmp___6 = *tmp___7;
  }
  while_break: /* CIL Label */ ;
  }
#line 2008
  *p = (char )'\000';
#line 2009
  argc ++;
#line 2009
  *(argv + argc) = (char *)0;
#line 2011
  if ((int )*(*(argv + 1) + 0) != 45) {
    {
#line 2011
    tmp___8 = strchr((char const   *)*(argv + 1), '=');
    }
#line 2011
    if ((unsigned long )tmp___8 == (unsigned long )((char *)0)) {
      {
#line 2016
      *(argv + 1) = concat("-", *(argv + 1), "");
      }
    }
  }
  {
#line 2019
  decode_switches(argc, argv, 1);
  }
#line 2020
  return;
}
}
#line 2029 "/home/khheo/testset/make-3.76.1/main.c"
static char *quote_as_word(char *out , char *in , int double_dollars ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp9 ;

  {
  {
#line 2034
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2034
    if (! ((int )*in != 0)) {
#line 2034
      goto while_break;
    }
    {
#line 2039
    tmp___0 = strchr("^;\'\"*?[]$<>(){}|&~`\\ \t\r\n\f\v", (int )*in);
    }
#line 2039
    if ((unsigned long )tmp___0 != (unsigned long )((char *)0)) {
#line 2041
      tmp = out;
#line 2041
      out ++;
#line 2041
      *tmp = (char )'\\';
    }
#line 2042
    if (double_dollars) {
#line 2042
      if ((int )*in == 36) {
#line 2043
        tmp___1 = out;
#line 2043
        out ++;
#line 2043
        *tmp___1 = (char )'$';
      }
    }
#line 2044
    tmp___2 = out;
#line 2044
    out ++;
#line 2044
    tmp___3 = in;
#line 2044
    in ++;
#line 2044
    *tmp___2 = *tmp___3;
  }
  while_break: /* CIL Label */ ;
  }
#line 2047
  return (out);
}
}
#line 2058 "/home/khheo/testset/make-3.76.1/main.c"
static char const   ref[17]  = 
#line 2058
  {      (char const   )'$',      (char const   )'(',      (char const   )'M',      (char const   )'A', 
        (char const   )'K',      (char const   )'E',      (char const   )'O',      (char const   )'V', 
        (char const   )'E',      (char const   )'R',      (char const   )'R',      (char const   )'I', 
        (char const   )'D',      (char const   )'E',      (char const   )'S',      (char const   )')', 
        (char const   )'\000'};
#line 2059 "/home/khheo/testset/make-3.76.1/main.c"
static char const   posixref[27]  = 
#line 2059
  {      (char const   )'$',      (char const   )'(',      (char const   )'-',      (char const   )'*', 
        (char const   )'-',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )'-',      (char const   )'v',      (char const   )'a',      (char const   )'r', 
        (char const   )'i',      (char const   )'a',      (char const   )'b',      (char const   )'l', 
        (char const   )'e',      (char const   )'s',      (char const   )'-',      (char const   )'*', 
        (char const   )'-',      (char const   )')',      (char const   )'\000'};
#line 2054 "/home/khheo/testset/make-3.76.1/main.c"
static void define_makeflags(int all , int makefile ) 
{ 
  register struct command_switch  const  *cs ;
  char *flagstring ;
  register char *p ;
  unsigned int words ;
  struct variable *v ;
  struct flag *flags ;
  unsigned int flagslen ;
  struct flag *new ;
  void *tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  struct flag *new___0 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  unsigned short const   **tmp___4 ;
  struct flag *new___1 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  unsigned short const   **tmp___7 ;
  char *buf___0 ;
  void *tmp___8 ;
  struct flag *new___2 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  unsigned short const   **tmp___12 ;
  struct flag *new___3 ;
  void *tmp___13 ;
  size_t tmp___14 ;
  unsigned short const   **tmp___15 ;
  char *buf___1 ;
  void *tmp___16 ;
  struct flag *new___4 ;
  void *tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  unsigned short const   **tmp___20 ;
  struct stringlist *sl ;
  register unsigned int i ;
  struct flag *new___5 ;
  void *tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  unsigned short const   **tmp___24 ;
  unsigned int tmp___25 ;
  void *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  size_t tmp___29 ;
  char *tmp___30 ;
  unsigned short const   **tmp___31 ;
  char *tmp___32 ;
  unsigned short const   **tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  unsigned short const   **tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  int tmp___44 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;

  {
#line 2077
  flags = (struct flag *)0;
#line 2078
  flagslen = 0U;
#line 2095
  cs = switches;
  {
#line 2095
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2095
    if (! ((int const   )cs->c != 0)) {
#line 2095
      goto while_break;
    }
#line 2096
    if (cs->toenv) {
#line 2096
      if (! makefile) {
#line 2096
        goto _L___4;
      } else
#line 2096
      if (! cs->no_makefile) {
        _L___4: /* CIL Label */ 
        {
#line 2102
        if ((unsigned int const   )cs->type == 5U) {
#line 2102
          goto case_5;
        }
#line 2106
        if ((unsigned int const   )cs->type == 1U) {
#line 2106
          goto case_1;
        }
#line 2106
        if ((unsigned int const   )cs->type == 0U) {
#line 2106
          goto case_1;
        }
#line 2113
        if ((unsigned int const   )cs->type == 3U) {
#line 2113
          goto case_3;
        }
#line 2137
        if ((unsigned int const   )cs->type == 4U) {
#line 2137
          goto case_4;
        }
#line 2158
        if ((unsigned int const   )cs->type == 2U) {
#line 2158
          goto case_2;
        }
#line 2099
        goto switch_default;
        switch_default: /* CIL Label */ 
        {
#line 2100
        abort();
        }
        case_5: /* CIL Label */ 
#line 2103
        goto switch_break;
        case_1: /* CIL Label */ 
        case_0: /* CIL Label */ 
#line 2107
        if (! *((int *)cs->value_ptr) == ((unsigned int const   )cs->type == 1U)) {
#line 2107
          if ((unsigned long )cs->default_value == (unsigned long )((char */* const  */)0)) {
#line 2107
            goto _L;
          } else
#line 2107
          if (*((int *)cs->value_ptr) != *((int *)cs->default_value)) {
            _L: /* CIL Label */ 
            {
#line 2110
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 2110
              tmp = __builtin_alloca(sizeof(struct flag ));
#line 2110
              new = (struct flag *)tmp;
#line 2110
              new->cs = cs;
#line 2110
              new->arg = (char *)0;
#line 2110
              new->next = flags;
#line 2110
              flags = new;
              }
#line 2110
              if ((unsigned long )new->arg == (unsigned long )((char *)0)) {
#line 2110
                flagslen ++;
              } else {
#line 2110
                flagslen += 4U;
              }
              {
#line 2110
              tmp___1 = __ctype_b_loc();
              }
#line 2110
              if (! ((int const   )*(*tmp___1 + (int )cs->c) & 8)) {
                {
#line 2110
                tmp___0 = strlen((char const   *)cs->long_name);
#line 2110
                flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___0));
                }
              }
#line 2110
              goto while_break___0;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
        }
#line 2111
        goto switch_break;
        case_3: /* CIL Label */ 
#line 2114
        if (all) {
#line 2116
          if ((unsigned long )cs->default_value != (unsigned long )((char */* const  */)0)) {
#line 2116
            if (*((unsigned int *)cs->value_ptr) == *((unsigned int *)cs->default_value)) {
#line 2119
              goto switch_break;
            } else {
#line 2116
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 2120
          if ((unsigned long )cs->noarg_value != (unsigned long )((char */* const  */)0)) {
#line 2120
            if (*((unsigned int *)cs->value_ptr) == *((unsigned int *)cs->noarg_value)) {
              {
#line 2123
              while (1) {
                while_continue___1: /* CIL Label */ ;
                {
#line 2123
                tmp___2 = __builtin_alloca(sizeof(struct flag ));
#line 2123
                new___0 = (struct flag *)tmp___2;
#line 2123
                new___0->cs = cs;
#line 2123
                new___0->arg = (char *)"";
#line 2123
                new___0->next = flags;
#line 2123
                flags = new___0;
                }
#line 2123
                if ((unsigned long )new___0->arg == (unsigned long )((char *)0)) {
#line 2123
                  flagslen ++;
                } else {
#line 2123
                  flagslen += 4U;
                }
                {
#line 2123
                tmp___4 = __ctype_b_loc();
                }
#line 2123
                if (! ((int const   )*(*tmp___4 + (int )cs->c) & 8)) {
                  {
#line 2123
                  tmp___3 = strlen((char const   *)cs->long_name);
#line 2123
                  flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___3));
                  }
                }
#line 2123
                goto while_break___1;
              }
              while_break___1: /* CIL Label */ ;
              }
            } else {
#line 2120
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 2124
          if ((int const   )cs->c == 106) {
            {
#line 2126
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 2126
              tmp___5 = __builtin_alloca(sizeof(struct flag ));
#line 2126
              new___1 = (struct flag *)tmp___5;
#line 2126
              new___1->cs = cs;
#line 2126
              new___1->arg = (char *)"1";
#line 2126
              new___1->next = flags;
#line 2126
              flags = new___1;
              }
#line 2126
              if ((unsigned long )new___1->arg == (unsigned long )((char *)0)) {
#line 2126
                flagslen ++;
              } else {
#line 2126
                flagslen += 7U;
              }
              {
#line 2126
              tmp___7 = __ctype_b_loc();
              }
#line 2126
              if (! ((int const   )*(*tmp___7 + (int )cs->c) & 8)) {
                {
#line 2126
                tmp___6 = strlen((char const   *)cs->long_name);
#line 2126
                flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___6));
                }
              }
#line 2126
              goto while_break___2;
            }
            while_break___2: /* CIL Label */ ;
            }
          } else {
            {
#line 2129
            tmp___8 = __builtin_alloca(30UL);
#line 2129
            buf___0 = (char *)tmp___8;
#line 2130
            sprintf((char */* __restrict  */)buf___0, (char const   */* __restrict  */)"%u",
                    *((unsigned int *)cs->value_ptr));
            }
            {
#line 2131
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
#line 2131
              tmp___9 = __builtin_alloca(sizeof(struct flag ));
#line 2131
              new___2 = (struct flag *)tmp___9;
#line 2131
              new___2->cs = cs;
#line 2131
              new___2->arg = buf___0;
#line 2131
              new___2->next = flags;
#line 2131
              flags = new___2;
              }
#line 2131
              if ((unsigned long )new___2->arg == (unsigned long )((char *)0)) {
#line 2131
                flagslen ++;
              } else {
                {
#line 2131
                tmp___10 = strlen((char const   *)buf___0);
#line 2131
                flagslen = (unsigned int )((size_t )flagslen + (4UL + 3UL * tmp___10));
                }
              }
              {
#line 2131
              tmp___12 = __ctype_b_loc();
              }
#line 2131
              if (! ((int const   )*(*tmp___12 + (int )cs->c) & 8)) {
                {
#line 2131
                tmp___11 = strlen((char const   *)cs->long_name);
#line 2131
                flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___11));
                }
              }
#line 2131
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
        }
#line 2134
        goto switch_break;
        case_4: /* CIL Label */ 
#line 2138
        if (all) {
#line 2140
          if ((unsigned long )cs->default_value != (unsigned long )((char */* const  */)0)) {
#line 2140
            if (*((double *)cs->value_ptr) == *((double *)cs->default_value)) {
#line 2143
              goto switch_break;
            } else {
#line 2140
              goto _L___3;
            }
          } else
          _L___3: /* CIL Label */ 
#line 2144
          if ((unsigned long )cs->noarg_value != (unsigned long )((char */* const  */)0)) {
#line 2144
            if (*((double *)cs->value_ptr) == *((double *)cs->noarg_value)) {
              {
#line 2147
              while (1) {
                while_continue___4: /* CIL Label */ ;
                {
#line 2147
                tmp___13 = __builtin_alloca(sizeof(struct flag ));
#line 2147
                new___3 = (struct flag *)tmp___13;
#line 2147
                new___3->cs = cs;
#line 2147
                new___3->arg = (char *)"";
#line 2147
                new___3->next = flags;
#line 2147
                flags = new___3;
                }
#line 2147
                if ((unsigned long )new___3->arg == (unsigned long )((char *)0)) {
#line 2147
                  flagslen ++;
                } else {
#line 2147
                  flagslen += 4U;
                }
                {
#line 2147
                tmp___15 = __ctype_b_loc();
                }
#line 2147
                if (! ((int const   )*(*tmp___15 + (int )cs->c) & 8)) {
                  {
#line 2147
                  tmp___14 = strlen((char const   *)cs->long_name);
#line 2147
                  flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___14));
                  }
                }
#line 2147
                goto while_break___4;
              }
              while_break___4: /* CIL Label */ ;
              }
            } else {
#line 2144
              goto _L___2;
            }
          } else {
            _L___2: /* CIL Label */ 
            {
#line 2150
            tmp___16 = __builtin_alloca(100UL);
#line 2150
            buf___1 = (char *)tmp___16;
#line 2151
            sprintf((char */* __restrict  */)buf___1, (char const   */* __restrict  */)"%g",
                    *((double *)cs->value_ptr));
            }
            {
#line 2152
            while (1) {
              while_continue___5: /* CIL Label */ ;
              {
#line 2152
              tmp___17 = __builtin_alloca(sizeof(struct flag ));
#line 2152
              new___4 = (struct flag *)tmp___17;
#line 2152
              new___4->cs = cs;
#line 2152
              new___4->arg = buf___1;
#line 2152
              new___4->next = flags;
#line 2152
              flags = new___4;
              }
#line 2152
              if ((unsigned long )new___4->arg == (unsigned long )((char *)0)) {
#line 2152
                flagslen ++;
              } else {
                {
#line 2152
                tmp___18 = strlen((char const   *)buf___1);
#line 2152
                flagslen = (unsigned int )((size_t )flagslen + (4UL + 3UL * tmp___18));
                }
              }
              {
#line 2152
              tmp___20 = __ctype_b_loc();
              }
#line 2152
              if (! ((int const   )*(*tmp___20 + (int )cs->c) & 8)) {
                {
#line 2152
                tmp___19 = strlen((char const   *)cs->long_name);
#line 2152
                flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___19));
                }
              }
#line 2152
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
          }
        }
#line 2155
        goto switch_break;
        case_2: /* CIL Label */ 
#line 2159
        if (all) {
#line 2161
          sl = *((struct stringlist **)cs->value_ptr);
#line 2162
          if ((unsigned long )sl != (unsigned long )((struct stringlist *)0)) {
#line 2167
            i = sl->idx;
            {
#line 2168
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 2168
              tmp___25 = i;
#line 2168
              i --;
#line 2168
              if (! (tmp___25 > 0U)) {
#line 2168
                goto while_break___6;
              }
              {
#line 2169
              while (1) {
                while_continue___7: /* CIL Label */ ;
                {
#line 2169
                tmp___21 = __builtin_alloca(sizeof(struct flag ));
#line 2169
                new___5 = (struct flag *)tmp___21;
#line 2169
                new___5->cs = cs;
#line 2169
                new___5->arg = *(sl->list + i);
#line 2169
                new___5->next = flags;
#line 2169
                flags = new___5;
                }
#line 2169
                if ((unsigned long )new___5->arg == (unsigned long )((char *)0)) {
#line 2169
                  flagslen ++;
                } else {
                  {
#line 2169
                  tmp___22 = strlen((char const   *)*(sl->list + i));
#line 2169
                  flagslen = (unsigned int )((size_t )flagslen + (4UL + 3UL * tmp___22));
                  }
                }
                {
#line 2169
                tmp___24 = __ctype_b_loc();
                }
#line 2169
                if (! ((int const   )*(*tmp___24 + (int )cs->c) & 8)) {
                  {
#line 2169
                  tmp___23 = strlen((char const   *)cs->long_name);
#line 2169
                  flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___23));
                  }
                }
#line 2169
                goto while_break___7;
              }
              while_break___7: /* CIL Label */ ;
              }
            }
            while_break___6: /* CIL Label */ ;
            }
          }
        }
#line 2172
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
#line 2095
    cs ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2175
  flagslen = (unsigned int )((unsigned long )flagslen + (4UL + sizeof(posixref)));
#line 2181
  tmp___26 = __builtin_alloca((unsigned long )((1U + flagslen) + 1U));
#line 2181
  flagstring = (char *)tmp___26;
#line 2182
  p = flagstring;
#line 2183
  words = 1U;
#line 2184
  tmp___27 = p;
#line 2184
  p ++;
#line 2184
  *tmp___27 = (char )'-';
  }
  {
#line 2185
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 2185
    if (! ((unsigned long )flags != (unsigned long )((struct flag *)0))) {
#line 2185
      goto while_break___8;
    }
    {
#line 2188
    tmp___31 = __ctype_b_loc();
    }
#line 2188
    if ((int const   )*(*tmp___31 + (int )(flags->cs)->c) & 8) {
#line 2195
      tmp___30 = p;
#line 2195
      p ++;
#line 2195
      *tmp___30 = (char )(flags->cs)->c;
    } else {
      {
#line 2190
      tmp___28 = p;
#line 2190
      p ++;
#line 2190
      *tmp___28 = (char )'-';
#line 2191
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)(flags->cs)->long_name);
#line 2192
      tmp___29 = strlen((char const   *)p);
#line 2192
      p += tmp___29;
      }
    }
#line 2196
    if ((unsigned long )flags->arg != (unsigned long )((char *)0)) {
#line 2202
      if ((int )*(flags->arg + 0) != 0) {
        {
#line 2205
        tmp___32 = p;
#line 2205
        p ++;
#line 2205
        tmp___34 = __ctype_b_loc();
        }
#line 2205
        if ((int const   )*(*tmp___34 + (int )(flags->cs)->c) & 8) {
#line 2205
          *tmp___32 = (char )' ';
        } else {
#line 2205
          *tmp___32 = (char )'=';
        }
        {
#line 2206
        p = quote_as_word(p, flags->arg, 1);
        }
      }
#line 2208
      words ++;
#line 2210
      tmp___35 = p;
#line 2210
      p ++;
#line 2210
      *tmp___35 = (char )' ';
#line 2211
      tmp___36 = p;
#line 2211
      p ++;
#line 2211
      *tmp___36 = (char )'-';
    } else {
      {
#line 2213
      tmp___39 = __ctype_b_loc();
      }
#line 2213
      if (! ((int const   )*(*tmp___39 + (int )(flags->cs)->c) & 8)) {
#line 2215
        words ++;
#line 2218
        tmp___37 = p;
#line 2218
        p ++;
#line 2218
        *tmp___37 = (char )' ';
#line 2219
        tmp___38 = p;
#line 2219
        p ++;
#line 2219
        *tmp___38 = (char )'-';
      }
    }
#line 2221
    flags = flags->next;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 2226
  if ((unsigned long )p == (unsigned long )(flagstring + 1)) {
#line 2228
    *(flagstring + 0) = (char )'\000';
  } else
#line 2229
  if ((int )*(p + -1) == 45) {
#line 2232
    p -= 2;
#line 2233
    *p = (char )'\000';
  } else {
#line 2237
    *p = (char )'\000';
  }
  {
#line 2241
  define_variable((char *)"MFLAGS", 6U, flagstring, (enum variable_origin )1, 1);
  }
#line 2243
  if (all) {
#line 2243
    if ((unsigned long )command_variables != (unsigned long )((struct command_variable *)0)) {
#line 2248
      if ((unsigned long )p == (unsigned long )(flagstring + 1)) {
#line 2250
        p = flagstring;
      } else {
#line 2254
        if ((int )*(p + -1) != 45) {
#line 2257
          tmp___40 = p;
#line 2257
          p ++;
#line 2257
          *tmp___40 = (char )' ';
#line 2258
          tmp___41 = p;
#line 2258
          p ++;
#line 2258
          *tmp___41 = (char )'-';
        }
#line 2261
        tmp___42 = p;
#line 2261
        p ++;
#line 2261
        *tmp___42 = (char )'-';
#line 2262
        tmp___43 = p;
#line 2262
        p ++;
#line 2262
        *tmp___43 = (char )' ';
      }
#line 2266
      if (posix_pedantic) {
        {
#line 2268
        memmove((void *)p, (void const   *)(posixref), sizeof(posixref) - 1UL);
#line 2269
        p += sizeof(posixref) - 1UL;
        }
      } else {
        {
#line 2273
        memmove((void *)p, (void const   *)(ref), sizeof(ref) - 1UL);
#line 2274
        p += sizeof(ref) - 1UL;
        }
      }
    } else {
#line 2243
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 2277
  if ((unsigned long )p == (unsigned long )(flagstring + 1)) {
#line 2279
    words = 0U;
#line 2280
    p --;
  } else
#line 2282
  if ((int )*(p + -1) == 45) {
#line 2284
    p -= 2;
  }
#line 2286
  *p = (char )'\000';
#line 2288
  if ((int )*(flagstring + 0) == 45) {
#line 2288
    if ((int )*(flagstring + 1) != 45) {
#line 2288
      tmp___44 = 1;
    } else {
#line 2288
      tmp___44 = 0;
    }
  } else {
#line 2288
    tmp___44 = 0;
  }
  {
#line 2288
  v = define_variable((char *)"MAKEFLAGS", 9U, flagstring + tmp___44, (enum variable_origin )2,
                      1);
  }
#line 2302
  if (! all) {
#line 2306
    v->export = (enum __anonenum_export_56 )0;
  }
#line 2307
  return;
}
}
#line 2314 "/home/khheo/testset/make-3.76.1/main.c"
static int printed_version  =    0;
#line 2311 "/home/khheo/testset/make-3.76.1/main.c"
static void print_version(void) 
{ 
  char *precede ;
  char const   *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 2316
  if (print_data_base_flag) {
#line 2316
    tmp = "# ";
  } else {
#line 2316
    tmp = "";
  }
#line 2316
  precede = (char *)tmp;
#line 2318
  if (printed_version) {
#line 2320
    return;
  }
  {
#line 2322
  printf((char const   */* __restrict  */)"%sGNU Make version %s", precede, version_string);
  }
#line 2323
  if ((unsigned long )remote_description != (unsigned long )((char *)0)) {
#line 2323
    if ((int )*remote_description != 0) {
      {
#line 2324
      printf((char const   */* __restrict  */)"-%s", remote_description);
      }
    }
  }
  {
#line 2326
  printf((char const   */* __restrict  */)", by Richard Stallman and Roland McGrath.\n%sCopyright (C) 1988, 89, 90, 91, 92, 93, 94, 95, 96, 97\n%s\tFree Software Foundation, Inc.\n%sThis is free software; see the source for copying conditions.\n%sThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\n%sPARTICULAR PURPOSE.\n\n%sReport bugs to <bug-gnu-utils@prep.ai.mit.edu>.\n\n",
         precede, precede, precede, precede, precede, precede);
#line 2335
  printed_version = 1;
#line 2339
  fflush(stdout);
  }
#line 2340
  return;
}
}
#line 2344 "/home/khheo/testset/make-3.76.1/main.c"
static void print_data_base(void) 
{ 
  time_t when ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 2349
  when = time((time_t *)0);
#line 2350
  tmp = ctime((time_t const   *)(& when));
#line 2350
  printf((char const   */* __restrict  */)"\n# Make data base, printed on %s", tmp);
#line 2352
  print_variable_data_base();
#line 2353
  print_dir_data_base();
#line 2354
  print_rule_data_base();
#line 2355
  print_file_data_base();
#line 2356
  print_vpath_data_base();
#line 2358
  when = time((time_t *)0);
#line 2359
  tmp___0 = ctime((time_t const   *)(& when));
#line 2359
  printf((char const   */* __restrict  */)"\n# Finished Make data base on %s\n", tmp___0);
  }
#line 2360
  return;
}
}
#line 2368 "/home/khheo/testset/make-3.76.1/main.c"
static char dying  =    (char)0;
#line 2364 "/home/khheo/testset/make-3.76.1/main.c"
void die(int status ) 
{ 
  int err ;

  {
#line 2370
  if (! dying) {
#line 2374
    dying = (char)1;
#line 2380
    if ((unsigned long )directory_before_chdir != (unsigned long )((char *)0)) {
      {
#line 2381
      chdir((char const   *)directory_before_chdir);
      }
    }
#line 2383
    if (print_version_flag) {
      {
#line 2384
      print_version();
      }
    }
#line 2387
    err = status != 0;
    {
#line 2387
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2387
      if (! (job_slots_used > 0U)) {
#line 2387
        goto while_break;
      }
      {
#line 2388
      reap_children(1, err);
#line 2387
      err = 0;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2391
    remote_cleanup();
#line 2394
    remove_intermediates(0);
    }
#line 2396
    if (print_data_base_flag) {
      {
#line 2397
      print_data_base();
      }
    }
    {
#line 2399
    log_working_directory(0);
    }
  }
  {
#line 2402
  exit(status);
  }
}
}
#line 2412 "/home/khheo/testset/make-3.76.1/main.c"
static int entered  =    0;
#line 2408 "/home/khheo/testset/make-3.76.1/main.c"
void log_working_directory(int entering ) 
{ 
  char *message___0 ;
  char const   *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 2413
  if (entering) {
#line 2413
    tmp = "Entering";
  } else {
#line 2413
    tmp = "Leaving";
  }
#line 2413
  message___0 = (char *)tmp;
#line 2418
  if (! print_directory_flag) {
#line 2419
    return;
  } else
#line 2418
  if (entering == entered) {
#line 2419
    return;
  }
#line 2421
  entered = entering;
#line 2423
  if (print_data_base_flag) {
    {
#line 2424
    fputs((char const   */* __restrict  */)"# ", (FILE */* __restrict  */)stdout);
    }
  }
#line 2426
  if (makelevel == 0U) {
    {
#line 2427
    printf((char const   */* __restrict  */)"%s: %s ", program, message___0);
    }
  } else {
    {
#line 2429
    printf((char const   */* __restrict  */)"%s[%u]: %s ", program, makelevel, message___0);
    }
  }
#line 2431
  if ((unsigned long )starting_directory == (unsigned long )((char *)0)) {
    {
#line 2432
    puts("an unknown directory");
    }
  } else {
    {
#line 2434
    printf((char const   */* __restrict  */)"directory `%s\'\n", starting_directory);
    }
  }
#line 2435
  return;
}
}
